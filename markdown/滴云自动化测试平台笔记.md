<title>Hello World</title>
<meta name="userId" content="486PE774616790144233547fTOKhPX"/>
![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第一章 架构项目大课-滴云自动化测试平台大课介绍



#### 第1集 架构基础设施-滴云自动化测试平台课程介绍

**简介：架构基础设施-滴云自动化测试平台课程介绍**

* **备注：这一章主要是围绕大课海报进行介绍，比较急的兄弟 可以适当倍速播放哈**

* 云测平台效果体验，正式域名为  dmeter.cn

* 前言

  * **架构项目大课-自动化云测平台**，准备近1年的**综合性实战项目**【**全新业务领域+独家项目经验**】
  * 从0~1开发商用自动化测试平台，从产品需求文档定制出发，架构方案设计到代码落地；
  * 从**技术组长的视角**开始，包括**架构设计**、架构图绘制，**技术选型，难点攻克**，监控告警，**DevOps部署上线**等；
  * 结合**云架构大课十八式里面多个技术栈**+中间件底层思想综合应用，**开发大型商业化中间件项目**
  
  <img src="img/image-20231216154915304.png" alt="image-20231216154915304" style="zoom:50%;" />
  
* 项目亮点和核心技术体系

  - **全新升级技术：最新AlibabaCloud全家桶+JDK17+SpringBoot3.X+海量数据处理+超多实用java生态类库**
- 滴云自动化压测平台是**全新的业务领域，独家原创项目**，**全网都没这个方向的视频教程**，简历跳槽则**独领风骚**
  - **一站式自动化云测试平台**，基于**JMeter5.X、Selenium4.X** 最新主流框架开发，解耦各个模块独立使用+定制
- **使用云测平台DCloudTest**，相当于 Postman + Swagger + Mock+ JMeter+Selenium **更加先进开发测试工具**



* 项目竞争力和架构能力
  - 提供**不同技术解决方案利弊分析**，基于业务和团队**做出最佳技术决策,**系统掌握**技术架构+业务驱动+团队管理**
  - 基于架构分析方法论：**业务痛点**-〉分析问题-〉行业方案对标-〉**最佳方案**-〉技术攻克-〉落地实践



* 核心业务模块和应用场景
  - 深入掌握**自动化云测平台底层原理**，三大核心模块包括：**接口自动化引擎、UI自动化引擎、压力测试引擎**
  - **高效提升**开发和测试团队进行**自动化接口测试、业务场景编排测试、压力负载测试**，加快高质量的软件交付
  - 全SaaS化形态，**无需额外安装和部署，支持复杂场景的可视化+自动化测试编排**，自研平台更可靠+定制化强
  - **DevOps一键启动公有云端测试**+持续监控告警+**自动生成测试报告**+可视化数据大屏+**丰富数据报表下载**



* **滴云自动化测试平台讲师：二当家小D**
  * 职业背景：阿里巴巴担任多个项目负责人，**阿里云栖社区技术专家/荔枝FM架构师**，现任小滴科技CTO
  * 授课经验：CSDN、51CTO、**小滴课堂金牌讲师**，累计观看用户**500万+**
  * 擅长技术：**10年开发架构经验**，擅长分布式高并发架构/大数据处理/自动化测试/微服务容器/k8s等领域
  * 其他介绍：
    * 学历：**学信网可查 最高大专，中大本科-挂科未拿到毕业证**
    * 英文能力：CET-6；
    * 本科院校：计算机专业课程-讲师
  * 备注：
    * 小滴课堂是**2016年成立至今**，讲师团队基本都是互联网大厂在职“老油条”工程师
    * **把正在做的或者已经完成的项目抽出来录制课程，实打实的互联网大厂项目实操！！！**

<img src="img/image-20231216155123589.png" alt="image-20231216155123589" style="zoom:50%;" />

















#### 第2集 滴云自动化测试平台常见问题和适合人群

**简介：滴云自动化测试平台常见问题和适合人群**

* 云测平台项目大课对应岗位能力
  * 掌握【产品分析+**技术解决方案**+团队管理方法论】，**从0到1**开发商业级大型项目，**架构设计到代码落地实现**
  * **技术**：对标**阿里P7架构师**能力级别+**全新业务**领域技术挑战+**难点攻克方法论【深度+广度】**
  * **管理**：**带5到10人团队**+项目管理+**架构设计方案**+开发进度+**工时评估+风险评估方法论**
  * **薪资**：一线城市**年总包40到70万**、**月薪20到40k**



* 常见疑惑点

  * **为什么要学**自动化云测平台项目大课
    - 互联网公司**基本离不开接口测试**，常规一个项目开发完成上线，需要**多个测试人员测试**对应的功能、接口等
    - 常规的功能测试，**多数公司**会用
    - **、Swagger**、**Selenium、Jmeter**或者自己写脚本完成接口测试。
    - **缺点**
      - 每次测试**都需要安装相关环境**、包括Jdk、Python等，而且自动化测试**还需要浏览器驱动**
      - 不同版本还**存在兼容性问题**，**语法也不一样**，测试人员**工作效率低**、维护多个测试工具
      - 每次测试都需要**重新部署环境**、且**容易丢失**，自动化测试**脚本分散，版本不一致、维护性差**
      - 测试**报告没统一**，**没有留存**且**不灵活**，**不支持在线预览和分享同步，**还有更多问题
    - **解决方案**
      - **学完**我们这个**自动化云测平台**，**都可以完美解决上面问题**
      - 通过浏览器，**一键开启接口自动化测试、Selenium** **UI**自动化测试、 Jmeter性能测试
      - 支持**多接口场景编排、多接口关联测试、一键分享测试报告**和定制化内容，还有更多...
      - 支持私有云和公有云部署，一次部署四处运行，99%技术公司都需要的项目平台
  
  <img src="img/image-20231216155345871.png" alt="image-20231216155345871" style="zoom:50%;" />
  
  * 这个是**后端java工程师学的课程**，**是否适合**测试工程师吗？
    - 这个**不是面试初级测试工程师**学的，**属于后端架构项目大课**，适合**后端或高级测试工程师**学习
    - 我们这个属于公司**核心的效能平台**、架构基础设施平台，一般互联网大厂里面**都会有类似平台**
    - 一般是**由公司的后端java开发人员**、技术组长、架构师等**负责开发**，用于**给全公司技术团队使用**的平台
    - 提高**开发速度、保证质量和节省人力，降低成本**，尤其是当下的大环境里面，**越来越多公司需要**这类经验
  
  
  
  * 这个是怎样的项目，**功能是否完整**和**前端页面开发**?
    - 任何项目都是**有版本迭代**的, 自动化云测平台是**完整可以上线的大型项目**
    - 大课项目**属于综合项目**，各个服务核心链路+**业务难点是齐全的**
    - 大课**不讲前端页面开发**，提供**完整前端代码和核心对接联调**，后端内容远比写前端页面**强N倍**
  
  
  
  * 大项目怎么**写进简历里面**，面试官问**在线地址是否有**，应该怎么答
    - 任何互联网**公司产品基本都离不开**自动化测试，自动化云测平台**都适合写进去**，课程**会详细讲解简历编写**
    - 金三银四前小滴课堂**会把项目部署上线**，且是**对外商用**的平台，大家可以**告知网站地址**
    -  自动化云测平台**支持私有化部署**，**说哪个公司都可以**，课程再简历章集**会讲怎么完美回答**
  
  
  
  * 大课里面**技术栈很多**，我只**会部分能否学**大课？
    - **AlibabaCloud/Redis/Kafka是必须先会的**，参加大课可以5折购买
    - 如果你学过我们这边**任何一个项目大课**，即**可直接学**自动化云测平台大课
    - 强烈**根据视频进度学**，然后**群里讨论+学习氛围**，不管是跳槽OR提升本身技术



* 云测平台项目大课适合人员
  * **工作多年重复做CRUD**的同学**，**缺少亮点**的简历项目，**工作1年以上需要2个以上亮点项目
  * 自动化云压测平台 适合 电商、在线教育、多媒体、金融保险、物流、营销、社交、传统IT行业 等领域公司
  * **超通用**的大型**互联网项目**经验，**99%公司都可以包装**，且适合直接使用
  * 过往项目经验都是常规业务开发，**缺少架构基础设施平台开发经验**的同学
  * 工作几年**技术成长遇到瓶颈**，对**不同业务领域场景不清楚解决方案**的同学
  * **工作1到5年的后端工程师**/技术经理，传统IT企业**转行互联网公司**
  * 本科、研究生 **校招计划进一线大厂**的同学（**国内/海外大厂都可以**）
  * 计划**跳槽一线大厂**或者冲刺年总包40~100万【**全新业务领域+独家项目经验**】
  * **目标成为 技术组长、技术总监、架构师** 的同学



*  **学了大课后那些场景可以用呢？**
  - 【测试需求】很多公司项目都有 接口测试、自动化测试、多接口编排场景测试、Web功能测试、压力测试、性能测试需求
  - 【企业商用】**掌握这个大课项目，独立开发完成这个云测平台，可以直接公司使用，99%公司都需要的架构基础设施平台**
  - 【授权使用】**买过大课**的同学，这边都**永久授权使用**，公司内部**私有化部署**或者公有部署
  - 【技术规划】本身**有带技术团队**的同学，可以把这个**纳入公司技术规划**，**提高开发和测试的效率**，更可靠和高效的交付项目











#### 第3集  滴云自动化测试平台核心技术亮点概述

**简介：滴云自动化测试平台核心技术亮点概述**

* 架构项目大课-自动化云测平台核心亮点（P3、P2、P1难度逐级上降）

  * P3（**提升技术广度-稳固基础设施**）

    - 云测平台**多账号登录体系**数据库**设计和编码实现**，支持手机-邮箱-社交账号
    - 最火的**轻量级权限认证框架SaToken**+整合AlibabaCloud微服务
    - **业务数据隔离控制**/项目空间/模块管理/接口管理+ **变更实时自动同步**
    - AlibabaCloud**微服务划分**/工程搭建/代码管理/**编码规范扫描**
    - **中间件一键部署**Kafka3.X/Redis7.X/Mysql8.X/MinIO/时序数据库/Prometheus等
    - **可视化实时监控+告警**，时序数据库InfluxDB+Grafana+**Prometheus**

    

  * P2（**技术驱动业务发展-难点攻克**）

    - 大厂项目管理中的**工时评估方法论**和**新领域项目风险把控技巧**
    - **源码封装StandardJMeterEngine自定义**压测引擎实战
    - 本地上传JMX结合压测引擎和**动态生成压测脚本**实战
    - **云端**压测**生成可视化压测报告**和**多文件打包压缩**下载实战
    - 自定义**在线**压测**聚合报告统计分析**和性能测试**报告在线分享**
    - 支持**HTTP多方法**测试**在线Web端接口测试**工具和**响应结果可视化**
    - 在线**API接口自动化测试**和可视化拖拽**多接口场景编排测试**
    - 数据驱动测试，支持**多文件格式参数导入读取**
    - **从0到1设计**公司自己的**自动化接口测试框架**和**可视化的断言**
    - **SpringBoot3.X二次封装Selenium**静默执行和**快照截图存储**
    - 支持丰富的**UI自动化测试报告**和多维度测试指标分析
    - **前后端分离架构**,基于**前端主流框架**+UI库+可视化图形报表 +**联调+前端部署上线**

    

  * P1（**架构综合能力-技术深度-核心板块攻坚**）

    - 掌握**架构分析方法论**，基于团队技术和业务需求**推断最合适的方案**
    - 滴云**自动化**压测**平台架构设计**和**多架构图分层绘制**
    - **新版SpringBoot3.X集成Jmeter5.X** 技术**多解决方案分析和业务选择**
    - SpringBoot3.X**二次封装Jmeter源码**实现**自定义**压测结果收集上报
    - 深入Jmeter压测链路+**java自定义创建测试计划/线程组/循环控制器/采样器**
    - **自定义ResultCollector整合Kafak实时收集数据和持久化存储**
    - 大型自动化**云测平台Mysql数据库模型设计**和SQL**索引优化实战**
    - 海量数据**存储技术选择**和数据库**执行计划分析+性能优化实战**
    - 自动化**多接口关联测试**和**上下文接口数据提取**实战
    - Selenium4.X **UI自动化测试引擎**整合**SpringBoot3.X封装**组件
    - 零代码或者**低代码整合Selenium 浏览器自动化测试**，高度可复用的测试脚本
    - Selenium **Web端**UI**自动化测试场景编排**，一键启动自动化测试
    - **技术Leader方法论**和团队管理技巧、**技术面试官成长法则**
    - 自动化云测平台**上线服务器资源评估**和**文件数据清理归档实战**
    - **DevOps自动化部署** Jenkins CICD + 阿里云Git仓库+ 阿里云ECS 服务器+ Docker容器编排调度
    - **技术组长或高级工程师简历编写和面试回答**



* 注意
  * 滴云自动化测试平台【**部分技术栈会调整变动**】，也是技术选型能力的提升
  * **遇到需求->想出多个解决方案->如何挑选->怎么判断是最适合的**

<img src="img/image-20231216155823586.png" alt="image-20231216155823586" style="zoom:50%;" />













#### 第4集 【特重要】大课代码-安装包-笔记资料下载指南

**简介：【重要】大课代码-安装包-笔记资料下载指南**

* 【重要】资料下载和注意事项

  * 更新频率：**每月1号和15号更新**（如果遇到假期延后或提前，看课程内容连贯而定），每次25到50集不等

  * 观看形式：**本地观看，无需联网，支持手机+PC**

  * **同学权益保护+溯源技术**

    - 资料笔记代码 从官网下载采用**阿里内网的溯源技术**，每个人的资料都是独一无二【**切记勿恶意泄露**】
    - 课程著作权已经同步申请+广州某法务部合作，**恶意侵权直接【广州互联网法院】**起诉
    - 包括**不限于代码文件**、图片、pdf、html、md文档都**可追踪到泄露人**【**溯源技术不可见、不可擦除**】

  * 务必进大课群【**每周更新：仓库地址、AppID、秘钥，IP、端口**】

    - 课程依赖多个**私有依赖库+代码环境部署+资料包**，需要获取才可以部署和实操
    - 大课群有提供远程仓库地址、密钥、代码等多个实操内容

    <img src="img/image-20231216142605209.png" alt="image-20231216142605209" style="zoom:30%;" />

    - **包括课程学习过程问题答疑+技术协助**
    - **课程里也有多个作业提交，不加统一答案**（会有技术讲师点评和评分）

  * 社群里**技术答疑**+讨论+学习氛围+**内推招聘**

  * 增值服务

    - 非会员的同学，基础技术栈不会，可以5折购买
    - **课程作业多解决方案点评+项目技能补充+简历辅导+过往项目辅导+职业规划+专属内推**



* 我的私人联系方式

<img src="img/image-20231216141230565-2707152.png" alt="image-20231216141230565" style="zoom:50%;" />







![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第二章 架构能力-自动化测试平台需求文档和架构图



#### 第1集 【重要】滴云自动化测试平台需求文档介绍《上》

**简介：滴云自动化测试平台需求文档介绍**

* 大家最多的疑惑，为啥要做这个项目？

<img src="img/image-20231216160113303.png" alt="image-20231216160113303" style="zoom:50%;" />

* 需求文档分析

  * 项目前言
  * 版本信息
  * 变更日志
  * 文档说明
  * 需求背景（面试重点）
  * 竞品分析（行业解决方案-面试重点）

  















#### 第2集 【重要】滴云自动化测试平台需求文档介绍《下》

**简介：滴云自动化测试平台需求文档介绍**

* 需求文档分析

  * 功能说明

    * 交换流程图-这个一般是产品经理做的，但技术人员用的基础设施平台，**普通产品经理理解不了痛点**，包括专业术语也不懂

    * 所以这类平台，一般就是由技术组长或者架构师进行设计和说明，**技术人员才懂技术人员的痛点**

    <img src="img/image-20231216160443667.png" alt="image-20231216160443667" style="zoom:50%;" />

  * 非功能需求

  * 项目规划（行业解决方案-面试重点）



* 听到这里，不少同学还是有的蒙的
  * 没关系，我知道大家的疑惑，毕竟第一次接触【架构基础设施类的业务项目】
  * 包括后续的设计和开发，特别是每个测试引擎
    * 我会先抛出如果没这个平台时大家怎么做，存在什么问题，基于这些问题，如何用平台去解决。
    * 包括很多专业术语、测试开发知识点我也会教大家，所以不用担心，跟着我走就可以
    * **数据库设计也是好几十张表，但我不一次性设计，特别多专业术语大家也会蒙的，我们堆积木的方式一步步进行**

<img src="img/image-20231216151911857.png" alt="image-20231216151911857" style="zoom:50%;" />













#### 第3集 温故而知新-架构图的作用和绘制技巧

**简介：温故而知新-架构图的作用和绘制技巧**

* 什么是架构图？
  - 架构图 = 架构 + 图
  - 用图的形式把系统架构展示出来，配上简单的文案

![image-20231216151243297](img/image-20231216151243297.png)

* 架构图是给人看的，这些人我们习惯称为【业务方、客户】，有哪些人？
  - 人员
    - 上级：你的公司Leader(晋升汇报)、老板、外部投资人
    - 团队内：产品、运营、测试、技术、运维同学
    - 外部：最终系统使用的用户
  - 好比阿里这边评定绩效，有一项就是业务方评分
    - 你做的外部用户的活动系统，测试同学会进行测试，太多bug肯定就不行
    - 你做的给运营同学使用的系统，不能提升她运营的效率，业务方是否满意？

* 画架构图是为了什么

  - 一图胜千言，解决沟通障碍，给不同的【业务方】看懂
  - 业务方很多，不同人看到角度不一样，你让【产品经理】看 【物理部署视图】他看得懂？

  ![image-20220812144458500](img/image-20220812144458500.png)

* 为什么要搞出这么多个架构图？用一个图不行吗？

  - 一开始确实是一个图表示系统架构设计
  - 但是业务方很多，不同人看到角度不一样，你让软件用户看物理部署视图？他看得懂？
    - 要明确沟通交流面向的客户
    - 开发人员、运维人员、项目经理、软件最终用户、客户
  - 架构图包括 功能需求、部署需求、流程需求等太复杂，所以还是要单一职责模式
  - 不同架构视图承载不同的架构设计决策，支持不同的目标和用途
  - 架构图也不能太多（过度文档化）维护更新起来成本大



- 不同架构图应该使用哪种方法来画?
  - 可以用的表示法和工具很多，没有太多的限制，把握对应的视图关注点才是关键
    - Xmind、EdrawMax、PPT、PowerDesigner
    - OmniGraffle、Visio、Process On
  - 开始阶段不要陷入过度设计中，没那么多需求不一定要那么多图（你是否有那么多客户）



* 常见架构图作用对比
  * 业务架构
    - 表达业务是如何开展的，服务于业务目标，通过描绘业务上下层关系，简单的业务视图降低业务系统的复杂 
  * 应用架构
    - 是对整个系统实现的总体架构 ,  应用架构和**系统架构**很大类似
    - 一方面承接业务架构的落地，一方面影响技术选型
    - 注意：一般应用架构图【不加入太多技术框架和实现】
  * 技术架构
    - 应用架构本身只关心需要哪些应用系统，不关心在整个项目中你需要使用哪些技术
    - 技术架构则是实现应用架构的承接方，识别技术需求，进行技术选型，描述技术之间的关系
    - 解决的问题包括
      - 技术层面的分层、开发语言、框架的选择
      - 通信技术、存储技术的选择、非功能性需求的技术选择等















#### 第4集 老王是个画家-教你画高大上的业务架构图

**简介：老王是个画家-教你画高大上的业务架构图**

- 在画架构图之前，想清楚3个问题，架构图想表达什么？有什么用？给谁看？
  - 表达是业务系统之间的关系，梳理业务结构
  - 将复杂的业务逻辑简单化，降低理解难度，更方便业务方理解
  - 给业务方查看，业务相关干系人

<img src="img/image-20231216152007307.png" alt="image-20231216152007307" style="zoom:50%;" />

- 业务架构图
  - 表达业务是如何开展的，服务于业务目标，通过描绘业务上下层关系，简单的业务视图降低业务系统的复杂度，提高客户理解度
  - 图中【尽量不出现技术】的字眼，不同架构图的读者是不同的，确保能看懂。
  - 架构图中模块的划分粒度，一定要合适，既不能太宽泛，也不能太细粒度
  - 无技术背景人员可参与实现的讨论，向技术人员描述解决方案核心要做什么，必须实现的关键是什么
  - 明白一个点
    - 先有业务，再有系统，微服务/系统/中心  是类似概念
    - 系统是来实现业务的，比如电商业务里面A系统、B系统

* 业务架构类型

  - 上中下结构：用户展现层-业务平台层-公共能力层-数据存储层-基础资源层
    - 案例一（图片来源-阿里云数字政府）

  ![2.jpg](img/ebe4e0e3317f4b228a845245a1c1b360.png)

  - 左中右结构：上游产业 - 业务平台- 下游产业
    - 相对较少用，就是倒置过去

* 画图三步走（**不同架构图通用法则**）

  - 分层 
    - 业务按照层级进行划分，各个层级属于独立的版块 
    - 下层为上层提供服务能力支撑，比如：laaS / PaaS / SaaS 
  - 分模块
    - 同层级中进行小归类；属于平行关系，可以独立存在
    - 理清架构图类型、业务要全面、专业术语一致、图形清晰美观、颜色类型划分合理
      - 不同颜色可以表示当下要做的，未来要做的
  - 分功能
    - 独立功能划分出来，即业务入口
    - 业务方重点关注的功能点，可以认为是微服务划分

  ![image-20231216154010493](img/image-20231216154010493.png)

* 如何判断架构图的好和坏？
  - 业务抽象设计的合理性，是否满足高内聚、低耦合的要求，不能太宽泛，也不能太细粒度
  - 层级划分目标系统边界，自下而上 或 由上而下，一般包括 基础设施、数据层、应用层、用户层四个层次
  - 纵向分层 上层依赖于下层越底层，越是基础服务；横向并列关系，级别相同
  - 理清架构图类型、业务要全面、专业术语一致、图形清晰美观、颜色类型划分合理
  - 最重要是：**你的业务方能 满意+看懂！！！**











#### 第5集 滴云自动化测试平台应用架构图介绍

**简介：滴云自动化测试平台业务架构图介绍**

* 什么是应用架构图

  - 是对整个系统实现的总体架构 ,  应用架构和**系统架构**很大类似

  - 一方面承接业务架构的落地，一方面影响技术选型

    * 注意：一般应用架构图【不加入太多技术框架和实现】

  - 作用

    - 根据业务场景 对系统进分层，指出开发的原则、系统各个层次的应用服务
    - 指导软件的研发，包括不限于 制定应用规范、定义接口和数据交互协议，满足功能性需求和非功能性需求

  - 业务方

    - **研发人员，各层级架构师，各层级技术管理者**

  - 分类

    - 多系统应用架构，用来分层次说明不同系统间的业务逻辑关系、系统边界等，比如 分布式、微服务
    - 单系统应用架构，用来分层次说明系统的组成模块和功能点之间的业务逻辑关系，比如单体应用

  - 常规分层
    - 表示-展现层：负责用户体验
    - 业务-服务层：负责业务逻辑
    - 数据-访问层：负责数据库存取

* 画图三步走
  - 分层 
    - 业务按照层级进行划分，各个层级属于独立的版块 
    - 下层为上层提供服务能力支撑，比如：laaS / PaaS / SaaS 
  - 分模块
    - 同层级中进行小归类；属于平行关系，可以独立存在
    - 理清架构图类型、业务要全面、专业术语一致、图形清晰美观、颜色类型划分合理
      - 不同颜色可以表示当下要做的，未来要做的
  - 分功能
    - 独立功能划分出来，即业务入口
    - 业务方重点关注的功能点，可以认为是微服务划分

* 滴云自动化测试平台应用架构图（找bug）

![image-20231216153050850](img/image-20231216153050850.png)















#### 第6集 滴云自动化测试平台技术架构和作业提交

**简介：滴云自动化测试平台技术架构和作业提交**

* 什么是技术架构

  - 应用架构本身只关心需要哪些应用系统，不关心在整个项目中你需要使用哪些技术
  - 技术架构则是实现应用架构的承接方，识别技术需求，进行技术选型，描述技术之间的关系
  - 解决的问题包括
    - 技术层面的分层、开发语言、框架的选择
    - 通信技术、存储技术的选择、非功能性需求的技术选择等
  - 案例

  <img src="img/image-20231216153932708.png" alt="image-20231216153932708" style="zoom:50%;" />

  

* 滴云自动化测试平台技术选型（**下面只是部分技术栈**）

  * 基础工具环境：**JDK17或JDK21+IDEA2023**(**全新改版**)+Maven3.9+Linux服务器

  * 微服务技术：**新版SpringCloudAlibaba**全家桶+**SpringBoot3.X**+Nacos2.x+MybatisPlus+Mysql8.X

  * 缓存+主流消息队列：**Redis7.X+Kafak3.X-Kraft架构 **

  * **底层测试引擎**：**Jmeter5.X+StandardJMeterEngine+Selenium4.X+WebDrvier**

  * **海量数据存储+自建分布式文件存储**：Mysql8.0+时序数据库 + 分布式文件存储MinIO

  * 可视化实时监控+告警：**时序数据库InfluxDB+Grafana+Prometheus+告警监控**

  * **前后端分离**架构下的 **Vue3**+ AntDesign+ **丰富可视化图形报表 (提供完整代码)**

  * **DevOps上线部署**：Jenkins **CICD** + 阿里云Git仓库+ **阿里云**ECS **服务器**+ Docker**容器编排调度**

    

- 要求

  - 画出滴云自动化测试平台的技术架构图
  - 工具任选：draw.io、processOn、其他在线工具
  - 云测平台的作业要重视，这些都是切身经历，别到用时方恨少
  - 看10遍不然做1遍，需要达到举一反三能力，不同业务场景

  ![image-20221108110152807](img/image-20221108110152807.png)

- 答案（珍惜机会，点评的作业）

  - 方式一：【截图形式】统一提交给我，加我微信
  - 方式二：云测学习群里提交，@我
  - 方式三：群里分享图片，多交流经验，时间多的可以画多点













![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第三章 滴云自动化测试平台项目环境搭建



#### 第1集 滴云自动化测试平台Linux云服务器和中间件安装

**简介：滴云自动化测试平台本地开发环境和云服务器准备**

* 阿里云服务器选择（CentOS7.8 ，推荐2核4G或4核8G）

* 服务器上安装常用中间件，方便测试（**网络安全组记得开放**）

  * Docker-ce社区版本

  * Mysql8.X
    * 可视化工具自己选择

  * Redis7.X
    * 可视化工具下载地址
    * https://gitee.com/qishibo/AnotherRedisDesktopManager
    * https://github.com/qishibo/AnotherRedisDesktopManager
  * Nacos2.X+Mysql库表导入

* 下载安装包 ，使用**【wget】或者【浏览器】远程下载相关依赖包（需要替换群里最新的）**

  ```
  原生资料下载方式(账号 - 密码 - ip地址 - 端口 需要替换群里最新的，其他路径不变)
  wget --http-user=用户名 --http-password=密码 http://ip:端口/dcloud_test/software_install_part1.zip
  
  
  #比如 命令行下
  wget --http-user=admin --http-password=xdclass.net888 http://47.115.31.28:9088/dcloud_test/software_install_part1.zip
  
  # 比如 浏览器直接访问
  http://47.115.31.28:9088/dcloud_test/software_install_part1.zip
  ```















#### 第2集 新版微服务+SpringBoot3.X本地开发环境创建

**简介：新版微服务+SpringBoot3.X本地开发环境创建**

* 云测大课本地开发环境说明（**大家自行升级版本**）

  * 技术版本

    * Maven-3.9以上

    ![image-20231219140356425](img/image-20231219140356425.png)

    * JDK-17以上

    ![image-20231219140410323](img/image-20231219140410323.png)

    * IDEA-2023旗舰版

  * 框架版本

    * SpringBoot3.X
    * AlibabaCloud 2022.0.0.0-RC2

* 项目创建 dcloud-meter

```
	<modules>
        <module>dcloud-common</module>
        <module>dcloud-account</module>
        <module>dcloud-engine</module>
        <module>dcloud-data</module>
        <module>dcloud-gateway</module>
    </modules>
```



















#### 第3集 滴云自动化测试平台项目依赖初始化搭建实战

**简介：滴云自动化测试平台项目依赖初始化搭建实战**

* 注意: 有些包maven下载慢，等待下载如果失败

  - 删除本地仓库spring相关的包，即.m2目录下的，重新执行 mvn install
  - 建议先使用默认的maven仓库，不用更换地址

  

* 项目依赖配置添加

```
  <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <spring.boot.version>3.0.2</spring.boot.version>
        <spring-cloud.version>2022.0.0</spring-cloud.version>
        <spring-cloud-alibaba.version>2022.0.0.0-RC2</spring-cloud-alibaba.version>
        <jmeter.version>5.5</jmeter.version>

        <satoken.version>1.37.0</satoken.version>
        <rest-assured.version>5.3.2</rest-assured.version>
        <selenium.version>4.10.0</selenium.version>
        <guava.version>32.1.3-jre</guava.version>
        <springdoc.version>2.2.0</springdoc.version>
        <minio.version>8.3.7</minio.version>
        <mybatisplus.version>3.5.3.1</mybatisplus.version>
        <fastjson.version>2.0.42</fastjson.version>
        <hutool.version>5.8.0</hutool.version>
        <mysql.version>8.0.27</mysql.version>
        <lombok.version>1.18.30</lombok.version>
        <common-io.version>2.8.0</common-io.version>
        <common-pool.version>2.11.1</common-pool.version>
    </properties>
```

* 聚合工程依赖配置

```
<!--锁定版本-->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>${spring-cloud-alibaba.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!--引入redis-->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-data-redis</artifactId>
                <version>${spring.boot.version}</version>
            </dependency>

            <!-- Spring整合参数验证 -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-validation</artifactId>
                <version>${spring.boot.version}</version>
            </dependency>

            <!-- kafka -->
            <dependency>
                <groupId>org.springframework.kafka</groupId>
                <artifactId>spring-kafka</artifactId>
                <version>${spring.boot.version}</version>
            </dependency>

            <!--mybatis plus和springboot整合-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>${mybatisplus.version}</version>
            </dependency>

            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>${fastjson.version}</version>
            </dependency>

            <!--hutool工具包-->
            <dependency>
                <groupId>cn.hutool</groupId>
                <artifactId>hutool-all</artifactId>
                <version>${hutool.version}</version>
            </dependency>


            <!--数据库连接-->
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>${mysql.version}</version>
            </dependency>

            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>${lombok.version}</version>
            </dependency>

            <dependency>
                <groupId>commons-io</groupId>
                <artifactId>commons-io</artifactId>
                <version>${common-io.version}</version>
            </dependency>

            <!--jmeter相关包-->
            <dependency>
                <groupId>org.apache.jmeter</groupId>
                <artifactId>ApacheJMeter_http</artifactId>
                <version>${jmeter.version}</version>
                <exclusions>
                    <exclusion>
                        <groupId>org.apache.logging.log4j</groupId>
                        <artifactId>log4j-slf4j-impl</artifactId>
                    </exclusion>
                </exclusions>
            </dependency>
            <dependency>
                <groupId>org.apache.jmeter</groupId>
                <artifactId>ApacheJMeter_functions</artifactId>
                <version>${jmeter.version}</version>
            </dependency>
            <dependency>
                <groupId>org.apache.jmeter</groupId>
                <artifactId>ApacheJMeter_jdbc</artifactId>
                <version>${jmeter.version}</version>
            </dependency>
            <dependency>
                <groupId>org.apache.jmeter</groupId>
                <artifactId>ApacheJMeter_tcp</artifactId>
                <version>${jmeter.version}</version>
            </dependency>
            <dependency>
                <groupId>org.apache.jmeter</groupId>
                <artifactId>ApacheJMeter_java</artifactId>
                <version>${jmeter.version}</version>
                <exclusions>
                    <exclusion>
                        <groupId>org.apache.logging.log4j</groupId>
                        <artifactId>log4j-slf4j-impl</artifactId>
                    </exclusion>
                </exclusions>
            </dependency>

            <!-- Selenium -->
            <dependency>
                <groupId>org.seleniumhq.selenium</groupId>
                <artifactId>selenium-java</artifactId>
                <version>${selenium.version}</version>
            </dependency>
            <dependency>
                <groupId>com.google.guava</groupId>
                <artifactId>guava</artifactId>
                <version>${guava.version}</version>
            </dependency>

            <!-- Sa-token -->
            <dependency>
                <groupId>cn.dev33</groupId>
                <artifactId>sa-token-spring-boot3-starter</artifactId>
                <version>${satoken.version}</version>
            </dependency>
            <dependency>
                <groupId>cn.dev33</groupId>
                <artifactId>sa-token-reactor-spring-boot3-starter</artifactId>
                <version>${satoken.version}</version>
            </dependency>
            <dependency>
                <groupId>cn.dev33</groupId>
                <artifactId>sa-token-redis-jackson</artifactId>
                <version>${satoken.version}</version>
            </dependency>

            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-pool2</artifactId>
                <version>${common-pool.version}</version>
            </dependency>


            <!--RestAssured 接口请求 -->

            <dependency>
                <groupId>io.rest-assured</groupId>
                <artifactId>rest-assured</artifactId>
                <exclusions>
                    <exclusion>
                        <groupId>org.apache.groovy</groupId>
                        <artifactId>groovy</artifactId>
                    </exclusion>
                    <exclusion>
                        <groupId>org.apache.groovy</groupId>
                        <artifactId>groovy-xml</artifactId>
                    </exclusion>
                </exclusions>
                <version>${rest-assured.version}</version>
            </dependency>
            <dependency>
                <groupId>io.rest-assured</groupId>
                <artifactId>rest-assured-all</artifactId>
                <exclusions>
                    <exclusion>
                        <groupId>org.apache.groovy</groupId>
                        <artifactId>groovy</artifactId>
                    </exclusion>
                    <exclusion>
                        <groupId>org.apache.groovy</groupId>
                        <artifactId>groovy-xml</artifactId>
                    </exclusion>
                </exclusions>
                <version>${rest-assured.version}</version>
            </dependency>

            <dependency>
                <groupId>io.rest-assured</groupId>
                <artifactId>spring-web-test-client</artifactId>
                <version>${rest-assured.version}</version>
            </dependency>


            <!-- swagger -->
            <dependency>
                <groupId>org.springdoc</groupId>
                <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
                <version>${springdoc.version}</version>
            </dependency>

            <!-- minio -->
            <dependency>
                <groupId>io.minio</groupId>
                <artifactId>minio</artifactId>
                <version>${minio.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>
```

* dcloud-common项目增加依赖

```
 <dependencies>
        <!-- 代码自动生成依赖 begin -->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-generator</artifactId>
            <version>3.5.3.1</version>
        </dependency>
        <!-- velocity -->
        <dependency>
            <groupId>org.apache.velocity</groupId>
            <artifactId>velocity-engine-core</artifactId>
            <version>2.0</version>
        </dependency>
        <!-- 代码自动生成依赖 end-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-loadbalancer</artifactId>
        </dependency>

        <!--mybatis plus-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.cloud</groupId>
                    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <!--Feign远程调用-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!--数据库连接-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>

        <!--引入Redis-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>


        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
        </dependency>


        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
        </dependency>

        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
        </dependency>

        <dependency>
            <groupId>cn.hutool</groupId>
            <artifactId>hutool-all</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
        </dependency>


        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>


    </dependencies>

```

* 配置Spring Boot的父项目依赖

```
 <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.0.2</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
```

* dcloud-engine项目增加配置文件application.properties

```
server.port=8082
spring.application.name=engine-service
spring.cloud.nacos.discovery.server-addr=120.79.56.211:8848

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.username=root
spring.datasource.password=xdclass.net168
spring.datasource.url=jdbc:mysql://120.79.56.211:3306/test_engine?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai

mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

spring.data.redis.host=120.79.56.211
spring.data.redis.password=123456
spring.data.redis.port=6379
```

* **最佳建议：把这章这集的代码导入到你们IDEA里面，进行构建**

















#### 第4集 微服务项目开发规范说明和工具类封装

**简介：微服务项目开发规范说明和工具类封装**

* 统一返回工具类封装

```
@Data
@AllArgsConstructor
@NoArgsConstructor
public class JsonData {

    /**
     * 状态码 0 表示成功
     */

    private Integer code;
    /**
     * 数据
     */
    private Object data;
    /**
     * 描述
     */
    private String msg;

    /**
     *  获取远程调用数据
     *
     * @param typeReference
     * @param <T>
     * @return
     */
    public <T> T getData(Class<T> typeReference){
        return JSON.parseObject(JSON.toJSONString(data),typeReference);
    }

    /**
     * 成功，不传入数据
     * @return
     */
    public static JsonData buildSuccess() {
        return new JsonData(0, null, null);
    }

    /**
     *  成功，传入数据
     * @param data
     * @return
     */
    public static JsonData buildSuccess(Object data) {
        return new JsonData(0, data, null);
    }

    /**
     * 失败，传入描述信息
     * @param msg
     * @return
     */
    public static JsonData buildError(String msg) {
        return new JsonData(-1, null, msg);
    }

    /**
     * 自定义状态码和错误信息
     * @param code
     * @param msg
     * @return
     */
    public static JsonData buildCodeAndMsg(int code, String msg) {
        return new JsonData(code, null, msg);
    }

    /**
     * 自定义状态码和错误信息
     * @param codeEnum
     * @return
     */
    public static JsonData buildResult(BizCodeEnum codeEnum){
        return JsonData.buildCodeAndMsg(codeEnum.getCode(),codeEnum.getMessage());
    }

    public  boolean isSuccess(){
        return code == 0;
    }
}

```

* 业务状态码枚举类

```
public enum BizCodeEnum {

    /**
     * 文件操作相关
     */
    FILE_REMOTE_DOWNLOAD_FAILED(220404,"远程文件下载失败"),
    FILE_REMOTE_READ_FAILED(220403,"远程文件读取失败"),
    FILE_REMOTE_UPLOAD_FAILED(220407,"文件上传失败"),
    FILE_REMOTE_UPLOAD_IS_EMPTY(220408,"上传文件为空"),
    FILE_PRE_SIGNED_FAILED(220409,"临时url生成失败"),
    FILE_CREATE_TEMP_FAILED(220411,"生成临时文件失败"),

    /**
     * 压测相关
     */
    STRESS_MODULE_ID_NOT_EXIST(260001,"模块id不存在"),
    STRESS_CASE_ID_NOT_EXIST(260002,"压测用例id不存在"),
    STRESS_UNSUPPORTED(260005,"不支持的压测类型"),
    STRESS_ASSERTION_UNSUPPORTED_ACTION(260007, "不支持的断言动作"),
    STRESS_ASSERTION_UNSUPPORTED_FROM(260008, "不支持的断言来源");
    
    @Getter
    private String message;

    @Getter
    private int code;

    private BizCodeEnum(int code, String message){
        this.code = code;
        this.message = message;
    }
}
```

* 全局异常处理

```

@Data
public class BizException extends RuntimeException {

    private int code;
    private String msg;
    private String detail;
    public BizException(Integer code, String message) {
        super(message);
        this.code = code;
        this.msg = message;
    }

    public BizException(BizCodeEnum bizCodeEnum){
        super(bizCodeEnum.getMessage());
        this.code = bizCodeEnum.getCode();
        this.msg = bizCodeEnum.getMessage();
    }

    public BizException(BizCodeEnum bizCodeEnum,Exception e){
        super(bizCodeEnum.getMessage());
        this.code = bizCodeEnum.getCode();
        this.msg = bizCodeEnum.getMessage();
        this.detail = e.toString();
    }
}

@ControllerAdvice
//@RestControllerAdvice
@Slf4j
public class CustomExceptionHandler {

    @ExceptionHandler(value = Exception.class)
    @ResponseBody
    public JsonData handler(Exception e){

        if(e instanceof BizException bizException){
            log.error("[业务异常]{}",e);
            return JsonData.buildCodeAndMsg(bizException.getCode(),bizException.getMsg());
        }else {
            log.error("[系统异常]{}",e);
            return JsonData.buildError("系统异常");
        }

    }

}
```







#### 第5集 滴云自动化测试平台纳入阿里云Git版本控制

**简介：滴云自动化测试平台纳入阿里云Git版本控制**

* Git介绍
  - 是一个版本管理工具, 其作用就是可以让你更好的管理你的程序
  - 比如你原来提交过的内容，以后虽然修改了，但是通过git这个工具，可以把你原来提交的内容重现出来
  - 这样对于你后来才意识到的一些错误的更改，可以进行还原
* 基于git协议的代码仓库
  - github 全球最大同性交友社区
  - gitee 开源中国
  - gitlab 开源的git仓库平台，阿里等大厂就是基于这个搭建
  - codeup 阿里云上的免费git仓库 
    * 地址：https://codeup.aliyun.com/
* 大课项目必须用git吗？
  - 如果是因为不会git，而不用则不行，因为这个是互联网公司必备的
  - 可以看联系客服看小滴课堂 git专题视频
* 配置滴云自动化测试平台纳入Git管理
  * 配置ssh
  * 纳入管理

![image-20231219191257203](img/image-20231219191257203.png)

* 配置忽略文件 .gitignore

```
# Compiled class file
*.class

# Log file
*.log

# BlueJ files
*.ctxt

# Mobile Tools for Java (J2ME)
.mtj.tmp/

*/target/*

.idea

*.DS_Store

*.iml

# Package Files #
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar

# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
hs_err_pid*
```

















![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第四章 互联网公司高并发业务的压测痛点



#### 第1集 测试引擎微服务和模拟接口开发实战

**简介：测试引擎微服务和模拟接口开发实战**

* 需求
  * 测试引擎项目开发-开发压测模块
  * 理清常规Jmeter压测工具使用流程
  * 开发模拟接口用于测试压测相关内容
    * get提交
    * post提交
      * json格式
      * 表单格式
    * 需要上述模拟接口需要支持参数化和随机响应延迟

* 启动类开发

  ```
  @SpringBootApplication
  public class EngineApplication {
      public static void main(String[] args) {
          SpringApplication.run(EngineApplication.class, args);
      }
  }
  ```

* 接口开发

  ```
  @Controller
  public class TestController {
  
      /**
       * form表单提交，不能json
       * @param mail
       * @param pwd
       * @return
       */
      @RequestMapping("/api/v1/test/login_form")
      @ResponseBody
      public JsonData login(String mail, String pwd){
  
          if(mail.startsWith("a")){
              return JsonData.buildError("账号错误");
          }
          return JsonData.buildSuccess("mail="+mail+",pwd="+pwd);
      }
  
  
  
  
      /**
       * json提交
       * @param mail
       * @param pwd
       * @return
       */
      @PostMapping("/api/v1/test/pay_json")
      @ResponseBody
      public JsonData pay(@RequestBody Map<String,String> map) {
  
          String id = map.get("id");
          String amount = map.get("amount");
          return JsonData.buildSuccess("id="+id+",amount="+amount);
      }
  
  
      /**
       * json提交, 加上随机睡眠时间
       * @param mail
       * @param pwd
       * @return
       */
      @PostMapping("/api/v1/test/pay_json_sleep")
      @ResponseBody
      public JsonData paySleep(@RequestBody Map<String,String> map) {
  
          try {
              int value = RandomUtil.randomInt(1000);
              TimeUnit.MICROSECONDS.sleep(value);
              String id = map.get("id");
              String amount = map.get("amount");
              return JsonData.buildSuccess("id="+id+",amount="+amount+",sleep="+value);
          } catch (InterruptedException e) {
              throw new RuntimeException(e);
          }
  
      }
  
  
      /**
       * get方式提交
       * @param id
       * @return
       */
      @GetMapping("/api/v1/test/query")
      @ResponseBody
      public JsonData queryDetail(Long id){
          return JsonData.buildSuccess("id="+id);
      }
  
  
      /**
       * get方式，随机睡眠时间
       * @param id
       * @return
       */
      @GetMapping("/api/v1/test/query_sleep")
      @ResponseBody
      public JsonData querySleep(Long id){
          try {
              int value = RandomUtil.randomInt(1000);
              TimeUnit.MICROSECONDS.sleep(value);
              return JsonData.buildSuccess("id="+id+",sleep="+value);
          } catch (InterruptedException e) {
              throw new RuntimeException(e);
          }
  
      }
  
      /**
       * get方式，id取模3是0后则http状态码500
       * @param id
       * @return
       */
      @GetMapping("/api/v1/test/query_error_code")
      @ResponseBody
      public JsonData queryError(Long id,  HttpServletResponse response){
  
          if(id % 3 == 0){
              response.setStatus(500);
          }
          return JsonData.buildSuccess("id="+id);
      }
  }
  ```

  













####  第2集 性能测试工具Jmeter核心知识快速回顾

**简介 性能测试工具Jmeter核心知识快速回顾**

- 什么是Jmeter

  - 是 apache 公司基于 java 开发的一款开源性能测试工具
  - 地址： https://jmeter.apache.org
  - 特点
    - 开源免费功能强大，在互联网公司普遍使用
    - 压测不同的协议和应用
      - Web - HTTP, HTTPS (Java, NodeJS, PHP, ASP.NET, …)
      - FTP、Database via JDBC
      - Mail - SMTP(S), POP3(S) and IMAP(S)
  - 使用场景及优点
    - 支持功能测试、单机和分布式压力测试
    - 纯java开发、上手容易，高性能
    - 提供测试数据分析、各种报表数据图形展示
    - 缺点：不支持html、js渲染操作，不能做UI功能测试

- 文档地址：http://jmeter.apache.org/usermanual/get-started.html

- 运行环境：需要安装JDK8 以上

- Jmeter目录

  ```
  bin:核心可执行文件，包含配置
          jmeter.bat: windows启动文件(window系统一定要配置显示文件拓展名)
          jmeter: mac或者linux启动文件
          jmeter-server：mac或者Liunx分布式压测使用的启动文件
          jmeter-server.bat：window分布式压测使用的启动文件
          jmeter.properties: 核心配置文件   
  
  extras：插件拓展的包
  
  lib:核心的依赖包
  ```

- 配置文件修改

  - bin目录 -> jmeter.properties

    - 语言问题

    ```
    默认 #language=en
    改为 language=zh_CN
    ```

    - 响应乱码问题解决

    ```
    # sampleresult.default.encoding=ISO-8859-1的注释去掉，
    
    改成：sampleresult.default.encoding=UTF-8
    ```

- 注意

  - JMeter 不是浏览器，它在协议级别工作

  - 对于 Web 服务和远程服务而言，JMeter 看起来像一个浏览器

  - JMeter 并不执行浏览器支持的所有操作，不像浏览器那样呈现 HTML 页面，不执行 HTML 页面中的 JS

     

















#### 第3集 Jmeter5.X核心功能组件+线程组和Sampler

**简介：Jmeter5.X基础功能组件+线程组和Sampler**

- 什么是线程组
  - 就是一组线程，并发执行，每个线程可以认为是一个请求

* 添加->threads->线程组（控制总体并发）

  * 线程数
    * 虚拟用户数。一个虚拟用户占用一个进程或线程
  * 准备时长（Ramp-Up Period(in seconds)）：
    * 全部线程启动的时长，比如100个线程，20秒，则表示20秒内 100个线程都要启动完成，每秒启动5个线程
  * 循环次数：
    * 每个线程发送的次数，假如值为5，100个线程，则会发送500次请求，可以勾选永远循环
  * 线程组里面的调度器

  ![image-20220921000902805](img/image-20220921000902805-2995119.png)

* 线程组->添加-> Sampler(采样器) -> Http （一个线程组下面可以增加几个Sampler）
  * 名称：采样器名称
  * 注释：对这个采样器的描述
  * web服务器
    * 默认协议是http
    * 默认端口是80
    * 服务器名称或IP ，请求的目标服务器名称或IP地址
    * 路径：服务器URL

* 查看测试结果
  * 线程组->添加->监听器->察看结果树
  * 线程组->添加->监听器->聚合报告
  * 位置
    * 放在http采集器级别，获取兄弟节点数据
    * 放在http采样器下面，获取当前http采样器数据
* 存储
  - 保存jmx性能测试脚本
  - 打开已有jmx性能测试脚本













#### 第4集 Jmeter5.X压测多类型接口测试计划实战

**简介：Jmeter5.X压测多类型接口测试计划实战**

* 本地压测，接口测试计划录入（每个接口单独一个JMX文件）
  * get方式
  * post方式
    * 表单提交
    * json提交

* 初步压测查看数据

<img src="img/image-20231219222144669-2995706.png" alt="image-20231219222144669" style="zoom:50%;" />



















#### 第5集 互联网公司高并发业务的Jmeter压测流程痛点

**简介：互联网公司高并发业务的Jmeter压测流程痛点**

* 互联网公司常规项目部署环境

![image-20231219215738131](img/image-20231219215738131.png)

* 本地Jmeter测试
  * 图形化压测，直接GUI界面压测

* Linux服务器压测

  * 命令行压测，服务器需要安装JDK环境和JMeter安装包

  * 上传JMX压测脚本，如果有参数化文件还需要修改JMX脚本

  * 执行压测（进到Jmeter目录，测试报告目录需要先创建好）

    ```
    jmeter -n -t /usr/local/software/linux_load_test.jmx -l /usr/local/software/temp/jtl/result.jtl -e -o /usr/local/software/temp/result
    ```

    - -n 非gui方式运行jmeter
    - -t ：jmx 脚本路径
    - -l ：result.jtl 运行结果保存路径，注意：.jtl 文件名不能重复，文件夹需要存在
    - -e ：在脚本运行结束后生成 HTML 报告
    - -o ：用于存放 HTML 报告的目录，文件夹需要存在

    - 下载测试报告

* 最多的问题（项目工期紧张情况，如何高效完成压测）
  * 压测小项目几个接口容易，但是几十个上百个接口，不同环境下你如何提高速度。。。。
  * 测试报告查看对比麻烦，假如老王认真的对接口做了性能优化，又要进行压测一遍，且在不同环境

<img src="img/image-20231219222221932.png" alt="image-20231219222221932" style="zoom:50%;" />

















#### 第6集 滴云自动化测试平台-SaaS化压测引擎初体验

**简介：滴云自动化测试平台-SaaS化压测引擎初体验**

* 什么是SaaS化产品
  * 即软件即服务（Software as a Service），是一种基于云计算的软件交付模式。
  * 软件通过互联网提供给用户，用户无需在本地安装和维护软件，通过浏览器直接访问使用
  * 用户无需购买昂贵的软件许可证或硬件设备，**只需根据实际使用情况付费，降低了起步成本和运营成本**
  * 国内互联网行业的SaaS产品有很多
    * 飞书
      * 字节跳动推出的企业通讯工具，也是一种SaaS平台。
      * 为企业提供了多种功能，包括即时通讯、会议管理、文件共享等，能够极大地提升企业内部的沟通和协作效率。
    * 阿里云
      * 阿里云的SAAS平台为企业提供了丰富的云计算服务，包括计算、存储、数据库、人工智能等。
    * 用友网络
      * 提供企业财务、供应链、人力资源等全方位的SaaS解决方案。
    * 微盟集团
      * 面向电商和零售企业，提供微信小程序、公众号运营、客户关系管理等SaaS服务。
    * 有赞
      * 主要为电商企业提供SaaS服务，包括店铺管理、营销推广、数据分析等功能。

* **SaaS化产品-滴云自动化测试平台压测初体验**
  
  * **测试用例录入**
    
    * **在线自定义创建**
    
    ![image-20231221190406699](img/image-20231221190406699.png)
    
    * **本地JMX脚本上传**
    
    ![image-20231221190344241](img/image-20231221190344241.png)
  * **一键开启压测+查看测试报告**
  
  ![image-20231221190439494](img/image-20231221190439494.png)

![image-20231219223727351](img/image-20231219223727351.png)











![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第五章 AI大模型下的技术工程师的开发神器



#### 第1集 新一代AI技术变革下-如何认清方向

**简介：新一代AI技术变革下-如何认清方向**

* 国外的AI平台

  * ChatGPT,地址 https://platform.openai.com/playground

  ![image-20231220182550889](img/image-20231220182550889.png)

* 国内AI平台

  * 百度

    * 文心一言，地址 https://yiyan.baidu.com/ 

  * 讯飞

    * 星火大模型，地址 https://xinghuo.xfyun.cn/

  * 阿里云

    * 通义，地址  https://tongyi.aliyun.com/

    ![image-20231220182257968](img/image-20231220182257968.png)

* ChatGPT、AIGC对我们IT行业的影响有多大？包括但不限于以下几种：
  * **对话系统**：
    * ChatGPT模型可以用于构建对话系统，实现自然语言问答、客服机器人等功能。
    * 例如智能音箱中的语音助手、在线聊天服务中的客服机器人等。
  * **文本生成**
    * ChatGPT模型可以用于生成各种类型的文本，如新闻报道、小说、诗歌等，
    * 例如自动化写作软件、创意内容生成工具等。
  * **语音转写**：
    * ChatGPT模型可以用于将语音转成文本，实现语音识别功能
    * 例如语音助手、语音翻译软件等。
  * **情感分析**：
    * ChatGPT模型可以用于分析和识别文本中所包含的情感色彩，如正面情感、负面情感等。
    * 例如社交媒体中的舆情分析、市场调查等。
* **个人感觉：行业AI真正的从人工智障转为人工智能**

- **IT技术行业会如何变化**
  - 传统的重复性工作可以被自动化和智能化
    - 例如自动编写基础代码、自动化测试、自动化发布、自动化部署等
    - 这使得技术人员能够更加专注于高价值和创新性的工作，提高工作效率和质量
  - 降低技术门槛
    - 随着 ChatGPT 和 AIGC 等技术的普及，关注点逐渐从技术底层转移到应用场景
    - 越来越多的人可以利用这些技术来解决问题，而不必具备特定的编程语言或统计学知识
  - 数据处理
    - 提供了更多的数据处理手段，例如自然语言处理、图像处理、数据挖掘等
    - 技术人员可以通过技术更好地处理和分析业务数据，发现数据背后的有用信息，提高决策的准确性和效率

- 其他行业：设计、金融、客服 会怎样变革 ?



















#### 第2集 AI大模型下技术工程师的开发神器实战

**简介：AI大模型下技术工程师的开发神器**

* AI大模型下，技术工程师如何提高效率，利用AI开发代码提高效率
  * **工具核心：让开发人员提供的示例或自然语言的描述，能够从大量数据中学习并生成相关的、准确的代码**
  * **常见工具：Copilot 、AlphaCode、通义灵码**

* 通义灵码

  * 地址：https://tongyi.aliyun.com/lingma

  ![image-20231220184341958](img/image-20231220184341958.png)

  * 介绍
    * 是阿里云出品的一款基于通义大模型的智能编码辅助工具，提供行级/函数级实时续写、自然语言生成代码、单元测试生成
    * 代码注释生成、代码解释、研发智能问答、异常报错排查等能力，对阿里云 SDK/OpenAPI 的使用场景调优
    * 助力开发者高效、流畅的编码。
  * 支持编程语言 
    * 支持 Java、Python、Go、C#、C/C++、JavaScript、TypeScript、PHP、Ruby、Rust、Scala、Kotlin 等主流编程语言。
  * 支持 IDE 及操作系统 
    * JetBrains IDEs
      * IDE 版本：IntelliJ IDEA、PyCharm、GoLand、WebStorm 等 2020.3 及以上
      * 操作系统：Windows 7 及以上、macOS、Linux
    * Visual Studio Code
      - IDE 版本：1.75.1 及以上
      - 操作系统：Windows 8.1 及以上、macOS、Linux
  * 安装步骤

  ![image-20231220184515223](img/image-20231220184515223.png)

















#### 第3集 技术难点思考SpringBoot如何集成Jmeter开发

**简介：技术难点思考SpringBoot如何集成Jmeter开发**

* 需求

  * 开发压测平台，Spring Boot需要调用Jmeter进行压测，如何完成？

* 解决方案一：使用Runtime类调用外部进程

  * `Runtime`类是Java中的一个核心类，提供了与Java运行时环境交互的方法

  * 它提供了与操作系统交互的接口，使Java应用程序能够执行系统命令、访问系统资源并执行特定操作。

  * 主要用途包括以下几个方面：

    * 启动和管理进程
      * `Runtime`类提供了一些方法，如`exec()`，用于启动和管理外部进程。
      * 这使得Java应用程序能够执行系统命令、启动其他应用程序或脚本，以及与外部进程进行交互。
    * 访问系统资源
      * `Runtime`类提供了一些方法，如`totalMemory()`和`freeMemory()`，用于获取Java虚拟机的内存信息。
      * 还可以使用`getSystemResource()`方法获取系统资源路径，如类路径、库路径等。
    * 执行特定操作
      * `Runtime`类还提供了一些方法，如`exit()`，用于终止Java应用程序。
      * 还可以使用`nanoTime()`方法获取当前纳秒时间，以及使用`currentTimeMillis()`方法获取当前毫秒时间。

  * Jmeter命令行压测讲解

    * 进到jmeter的bin目录下

    ```
    ./jmeter -n -t /Users/xdclass/Desktop/report.jmx -l /Users/xdclass/Desktop/temp/jtl/result.jtl -e -o /Users/xdclass/Desktop/temp/result
    ```

    - 参数说明
      - -n 非gui方式运行jmeter
      - -t ：jmx 脚本路径
      - -l ：results.log 运行结果保存路径，**注意：文件名不能重复，文件夹需要存在**
      - -e ：在脚本运行结束后生成 HTML 报告
      - -o ：用于存放 HTML 报告的目录，**文件夹需要存在**

* 编码实战（大家可以先看，然后不实操，**如果实操记得注意Window的文件路径**）

  ```
  public class TestRuntime {
  
      public static void main(String[] args) {
          try {
              // 调用Jmeter执行脚本
              Process process = Runtime.getRuntime().exec("/Users/xdclass/Desktop/coding/apache-jmeter-5.5/bin/jmeter -n -t /Users/xdclass/Desktop/test.jmx -l results.log -e -o /Users/xdclass/Desktop/result");
  
              // 读取Jmeter的输出
              BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
              String line;
              while ((line = reader.readLine()) != null) {
                  System.out.println(line);
              }
  
              // 等待Jmeter进程结束
              int exitCode = process.waitFor();
              System.out.println("Jmeter exit code: " + exitCode);
          } catch (IOException | InterruptedException e) {
              e.printStackTrace();
          }
      }
  }
  ```

* **问题点：**

  * **可读性和维护拓展性差，难以平台化，停留现有认知**

* 需要技术组长解决的问题：

  * 梳理下合理的压测流程，怎么配置压测参数、开启压测、查看测试报告更方便



















![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第六章 滴云自动化测试平台-压测引擎数据库设计



#### 第1集 滴云自动化测试平台-压测引擎数据库设计《上》

**简介：滴云自动化测试平台-压测引擎数据库设计**

* 数据库设计思路
  * 技术负责人基于产品需求文档，日常压测流程的痛点进行整理需求
  * 梳理下合理的压测流程，怎么配置压测参数、开启压测、查看测试报告更方便
  
* 数据库模型设计（分步设计-先设计压测相关模块；**数据库约束和索引优化后续做**）

  * 宏观上的ER图关系

  ![image-20231222113509169](img/image-20231222113509169.png)

  * 每个表模型字段明细

  ```
  CREATE TABLE `project` (
    `id` bigint unsigned NOT NULL AUTO_INCREMENT,
    `project_admin` bigint unsigned DEFAULT NULL COMMENT '项目管理员ID',
    `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '项目名称',
    `description` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '描述',
    `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (`id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
  
  
  CREATE TABLE `environment` (
    `id` bigint unsigned NOT NULL AUTO_INCREMENT,
    `project_id` bigint unsigned NOT NULL COMMENT '所属项目ID',
    `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '环境名称',
    `protocol` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '协议',
    `domain` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '环境域名',
    `port` int unsigned NOT NULL COMMENT '端口',
    `description` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '描述',
    `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (`id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
  
  
  CREATE TABLE `stress_case_module` (
    `id` bigint unsigned NOT NULL AUTO_INCREMENT,
    `project_id` bigint unsigned DEFAULT NULL COMMENT '所属项目ID',
    `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '接口模块名称',
    `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (`id`),
    UNIQUE KEY `name` (`name`)
  ) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
  
  ```

















#### 第2集 滴云自动化测试平台-压测引擎数据库设计《下》

**简介：滴云自动化测试平台-压测引擎数据库设计**

* 下载资料 ，使用**【wget】或者【浏览器】远程下载相关依赖包（需要替换群里最新的）**

  ```
  原生资料下载方式(账号 - 密码 - ip地址 - 端口 需要替换群里最新的，其他路径不变)
  wget --http-user=用户名 --http-password=密码 http://ip:端口/dcloud_test/dcloud_stress_sql.zip
  
  
  #比如 命令行下
  wget --http-user=admin --http-password=xdclass.net888 http://47.115.31.28:9088/dcloud_test/dcloud_stress_sql.zip
  
  # 比如 浏览器直接访问
  http://47.115.31.28:9088/dcloud_test/dcloud_stress_sql.zip
  ```

* 压测用例表介绍

```
特殊字段存储介绍assertion
[{"name":"测试断言","action":"CONTAIN","from":"RESPONSE_DATA","value":"0"}]

特殊字段存储介绍relation
[{"sourceType":"csv","delimiter":",","ignoreFirstLine":false,"recycle":true,"variableNames":"id,title","remoteFilePath":"http://120.24.7.58:9000/bucket/test.csv","name":"CSV商品数据集合"}]

特殊字段存储介绍thread_group_config
{"threadGroupName":"测试","numThreads":"20","rampUp":"2","loopCount":"10","schedulerEnabled":false,"duration":0,"delay":0}
```

* 测试报告概述表

* 压力测试报告明细表

























#### 第3集 新版SpringBoot3.X+MybatisPlus逆向工程实战

**简介：新版SpringBoot3.X+MybatisPlus逆向工程实战**

* 新版MybatisPlus逆向工程配置

  ```
  
  public class MyBatisPlusGenerator {
  
      public static void main(String[] args) {
  
          String userName = "root";
          String password = "xdclass.net168";
          String serverInfo = "120.79.56.211:3306";
          String targetModuleNamePath = "/dcloud-engine";
          String dbName = "test_engine";
          String[] tables = {
                  "project", "environment",
                  "stress_case_module", "stress_case"
          };
  
          // 数据源配置
          FastAutoGenerator.create("jdbc:mysql://"+serverInfo+"/"+dbName+"?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&tinyInt1isBit=true", userName, password)
                  .globalConfig(builder -> {
                      builder.author("小滴课堂-二当家小D,")        // 设置作者
                              .commentDate("yyyy-MM-dd")
                              .enableSpringdoc()
                              .disableOpenDir() //禁止打开输出目录
                              .dateType(DateType.ONLY_DATE)   //定义生成的实体类中日期类型 DateType.ONLY_DATE 默认值: DateType.TIME_PACK
                              .outputDir(System.getProperty("user.dir") + targetModuleNamePath + "/src/main/java"); // 指定输出目录
                  })
                  .dataSourceConfig(builder -> {//Mysql下tinyint字段转换
                      builder.typeConvertHandler((globalConfig, typeRegistry, metaInfo) -> {
                          if (JdbcType.TINYINT == metaInfo.getJdbcType()) {
                              return DbColumnType.BOOLEAN;
                          }
                          return typeRegistry.getColumnType(metaInfo);
                      });
                  })
                  .templateConfig(builder -> {
                      //设置不生成controller和service
                      builder.disable(TemplateType.CONTROLLER,TemplateType.SERVICE,TemplateType.SERVICE_IMPL);
                  })
                  .packageConfig(builder -> {
                      builder.parent("com.glen.autotest") // 父包模块名
                              .entity("model")      //Entity 包名 默认值:entity
                              .mapper("mapper")     //Mapper 包名 默认值:mapper
                              .pathInfo(Collections.singletonMap(OutputFile.xml, System.getProperty("user.dir") + targetModuleNamePath + "/src/main/resources/mapper")); // 设置mapperXml生成路,默认存放在mapper的xml下
                  })
  
                  .strategyConfig(builder -> {
                      builder.addInclude(tables) // 设置需要生成的表名 可变参数
                              .entityBuilder()// Entity策略配置
                              .enableFileOverride() // 开启生成Entity层文件覆盖
                              .idType(IdType.ASSIGN_ID)//主键策略  雪花算法自动生成的id
                              .enableLombok() //开启lombok
                              .logicDeleteColumnName("deleted")// 说明逻辑删除是哪个字段
                              .enableTableFieldAnnotation()// 属性加上注解说明
                              .formatFileName("%sDO")
  
                              .controllerBuilder()// Controller策略配置
                              .enableFileOverride() // 开启生成Controller层文件覆盖
  
                              .serviceBuilder()// Service策略配置
                              .enableFileOverride() // 开启生成Service层文件覆盖
                              .superServiceClass("")
                              .superServiceImplClass("")
                              .formatServiceFileName("%sService")
                              .formatServiceImplFileName("%sServiceImpl")
  
                              .mapperBuilder()// Mapper策略配置
                              .enableFileOverride() // 开启生成Mapper层文件覆盖
                              .formatMapperFileName("%sMapper")
                              .superClass(BaseMapper.class)
                              .enableBaseResultMap()
                              .enableBaseColumnList()
  
                              .formatXmlFileName("%sMapper");
                  })
                  .execute();
  
      }
  
  
  }
  ```

  

  

  

  











#### 第4集 对象转换传输规范SpringBeanUtil工具类封装

**简介：对象转换传输规范SpringBeanUtil工具类封装**

* N方库说明

```
一方库: 本工程内部子项目模块依赖的库(jar 包)。
二方库: 公司内部发布到中央仓库，可供公司内部其它应用依赖的库(jar包)。
三方库: 公司之外的开源库(jar 包)。
```

- POJO实体类

```
POJO(Plain Ordinary Java Object): 在手册中，POJO 专指只有 setter / getter / toString的简单类，包括DO/DTO/BO/VO等, 禁止命名成xxxPOJO
```

* 领域模型命名规约
  * 数据对象:xxxDO，xxx即为数据表名
  * 一般数据传输对象:xxxDTO，xxx为业务领域相关的名称，返回前端结果或者RPC调用统一DTO
  * 接收前端json对象请求的命名为 XXXReq

* 对象转换拷贝工具类封装

```
public class SpringBeanUtil {
    public static <T> T copyProperties(Object source, Class<T> target) {
        try {
            T t = target.getConstructor().newInstance();
            BeanUtils.copyProperties(source, t);
            return t;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static <T> List<T> copyProperties(List<?> sourceList, Class<T> target) {
        ArrayList<T> targetList = new ArrayList<>();
        sourceList.forEach(item -> targetList.add(copyProperties(item, target)));
        return targetList;
    }
}
```











#### 第5集 滴云自动化测试平台-项目管理开发实战

**简介：滴云自动化测试平台-项目管理开发实战**

* 项目管理基础模块开发

```
@RequestMapping("/api/v1/project")
public class ProjectController {
    @Resource
    private ProjectService projectService;


    @GetMapping("/list")
    public JsonData list() {
        return JsonData.buildSuccess(projectService.list());
    }


    @PostMapping("/save")
    public JsonData save(@RequestBody ProjectSaveReq projectSaveReq) {
        return JsonData.buildSuccess(projectService.save(projectSaveReq));
    }


    @PostMapping("/update")
    public JsonData update(@RequestBody @Validated ProjectUpdateReq projectUpdateReq) {
        return JsonData.buildSuccess(projectService.update(projectUpdateReq));
    }


    @PostMapping("/del")
    public JsonData delete(@RequestBody @Validated ProjectDelReq projectDelReq) {
        return JsonData.buildSuccess(projectService.delete(projectDelReq.getProjectId()));
    }
}

```









#### 第6集 滴云自动化测试平台-环境管理开发实战

**简介：滴云自动化测试平台-环境管理开发实战**

* 环境管理基础模块开发

```
@RestController
@RequestMapping("/api/v1/env")
public class EnvironmentController {
    @Resource
    private EnvironmentService environmentService;

    @GetMapping("/list")
    public JsonData list(@RequestParam("projectId") long projectId) {
        return JsonData.buildSuccess(environmentService.list(projectId));
    }


    @PostMapping("/save")
    public JsonData save(@RequestBody  EnvironmentSaveReq environmentSaveReq) {
        return JsonData.buildSuccess(environmentService.save(environmentSaveReq));
    }


    @PostMapping("/update")
    public JsonData update(@RequestBody  EnvironmentUpdateReq environmentUpdateReq) {
        return JsonData.buildSuccess(environmentService.update(environmentUpdateReq));
    }


    @PostMapping("/del")
    public JsonData delete(@RequestBody EnvironmentDelReq  req) {
        return JsonData.buildSuccess(environmentService.delete(req.getProjectId(),req.getId()));
    }
}
```





















![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第七章 压测引擎架构链路分析和JMX开发初体验



#### 第1集 Jmeter压测引擎之JMX脚本组成结构分析

**简介： Jmeter压测引擎之JMX脚本组成结构分析**

* 压测引擎支持两种测试计划录入
  * 本地上传JMX
  * 在线创建测试计划

* Jmeter压测最终都是执行jmx脚本，主要由以下部分组成：
  * **Test Plan**: 这是测试脚本的主节点，所有的其他节点都应作为其子节点。
  * **Thread Groups**: 线程组定义了并发用户和他们的活动。每个线程组代表一组虚拟用户，他们并发执行预定的操作。
  * **Samplers**: Sampler是执行特定请求的节点，例如HTTP请求或JDBC请求等。这些请求产生对服务器的实际负载。
  * **Controllers**: 控制器节点决定JMeter如何组织和运行其测试计划中的请求。例如，使用“循环控制器”，在多个迭代中重复请求。
  * **Listeners**: 监听器节点用于收集和显示测试过程中的信息，如样本的结果、响应时间、吞吐量等。
  * **Config Elements**: 配置元素用于设置JMeter中的参数或属性。例设置cookie的HTTP Header Manager或定义用户定义的变量。
  * **Assertions**: 断言用于验证服务器响应是否符合预期。如果响应不符合预期，断言将标记样本为失败。
  * **Pre-Processors, Post-Processors, and Assertions**: 这些节点用于处理服务器响应或在发送请求之前设置请求的某些属性。


* 一个典型的JMX脚本的结构如下

  * 具体内容会根据实际的测试需求有所不同
  * 可以通级别节点添加，也可以子节点添加

  ```xml
  <jmeterTestPlan version="1.2">  
    <hashTree>  
      <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Load Test" enabled="true">  
        ...  
        <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Users" enabled="true">  
          ...  
          <SamplerController guiclass="HashTreeControllerGui" testclass="SamplerController" testname="Samplers" enabled="true">  
            ...  
            <HashTree>  
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="GET request to example.com" enabled="true">  
                ...  
              </HTTPSamplerProxy>  
              ...  
            </HashTree>  
          </SamplerController>  
          ...  
        </ThreadGroup>  
        ...  
      </TestPlan>  
    </hashTree>  
  </jmeterTestPlan>
  ```

* XML脚本里面组件的共同点

  ![image-20231225153337416](img/image-20231225153337416.png)

















#### 第2集 Jmeter5.X二次开发标准解决方案实战《上》

**简介： Jmeter5.X二次开发标准解决方案实战**

* **架构师核心技能：进入新的业务领域，如何发现靠谱的技术解决方案？**
  * 方案一：官方文档和源码分析
  * 方案二：看竟品、行业厂商提供的服务和文档
  * 方法三：搜索引擎和GitHub社区
  * 方法四：利用AI平台查找
* **小步快跑-快速试错（难点攻克）**
  * Jmeter多个不同使用场景，先跑通流程，然后再抽取封装成平台
  * **云测平台开发，代码里面会有漏洞和设计缺陷，大家要发现出来，并提出解决方案！！！**

<img src="img/image-20231222183322262.png" alt="image-20231222183322262" style="zoom:30%;" />

* java集成Jmeter二次开发方案介绍-jmx脚本执行案例（注意Window和Linux文件夹路径问题）

  ```
     /**
       * 测试JMeter脚本
       * @throws Exception 异常
       */
      @Test
      public void testJmeterScript()throws Exception{
          // JMeter路径
          String jmeterPath = "/Users/xdclass/Desktop/coding/apache-jmeter-5.5";
          // JMeter根目录
          File jmeterHome = new File(jmeterPath);
          // JMX文件路径
          String jmxFilePath = "/Users/xdclass/Desktop/课程资料-jmx集合/query.jmx";
          // JMX文件
          File jmxFile = new File(jmxFilePath);
          // JMeter配置文件路径
          File jmeterProperties = new File(jmeterHome.getPath() + File.separator + "bin" + File.separator + "jmeter.properties");
          // 设置JMeter根目录
          JMeterUtils.setJMeterHome(jmeterHome.getPath());
          // 加载JMeter配置文件
          JMeterUtils.loadJMeterProperties(jmeterProperties.getPath());
  
          // JMeter标准引擎
          StandardJMeterEngine jmeter = new StandardJMeterEngine();
          // 测试计划树
          HashTree testPlanTree = new HashTree();
  
          // 设置文件服务器的基础脚本路径
          FileServer.getFileServer().setBaseForScript(jmxFile);
          // 加载测试计划树 jmx脚本
          testPlanTree = SaveService.loadTree(jmxFile);
  
          // 转换测试计划树
          JMeter.convertSubTree(testPlanTree, false);
  
          // Summariser对象
          Summariser summer = null;
          // Summariser名称
          String summariserName = JMeterUtils.getPropDefault("summariser.name", "summary");
          if (!summariserName.isEmpty()) {
              // 创建Summariser对象
              summer = new Summariser(summariserName);
          }
          // 结果日志文件名
          String logFile = "example.csv";
          // 结果收集器
          ResultCollector logger = new ResultCollector (summer);
          logger.setFilename(logFile);
          // 将结果收集器添加到测试计划树上
          testPlanTree.add(testPlanTree.getArray()[0], logger);
          // 配置JMeter引擎
          jmeter.configure(testPlanTree);
          // 运行JMeter测试
          jmeter.run();
      }
  
  
  ```

















#### 第3集 Jmeter5.X二次开发标准解决方案实战《下》

**简介： Jmeter5.X二次开发标准解决方案实战**

* 运行JMX压测

![image-20231225160100780](img/image-20231225160100780.png)

* 查看测试结果

![image-20231225160012312](img/image-20231225160012312.png)

















#### 第4集 滴云自动化测试平台-压测引擎总体架构设计

**简介： 滴云自动化测试平台-压测引擎总体架构设计**

* 压测引擎平台化思路设计

![image-20231225162832973](img/image-20231225162832973.png)













#### 第5集 压测引擎之测试用例接口开发实战

**简介： 压测引擎之测试用例接口开发实战**

* 测试用例
  * 用例：用户使用的案例简称，比如 用户验证是否可以登录的案例
  * 测试用例：测试项目设计的执行文档

* 压力测试用例接口开发实战

```

    /**
     * 根据id查找
     *
     * @param id
     * @return
     */
    @GetMapping("/find")
    public JsonData getById(@RequestParam("projectId") long projectId,@RequestParam("id") long caseId) {
        return JsonData.buildSuccess(stressCaseService.getById(projectId,caseId));
    }


    /**
     * 根据id删除测试用例
     *
     * @param id
     * @return
     */
    @PostMapping("/del")
    public JsonData delete(@RequestBody StressCaseDelReq delReq) {
        return JsonData.buildSuccess(stressCaseService.remove(delReq.getProjectId(),delReq.getId()));
    }


    /**
     * 保存测试用例
     *
     * @param stressCaseSaveReq
     * @return
     */
    @PostMapping("/save")
    public JsonData save(@RequestBody @Validated StressCaseSaveReq stressCaseSaveReq) {
        return JsonData.buildSuccess(stressCaseService.save(stressCaseSaveReq));
    }


    @PutMapping("/update")
    public JsonData update(@RequestBody @Validated StressCaseUpdateReq stressCaseUpdateReq) {
        return JsonData.buildSuccess(stressCaseService.update(stressCaseUpdateReq));
    }


    /**
     * 执行用例
     *
     * @param id
     * @return
     */
    @GetMapping("/execute")
    public JsonData execute(@RequestParam("projectId")Long projectId,@RequestParam("id") Long caseId) {
        stressCaseService.execute(projectId,caseId);
        return JsonData.buildSuccess();
    }

```

















#### 第6集 压测引擎之用例模块管理接口开发实战

**简介：  压测引擎之用例模块管理接口开发实战**

* 压测用例模块接口开发实战

```
@RestController
@RequestMapping("/api/v1/stress_case_module")
public class StressCaseModuleController {

    @Autowired
    private StressCaseModuleService stressCaseModuleService;

    @GetMapping("/list")
    public JsonData list(@RequestParam("projectId") long projectId){
        return JsonData.buildSuccess(stressCaseModuleService.list(projectId));
    }

    @GetMapping("/find")
    public JsonData getById(@RequestParam("projectId") long projectId,@RequestParam("moduleId") long moduleId){
        return JsonData.buildSuccess(stressCaseModuleService.getById(projectId,moduleId));
    }

    @PostMapping("/save")
    public JsonData save(@RequestBody @Validated StressCaseModuleSaveReq moduleSaveReq){
        return JsonData.buildSuccess(stressCaseModuleService.save(moduleSaveReq));
    }

    @PostMapping("/update")
    public JsonData update(@RequestBody @Validated StressCaseModuleUpdateReq moduleUpdateReq){
        return JsonData.buildSuccess(stressCaseModuleService.update(moduleUpdateReq));
    }

   
    @PostMapping("/del")
    public JsonData delete(@RequestBody StressCaseModuleDelReq delReq){
        return JsonData.buildSuccess(stressCaseModuleService.remove(delReq.getProjectId(),delReq.getId()));
    }
}
```























![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第八章 滴云自动化测试平台-压测引擎开发实战



#### 第1集 云测平台Jmeter二次开发流程拆解和梳理

**简介： 云测平台Jmeter二次开发流程拆解和梳理**

* Jmeter二次开发流程梳理

![image-20231225162901905](img/image-20231225162901905.png)

* 步骤拆分

  * 环境初始化是 主要是设置JMeter的运行环境，包括安装JMeter、设置Java环境等。

    - **安装 JMeter**: 下载 JMeter 安装包并按照官方指南进行安装，即指定SpringBoot程序可以识别JmeterHome路径

  * 脚本加载主要是通过各种方式加载和解析JMeter脚本，通常包括从文件加载和从数据库加载等。

    - **从文件加载**: 使用 `TestPlan` 和 `HashTree` 类来加载脚本文件。

    ```java
    HashTree testPlanTree = SaveService.loadTree(new File("path_to_jmeter_script.jmx"));
    ```

    * **从数据库加载**: 如果脚本存储在数据库中，可以使用 JDBC 连接器来读取并解析脚本。

  * 用例执行是实际运行JMeter测试的部分，通常涉及启动线程组、采样器等。

    - **启动线程组**: 使用 `ThreadGroup` 类来启动线程组
    - **采样器执行**: 采样器是实际发送请求的部分，可以使用 `HTTPSamplerProxy` 等类来创建和执行采样器。
    - **监听器和后处理**: 可以添加监听器来收集测试结果，并在测试结束后进行后处理。

  * 测试结果收集主要是收集测试过程中的数据，包括响应时间、请求结果等

    * **使用 ViewResultsTree 监听器**: `ViewResultsTree` 是一个常用的监听器，可以显示测试结果树。
    * **自定义监听器**:
      * 如果需要更定制化的结果收集，可以创建自定义监听器类。
      * 自定义监听器需要实现 `ResultCollector` 接口，并在测试过程中添加到测试计划中。

* 代码案例拆解

![image-20231225165528863](img/image-20231225165528863.png)















#### 第2集 滴云自动化测试平台之JmeterEngine模块封装

**简介： 滴云自动化测试平台之JmeterEngine模块封装**

* 需求
  * 压测引擎支持两种测试计划录入
    * 本地上传JMX
    * 在线创建测试计划
  * 执行压测也分两种方式，对外提供HTTP接口，根据类型执行不同策略
    * 本地JMX执行
    * 在线创建测试计划执行

* 封装环境初始化工具类

![image-20231225162901905](img/image-20231225162901905.png)

* 编码实战

```
public class StressTestUtil {

    /**
     * 获取Jmeter的home目录，临时写法，后续部署上线前会调整
     */
    public static String getJmeterHome() {
        try {

            return StressTestUtil.class.getClassLoader().getResource("jmeter").getPath();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

    }

    /**
     * 获取Jmeter的bin目录
     */
    public static String getJmeterHomeBin() {
        return getJmeterHome() + File.separator + "bin";
    }


    /**
     * 设置JMeter的属性, 可以不触发调用
     */
    public static void initJmeterProperties() {
        // 获取JMeter的安装目录
        String jmeterHome = getJmeterHome();
        String jmeterHomeBin = getJmeterHomeBin();
        // 加载jmeter.properties文件
        JMeterUtils.loadJMeterProperties(jmeterHomeBin + File.separator + "jmeter.properties");
        // 设置JMeter的安装目录
        JMeterUtils.setJMeterHome(jmeterHome);
        //避免中文乱码
        JMeterUtils.setProperty("sampleresult.default.encoding","UTF-8");
        // 初始化本地环境
        JMeterUtils.initLocale();
        // 获取JMeter的属性文件
        //Properties jmeterProps = JMeterUtils.getJMeterProperties();

    }


    /**
     * 获取自定义jmeter压测引擎,封装方法，统一返回对象，后续改动则方便
     * @return
     */
    public static StandardJMeterEngine getJmeterEngine() {
        //初始化配置
        initJmeterProperties();
        StandardJMeterEngine standardJMeterEngine = new StandardJMeterEngine();
        return  standardJMeterEngine;
    }

}
```

















#### 第3集 压测引擎用例执行链路伪代码业务流程整理

**简介： 压测引擎用例执行链路伪代码业务流程整理**

* 需求

  * 开发用例执行HTTP接口，controller->service->mapper
  * 数量业务逻辑层的压测链路【伪代码逻辑】

* 开发执行接口

  * 业务接口开发
  
  ```
   	/**
       * 执行用例
       *
       * @param id
       * @return
       */
      @GetMapping("/execute")
      public JsonData execute(@RequestParam("projectId")Long projectId,@RequestParam("id") Long caseId) {
          stressCaseService.execute(projectId,caseId);
          return JsonData.buildSuccess();
      }
  
    	/**
       * 执行用例
       * 【1】查询用例详情
       * 【2】初始化测试报告
       * 【3】判断压测类型 JMX、SIMPLE
       * 【4】初始化测试引擎
       * 【5】组装测试计划
       * 【6】执行压测
       * 【7】发送压测结果明细
       * 【8】压测完成清理数据
       * 【9】通知压测结束
       */
  @Override  
  public void execute(Long projectId, Long caseId) {
  
          LambdaQueryWrapper <StressCaseDO> queryWrapper = new LambdaQueryWrapper<>();
          queryWrapper.eq(StressCaseDO::getProjectId, projectId).eq(StressCaseDO::getId, caseId);
  
          StressCaseDO stressCaseDO = stressCaseMapper.selectOne(queryWrapper);
        
        	//业务流程逻辑
        	
      }
  
  ```
  
  * 新增枚举
  
  ```
  public enum ReportTypeEnum {
      /**
       * 压测
       */
      STRESS,
      /**
       * 接口
       */
      API,
      /**
       * UI自动化
       */
      UI
  }
  
  public enum ReportStateEnum {
  
          /**
           * 执行中
           */
          EXECUTING,
  
          /**
           * 统计报告
            */
          COUNTING_REPORT,
  
          /**
           * 执行成功
           */
          EXECUTE_SUCCESS,
  
          /**
           * 执行失败
           */
          EXECUTE_FAIL;
  }
  ```
  
  
  
  
  
  







#### 第4集 数据服务-初始化压测报告接口开发实战

**简介： 数据服务-初始化压测报告接口开发实战**

* 注意
  * Jmeter路径调整，放到当前电脑上，避免每次打包文件太大
* 需求【测试报告服务】
  * 压测用例执行前需要初始化压测报告
  * 开发一个Feign接口用于RPC调用

* 开发实战

  ```
  	 /**
       * 远程保存测试报告
       * @param reportSaveReq
       * @return
       */
      @PostMapping("save")
      public JsonData save(@RequestBody ReportSaveReq reportSaveReq){
          ReportDTO reportDTO = reportService.saveReport(reportSaveReq);
          return JsonData.buildSuccess(reportDTO);
      }
  
  
      @Override
      public ReportDTO saveReport(ReportSaveReq reportSaveReq) {
          ReportDO reportDO = SpringBeanUtil.copyProperties(reportSaveReq, ReportDO.class);
          reportMapper.insert(reportDO);
  
          ReportDTO reportDTO = ReportDTO.builder().id(reportDO.getId())
                  .projectId(reportDO.getProjectId()).name(reportDO.getName()).build();
  
          return reportDTO;
      }
  ```

  

















#### 第5集 压测引擎-测试报告初始化Feign接口开发实战

**简介： 压测引擎-测试报告初始化Feign接口开发实战**

* 需求【测试引擎服务】

  * 压测用例执行前需要Feign远程初始化测试报告
  * 并且把相关测试报告概述信息传递给相关接口

* 开发实战

  ```
     			//生成测试报告
          ReportSaveReq reportSaveReq = ReportSaveReq.builder()
                  .projectId(stressCaseDO.getProjectId())
                  .caseId(stressCaseDO.getId())
                  .startTime(System.currentTimeMillis())
                  .executeState(ReportStateEnum.EXECUTING.name())
                  .name(stressCaseDO.getName()).type(ReportTypeEnum.STRESS.name()).build();
          JsonData jsonData = reportFeignService.saveReport(reportSaveReq);
  
          if(jsonData.isSuccess()){
              ReportDTO reportDTO = jsonData.getData(ReportDTO.class);
              //判断是自定义还是jmx压测
              if (StressSourceTypeEnum.SIMPLE.name().equalsIgnoreCase(stressCaseDO.getStressSourceType())) {
                  runSimpleStressCase(stressCaseDO,reportDTO);
  
              } else if (StressSourceTypeEnum.JMX.name().equalsIgnoreCase(stressCaseDO.getStressSourceType())) {
                  runJmxStressCase(stressCaseDO,reportDTO);
              } else {
                  JsonData.buildResult(BizCodeEnum.STRESS_UNSUPPORTED);
                  return;
              }
              JsonData.buildSuccess();
          }else {
              JsonData.buildResult(BizCodeEnum.REPORT_SAVE_FAILED);
          }
  ```

* 问题点

  * 现在执行JMX类型的用例，那JMX脚本从哪里获取？

<img src="img/image-20240104210039627-4373244.png" alt="image-20240104210039627" style="zoom:33%;" />













![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第九章 新一代分布式文件服务MinIO部署和开发实战



#### 第1集 分布式文件存储行业解决方案和技术选型分析

**简介： 分布式文件存储行业解决方案和技术选型分析**

* 背景说明

  * 数据爆炸的时代，产生的数据量不断地在攀升，基本都离不开文件存储
    - 存储单位从KB、MB、GB、TB、PB到ZB级别的数据，图片、文档、素材、静态化页面、长短视频、安装包等一系列文件 
    - 为什么我们云测平台需要文件存储
      * 需要上传JMX脚本到服务器
      * 接口文档上传
      * UI自动化测试截图上传等
  * 业务应用内存储
    - 传统的javaweb项目, 文件数量达到一定后占据大量的内存、磁盘和带宽, 无法满足海量请求的业务
    - 开发容易-扩容难
  * 分布式文件系统（Distributed File System)
    - 海量数据对存储提出了新的要求，从而诞生了分布式文件存储
    - 文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连
    - 扩容容易-开发难

* 目前业界比较多的解决方案

  * 免费：MinIO

    * 官网：https://minio.org.cn/

    ![image-20240104221326781](img/image-20240104221326781.png)

    * 是一个高性能、分布式的对象存储系统，完全兼容Amazon S3协议
    * 学习成本低，安装运维简单，主流语言的客户端整合都有, 号称最强的对象存储文件服务器
    * 提供简单的Web界面和广泛的API支持，方便集成和开发
    * 适用于各种规模的部署，从个人小型项目到大型企业级应用
    * 提供数据加密功能、访问控制、身份验证功能
    * 具有高可用性，可以在分布式环境中运行，并自动处理数据的冗余和复制
    * 高度可扩展性，可以根据需求增加更多的存储节点或容量来扩展存储规模

  <img src="img/image-20240104220450405.png" alt="image-20240104220450405" style="zoom:30%;" />

  * 花钱：云厂商

    - 阿里云OSS

    - 七牛云

    - 亚马逊云

      <img src="img/image-20240104220418216.png" alt="image-20240104220418216" style="zoom:30%;" />

* 面试官：滴云自动化测试平台如何选型哪类存储呢，自建或者云厂商如何思考，为啥选择这个？

  * 选云厂商理由

    * 优点：开发简单，功能强大，容易维护（不同网络下图片质量、水印、加密策略、扩容、加速）

    * 缺点：要钱, 个性化处理，未来转移比较复杂，不排除有些厂商会提供一键迁移工具

      

  - 选开源MinIO的理由

    - 优点：功能强大、可以根据业务做二次的定制，新一代分布式文件存储系统，容器化结合强大，更重要的是免费

    - 缺点：自己需要有专门的团队进行维护、扩容等

      

  * 推荐答案
    * 参考一：由于云测平台业务特殊性，多数企业会考虑【私有化】部署，因此如果绑定外部对象存储，则迁移麻烦
    * 参考二：公司现有的分布式文件存储基建平台采用的是MinIO，技术团队也比较熟悉，也满足业务需求















#### 第2集 Docker容器化部署分布式文件存储MinIO实战

**简介： Docker容器化部署分布式文件存储MinIO实战**

* 部署实战

  * 下载安装包 ，使用**【wget】或者【浏览器】远程下载相关依赖包（需要替换群里最新的）**

    ```
    原生资料下载方式(账号 - 密码 - ip地址 - 端口 需要替换群里最新的，其他路径不变)
    wget --http-user=用户名 --http-password=密码 http://ip:端口/dcloud_test/software_install_part2.zip
    
    
    #比如 命令行下
    wget --http-user=admin --http-password=xdclass.net888 http://47.115.31.28:9088/dcloud_test/software_install_part2.zip
    
    # 比如 浏览器直接访问
    http://47.115.31.28:9088/dcloud_test/software_install_part2.zip
    ```

  * 安装实战
    * 网络安全组开放端口 9000, 9001
    * 访问：ip+9001端口

* 操作

  * 界面登录
  * 文件上传下载

![image-20240104222112293](img/image-20240104222112293.png)













#### 第3集 SpringBoot3.X整合MinIO文件上传开发实战

**简介： SpringBoot3.X整合MinIO文件上传开发实战**

* 需求

  * SpringBoot3.X整合MinIO文件上传开发实战

* 编码实战

  * engine-service增加依赖

    ```
    <dependency>
    <groupId>io.minio</groupId>
    <artifactId>minio</artifactId>
    </dependency>
    ```

  * 配置文件

    ```
    minio.endpoint=http://120.79.56.211:9000
    minio.accessKey=minio_root
    minio.secretKey=minio_123456
    minio.bucketName=bucket
    ```

  * 配置类

    ```
    @Data
    @Component
    @ConfigurationProperties(prefix = "minio")
    public class MinioConfig {
        private String endpoint;
        private String accessKey;
        private String secretKey;
        private String bucketName;
    
        @Bean
        public MinioClient minioClient() {
            return MinioClient.builder()
                    .endpoint(endpoint)
                    .credentials(accessKey, secretKey)
                    .build();
        }
    }
    ```

  * 代码开发

    ```
        @PostMapping("/upload")
        public JsonData upload(@RequestParam("file") MultipartFile file) {
            return JsonData.buildSuccess(minioService.upload(file));
        }
        
         @Override
        public String upload(MultipartFile file) {
            // 获取上传文件名
            String filename = FileUtil.getFilename(file.getOriginalFilename());
            // TODO 作业-异步上传，改成线程池上传
            new Thread(() -> upload(file, filename)).start();
    
            return minioConfig.getEndpoint() + "/" + minioConfig.getBucketName() + "/" + filename;
        }
        
        
           /**
         * 上传文件
         *
         * @param file     文件对象
         * @param filename 文件名
         */
        private void upload(MultipartFile file, String filename) {
            if (file == null || file.getSize() == 0) {
                throw new BizException(BizCodeEnum.FILE_REMOTE_UPLOAD_IS_EMPTY);
            }
    
            try {
                InputStream inputStream = file.getInputStream();
                minioClient.putObject(PutObjectArgs.builder()
                        .bucket(minioConfig.getBucketName())
                        .object(filename)
                        .stream(inputStream, file.getSize(), -1)
                        .contentType(file.getContentType())
                        .build());
            } catch (Exception e) {
                throw new BizException(BizCodeEnum.FILE_REMOTE_UPLOAD_FAILED,e);
            }
        }
        
        
        
        public class FileUtil {
       
            /**
             * 生成文件名称
             * Timestamp + '-' + UUID + '-' + 原文件名
             * @param filename
             * @return
             */
            public static String getFilename(String filename) {
                return System.currentTimeMillis() + "-" +
                        (UUID.randomUUID().toString().replaceAll("-", "")) + "-" +
                        filename;
            }
        }
    ```

* 问题
  * 文件上传后不能公开读写吧，那怎么访问呢？

<img src="img/image-20240104214504083.png" alt="image-20240104214504083" style="zoom:50%;" />

















#### 第4集 MinIO文件临时访问URL生成接口开发实战

**简介： MinIO文件临时访问URL生成接口开发实战**

* 需求

  * 文件上传后的URL是不能直接访问的
  * 需要开发一个接口，生成临时可以访问的URL连接

* 编码实战

  * 文件临时访问URL接口开发

  ```
   		/**
       * 获取对象的临时访问url，有效期1分钟，也可以当参数传入
       */
      @Override
      public String getTempAccessFileUrl(String remoteFilePath) {
          try {
              String fileName = remoteFilePath.substring(remoteFilePath.lastIndexOf('/') + 1);
              GetPresignedObjectUrlArgs args = GetPresignedObjectUrlArgs.builder()
                      .bucket(minioConfig.getBucketName())
                      .object(fileName)
                      .expiry(1, TimeUnit.MINUTES)
                      .method(Method.GET)
                      .build();
              return minioClient.getPresignedObjectUrl(args);
          } catch (Exception e) {
              throw new BizException(BizCodeEnum.FILE_PRE_SIGNED_FAILED);
          }
      }
  ```

  * 测试上传文件，配置1分钟过期时间

















#### 第5集 远程URL文件读取接口工具类开发实战

**简介： 远程URL文件读取接口工具类开发实战**

* 需求

  * 有了文件上传和临时访问文件的接口
  * 需要开发一个可以读取远程文件的接口

* 编码实战

  * 读取远程文件的接口

  ```
  
      public static String readRemoteFile(String urlStr) {
          try {
              URL url = new URL(urlStr);
              URLConnection conn = url.openConnection();
              BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
              StringBuilder content = new StringBuilder();
              String line;
              while ((line = reader.readLine()) != null) {
                  content.append(line);
                  content.append(System.lineSeparator());
              }
              reader.close();
              return content.toString();
          } catch (Exception e) {
              throw new BizException(BizCodeEnum.FILE_REMOTE_READ_FAILED,e);
          }
      }
  ```

  * 测试读取MinIO存储的文件

























![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第十章 自定义压测结果收集器和多引擎执行类设计



#### 第1集 压测结果链路分析和自定义结果收集器测试

**简介： 压测结果链路分析和自定义压测结果收集器**

* 需求
  * 对接口进行压力测试，之前采用JMX压测产生的测试结果是存储到CSV，需要改造
  * 压测结果需要发送到队列里面去，然后另外一端进行消费

* 数据链路图

  <img src="img/image-20240106120951852.png" alt="image-20240106120951852" style="zoom:50%;" />

* 如何自定义压测结果收集器

  * 继承ResultCollector，重写里面的方法  `public void sampleOccurred(SampleEvent event)` 
  * sampleOccurred方法会收集每次请求的结果，里面可以获取压测相关的数据
  * 案例测试

  ```
  @Slf4j
  public class TestSampleCollector extends ResultCollector {
  
      public TestSampleCollector() {
          super();
      }
  
      public TestSampleCollector(Summariser summer) {
          super(summer);
      }
  
      @Override
      public void sampleOccurred(SampleEvent event) {
          super.sampleOccurred(event);
          System.out.println("label="+ event.getResult().getSampleLabel());
          System.out.println("getRequestHeaders="+ event.getResult().getRequestHeaders());
          System.out.println("getResponseHeaders="+ event.getResult().getResponseHeaders());
          System.out.println("ThreadGroup="+event.getThreadGroup());
          System.out.println("ResponseCode="+event.getResult().getResponseCode());
          System.out.println("Hostname="+event.getHostname());
          System.out.println("getResponseDataAsString="+event.getResult().getResponseDataAsString());
          AssertionResult[] assertionResults = event.getResult().getAssertionResults();
          for (AssertionResult assertionResult : assertionResults) {
              System.out.println("AssertionResult="+assertionResult.getName()+",FailureMessage="+assertionResult.getFailureMessage());
          }
      }
  
  }
  
  //修改之前测试的结果收集器
  //ResultCollector logger = new ResultCollector (summer);
  TestSampleCollector logger = new TestSampleCollector (summer);
  ```

* 正式开发思路

  * 构建一个Map存储不同的结果收集器
  * 注入消息组件对象，每次sampleOccurred触发的时候把结果收集发送到消息组件

















#### 第2集 压测引擎开发之自定义结果收集器实战《上》

**简介：  压测引擎开发之自定义结果收集器实战《上》**

* 需求

  * 自定义压测结果收集器，继承ResultCollector，重写里面的方法  `public void sampleOccurred(SampleEvent event)` 
  * 消息发送组件封装思想，可以灵活替换不同消息实现

* 知识点

  * `SamplingStatCalculator`类介绍

    * 是 Apache JMeter 中的一个类，用于计算采样器的统计数据类
    * 提供了对采样器结果的一些关键指标的快速访问，如样本数、平均时间、最小时间、最大时间等
    * 一个线程组下面可能有多个不同的请求，因此需要区分不同的统计数据类

    ![image-20240106152517236](img/image-20240106152517236.png)

* 编码实战

  ```
  /**
   * 封装接口，可以用kafka或者redis进行具体实现
   */
  public interface StressResultSenderService {
      /**
       * 发送测试结果
       * @param caseInfoDTO
       * @param reportTypeEnum
       * @param result
       * @throws Exception
       */
      void sendResult(CaseInfoDTO caseInfoDTO, TestTypeEnum reportTypeEnum, String result) ;
  }
  
  
  @Slf4j
  public class EngineSampleCollector extends ResultCollector {
  
      /**
       * 不同请求的计数器集合
       */
      private Map<String, SamplingStatCalculator> calculatorMap = new HashMap<>();
  
      /**
       * 注入消息对象实例，方便存储数据
       */
      private StressResultSenderService senderService;
  
      /**
       * 测试用例
       */
      private StressCaseDO stressCaseDO;
  
      /**
       * 测试报告
       */
      private ReportDTO reportDTO;
  
  
      public EngineSampleCollector(StressCaseDO stressCaseDO, Summariser summer, StressResultSenderService senderService, ReportDTO reportDTO) {
          super(summer);
          this.senderService = senderService;
          this.stressCaseDO = stressCaseDO;
          this.reportDTO = reportDTO;
      }
  
  
      @Override
      public void sampleOccurred(SampleEvent event) {
          super.sampleOccurred(event);
          SampleResult result = event.getResult();
          String sampleLabel = result.getSampleLabel();
  
          // 针对不同的请求分别实例化计数器,才可以区分出来请求的数据
          SamplingStatCalculator calculator = calculatorMap.get(sampleLabel);
  
          if (Objects.isNull(calculator)) {
              // 如果计数器不存在，则创建新的计数器，并添加样本结果
              calculator = new SamplingStatCalculator();
              calculator.addSample(result);
              calculatorMap.put(sampleLabel, calculator);
          } else {
              // 如果计数器已存在，则添加样本结果
              calculator.addSample(result);
          }
  
  				//封装测试结果对象
         
          // 序列化为json
  
          // 发送测试结果
  
      }
  
  }
  ```

  







#### 第3集 压测引擎开发之自定义结果收集器实战《下》

**简介：  压测引擎开发之自定义结果收集器实战《下》**

* 需求

  * 封装采样器结果对象DTO，完善`sampleOccurred`方法逻辑

* 编码实战

  ```
  @Data
  public class StressSampleResultDTO {
      /**
       *结果ID
       */
      private Long reportId;
  
      /**
       * 时间戳
       */
      private Long sampleTime;
      /**
       *采样器标签，请求名称
       */
      private String samplerLabel;
      /**
       *采样次数
       */
      private Long samplerCount;
      /**
       *平均响应时间
       */
      private Double meanTime;
      /**
       *最小响应时间
       */
      private Integer minTime;
      /**
       *最大响应时间
       */
      private Integer maxTime;
  
      /**
       *错误百分比
       */
      private Double errorPercentage;
  
      /**
       * 错误请求数
       */
      private Long errorCount;
      /**
       *每秒请求速率
       */
      private Double requestRate;
      /**
       *每秒接收KB
       */
      private Double receiveKBPerSecond;
      /**
       *每秒发送KB
       */
      private Double sentKBPerSecond;
  
      /**
       *线程数量
       */
      private Integer threadCount;
  
      /**
       * 请求协议 主机 路径 端口  参数
       */
      private String requestLocation;
      /**
       * 请求头
       */
      private String requestHeader;
  
      /**
       * 请求参数
       */
      private String requestBody;
      /**
       * 响应码
       */
      private String responseCode;
      /**
       * 响应头
       */
      private String responseHeader;
      /**
       * 响应体
       */
      private String responseData;
  
      /**
       * 断言信息
       */
      private String assertInfo;
  }
  
  ```

  ```
  
  
          StressSampleResultDTO sampleResultInfoDTO = new StressSampleResultDTO();
          //测试报告id
          sampleResultInfoDTO.setReportId(reportDTO.getId());
          // 设置时间戳
          sampleResultInfoDTO.setSampleTime(result.getTimeStamp());
          // 设置请求标签
          sampleResultInfoDTO.setSamplerLabel(result.getSampleLabel());
          // 设置样本计数
          sampleResultInfoDTO.setSamplerCount(calculator.getCount());
          // 设置平均时间
          sampleResultInfoDTO.setMeanTime(calculator.getMean());
          // 设置最小时间
          sampleResultInfoDTO.setMinTime(calculator.getMin().intValue());
          // 设置最大时间
          sampleResultInfoDTO.setMaxTime(calculator.getMax().intValue());
  
          // 设置错误百分比
          sampleResultInfoDTO.setErrorPercentage(calculator.getErrorPercentage());
          // 设置错误计数
          sampleResultInfoDTO.setErrorCount(calculator.getErrorCount());
          // 设置请求速率
          sampleResultInfoDTO.setRequestRate(calculator.getRate());
          // 设置接收数据大小
          sampleResultInfoDTO.setReceiveKBPerSecond(calculator.getKBPerSecond());
          // 设置发送数据大小
          sampleResultInfoDTO.setSentKBPerSecond(calculator.getSentKBPerSecond());
  
  
          //设置请求路径参数
          sampleResultInfoDTO.setRequestLocation(event.getResult().getUrlAsString());
          // 设置请求头
          sampleResultInfoDTO.setRequestHeader(event.getResult().getRequestHeaders());
          // 设置请求体
          sampleResultInfoDTO.setRequestBody(event.getResult().getSamplerData());
          // 设置响应码
          sampleResultInfoDTO.setResponseCode(event.getResult().getResponseCode());
          // 设置响应头
          sampleResultInfoDTO.setResponseHeader(event.getResult().getResponseHeaders());
          // 设置响应数据
          sampleResultInfoDTO.setResponseData(event.getResult().getResponseDataAsString());
  
          //断言信息
          AssertionResult[] assertionResults = event.getResult().getAssertionResults();
          StringBuilder assertMsg = new StringBuilder();
          if (Objects.nonNull(assertionResults)) {
              for(AssertionResult assertionResult : assertionResults){
                  assertMsg.append("name=").append(assertionResult.getName()).append(",msg=").append(assertionResult.getFailureMessage()).append(",");
              }
          }
          sampleResultInfoDTO.setAssertInfo(assertMsg.toString());
  
          // 将信息以列表形式存入Redis,以时间戳为Key
          String sampleResultJson = JSON.toJSONString(sampleResultInfoDTO);
  
          log.error(sampleResultJson);
  
          // 发送测试结果
          CaseInfoDTO caseInfoDTO = new CaseInfoDTO(stressCaseDO.getId(),stressCaseDO.getModuleId(),stressCaseDO.getName());
          senderService.sendResult(caseInfoDTO, TestTypeEnum.STRESS,sampleResultJson);
  ```

  













#### 第4集 模版方法设计模式讲解和多引擎执行类设计

**简介： 多引擎执行抽象类设计和模版方法设计模式介绍**

* 需求
  * 由于SIMPLE和JMX两个类型压测引擎执行链路类似，可以把公共的逻辑抽取
  * 不同的逻辑交给子类进行实现，可以更灵活，推荐采用模版方法设计模式
  * **此类设计模式在很多项目中有大量使用，属于关键设计模式，面试重点**

* 模板方法模式Template Method

  - 定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中
  - 使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤，属于行为型模式
  - 关键角色
    - 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法
    - 基本方法：是整个算法中的一个步骤，包括抽象方法和具体方法
      - 抽象方法：在抽象类中申明，由具体子类实现。
      - 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它

  <img src="img/image-20240106155750617.png" alt="image-20240106155750617" style="zoom:50%;" />

* 应用场景

  - 有多个子类共有逻辑相同的方法，可以考虑作为模板方法
  - 设计一个系统时知道算法所需的关键步骤，且确定步骤的执行顺序，但某些步骤的具体实现还未知，可以延迟到子类进行完成

  ```
  小滴课堂-老王成功晋升为管理者，但是团队来了很多新兵，由于团队水平参差不齐，经常有新项目进来，但整体流程很不规范。
   
  一个项目的生命周期：需求评审-设计-开发-测试-上线-运维。整个周期里面，需求评审-设计是固定的操作，
   
  而其他步骤则流程耗时等是根据项目来定的。
  
  因此老王梳理了一个模板，来规范化项目，他只管核心步骤和项目里程碑产出的结果，具体的工时安排和开发就让团队成员去操作
  ```

  

* 案例实践

  ```
  /**
   * 抽象类(Abstract Class)
   */
  public abstract class AbstractClass {
      
      /**
       * 模版方法
       */
      public void templateMethod() {
          specificMethod();
          abstractMethod1();
          abstractMethod2();
      }
  
      /**
       * 具体方法
       */
      public void specificMethod() {
          System.out.println("抽象类中的具体方法被调用");
      }
  
      // 抽象方法1
      public abstract void abstractMethod1();   
  
     // 抽象方法2
      public abstract void abstractMethod2(); 
  }
  ```

  









#### 第5集 测试引擎执行类-模版方法骨架类开发实战

**简介： 测试引擎执行类-模版方法骨架类开发实战**

* 需求

  * 执行引擎模版方法骨架梳理和开发
  * 开发部分公共方法

* 编码实战

  * 骨架类方法

  ```
  
      /**
       * 最终的测试计划
       */
      private HashTree testPlanHashTree;
  
      /**
       * 测试引擎
       */
      private StandardJMeterEngine engine;
  
      /**
       * 应用上下文
       */
      protected ApplicationContext applicationContext;
  
      /**
       * 测试用例
       */
      protected StressCaseDO stressCaseDO;
  
      /**
       * 测试报告
       */
      protected ReportDTO reportDTO;
  
      /**
       * 组装测试计划
       */
      public abstract void assembleTestPlan();
  
      
  
      /**
       * 模版方法设计模式,具体由子类进行实现
       */
      public void startStressTest() {
          //初始化测试引擎
          this.initStressEngine();
  
          //获取测试计划
           this.assembleTestPlan();
  
          //方便调试 TODO 可以不用
          this.hashTree2Jmx();
  
          //运行压测
          this.run();
  
          // 运行完场景之后,清理数据
          this.clearData();
  
          //更新测试报告
          this.updateReport();
  
       }
  
  
      /**
       * 创建底层测试引擎
       */
      public void initStressEngine(){
          engine = StressTestUtil.getJmeterEngine();;
      }
  
      /**
       * 更新测试报告 TODO
       */
      public void updateReport() {
      }
  
      public EngineSampleCollector getResultCollector(StressCaseDO stressCaseDO, ResultSenderService senderService, ReportDTO reportDTO) {
          // 结果收集
          String summariserName = JMeterUtils.getPropDefault("summariser.name", "summary");
          Summariser summary = summariserName.isEmpty() ? null : new Summariser(summariserName);
  
          // 自定义结果收集.继承自ResultCollector,将SampleResult的数据进行缓存
          EngineSampleCollector engineSampleCollector = new EngineSampleCollector(stressCaseDO,summary, senderService, reportDTO);
  
          // 这两个方法都是继承自ResultCollector的方法
          engineSampleCollector.setName(stressCaseDO.getName());
          engineSampleCollector.setEnabled(Boolean.TRUE);
  
          return engineSampleCollector;
      }
  
      /**
       * 执行场景
       *
       * @param testPlanTree JMeter测试计划树
       */
      public void run() {
          if (Objects.nonNull(testPlanHashTree)) {
              // 配置测试计划树
              engine.configure(testPlanHashTree);
              engine.run();  // 运行引擎
          }
      }
  
  		//清理数据 TODO
      public void clearData(){
         
      }
  
  
      /**
       * 将 ListedHashTree 对象转换为 JMX 文件。
       * @param h 要转换的 ListedHashTree 对象
       * @throws IOException 如果在转换过程中发生 I/O 错误
       */
      public void hashTree2Jmx()  {
          try {
              StressTestUtil.initJmeterProperties();
              SaveService.loadProperties();
              String localTempFile = System.getProperty("user.dir")+ File.separator+"static"+File.separator+ IdUtil.simpleUUID() +".jmx";
  
              SaveService.saveTree(testPlanHashTree, new FileOutputStream(localTempFile));
          }catch (Exception e){
              log.error("转换失败",e);
          }
  
      }
  ```

  

  









![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第十一章 JMX测试引擎执行类和可变参数开发实战



#### 第1集  JMX测试引擎执行类开发之组装测试计划

**简介：   JMX测试引擎执行类开发之组装测试计划**

* 需求
  * 组装JMX类型测试计划

![image-20231225162901905](img/image-20231225162901905.png)

* 编码实战

  ```
  
      @Override
      public void assembleTestPlan() {
  
          File jmxFile = null;
          //收集器添加到测试计划里面
          HashTree testPlanTree = null;
          try {
              //创建在文件名中会创建随机数以防文件名重复
              jmxFile = File.createTempFile("jmeter-script", ".xml");
              try (FileWriter writer = new FileWriter(jmxFile)) {
                  FileService minioService = applicationContext.getBean(FileService.class);
                  String tempFileUrl = minioService.getTempFileUrl(stressCaseDO.getJmxUrl());
                  String jmxContent = FileUtil.readRemoteFile(tempFileUrl);
                  writer.write(jmxContent);
              }
               testPlanTree = SaveService.loadTree(jmxFile);
              JMeter.convertSubTree(testPlanTree, false);
  
              //获取结果收集器
              EngineSampleCollector resultCollector = super.getResultCollector(applicationContext.getBean(KafkaResultSenderServiceImpl.class));
              testPlanTree.add(testPlanTree.getArray()[0], resultCollector);
  
              //处理参数化
              parseParamFilesToScript(testPlanTree);
          } catch (IOException e) {
              throw new BizException(BizCodeEnum.FILE_CREATE_TEMP_FAILED, e);
          } finally {
              if (jmxFile != null) {
                  boolean flag = jmxFile.delete();
                  if (!flag) {
                      log.error("删除临时文件失败");
                  } else {
                      log.info("删除临时文件成功");
                  }
              } else {
                  log.warn("没有临时文件删除");
              }
          }
          super.setTestPlanHashTree(testPlanTree);
      }
  ```

  

















#### 第2集  JMX测试引擎执行类开发之链路测试

**简介：   JMX测试引擎执行类开发之链路测试**

* 需求

  * 上传JMX脚本，执行测试用例，断点调试查看是否成功执行输出日志

* 测试实战

  * 脚本

  ```
  INSERT INTO `test_engine`.`stress_case` (`id`, `project_id`, `module_id`, `environment_id`, `name`, `description`, `assertion`, `relation`, `stress_source_type`, `thread_group_config`, `jmx_url`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (1, 1, 1, 1, 'JMX测试用例query', NULL, NULL, NULL, 'JMX', NULL, 'http://120.79.56.211:9000/bucket/query.jmx', NULL, NULL, NULL, NULL, NULL, NULL, '2024-01-08 10:11:41', '2024-01-08 10:12:30');
  ```

  

<img src="img/image-20240108160201683.png" alt="image-20240108160201683" style="zoom:50%;" />























#### 第3集 压测引擎之Jmeter的CSV可变参数案例讲解

**简介：  压测引擎之Jmeter的CSV可变参数案例讲解**

* 需求

  - 业务开发里面参数一般不是固定方式，单参数可能走缓存则影响性能，所以会采用可变参数进行压测
  - 比如压测商品详情，查看id从1~100 的商品详情

  <img src="img/image-20240108142906316.png" alt="image-20240108142906316" style="zoom:50%;" />

* Jmeter原生 CSV可变参数配置实战

  - 线程组—>添加—>配置原件—>CSV Data Set Config

  ![image-20220920212918122](img/image-20220920212918122.png)

  - CSV参数读取配置

  ![image-20220920213341061](img/image-20220920213341061-4694613.png)













#### 第4集 【重点】云测平台压测引擎可变参数架构设计

**简介：  【重点】云测平台压测引擎可变参数架构设计**

* 需求

  * 查看原生的JMX里面带可变参数的组成结构，梳理如果是平台化应该如何设计和交互

  * 带CSV文件的JMX脚本结构介绍

    ![image-20240108143224004](img/image-20240108143224004.png)

* 可变参数压测-架构链路设计**难点三问**

  * CSV参数不是固定的，包括有多个文件、多个参数等，这个**数据库表应该如何设计？**
  * JMX脚本里面的文件路径是写死本地的，云测平台压测执行的时候，**CSV参数文件如何和JMX脚本关联起来？**
  * 测试完成后，如何清理相关临时参数文件数据？

  <img src="img/image-20240108144920581.png" alt="image-20240108144920581" style="zoom:50%;" />















#### 第5集 【重点】压测引擎可变参数架构设计三问解决方案

**简介：  【重点】压测引擎可变参数架构设计三问解决方案**

* 可变参数压测-架构链路设计**难点三问**

  * CSV参数不是固定的，包括有多个文件、多个参数等，这个**数据库表应该如何设计？**

    * 测试用例的 `relation` 字段，存储JSON数组，每个JSON对象就是一个可变参数对象，通过name名称匹配具体哪个可变参数

    ```
    [{"sourceType":"csv","delimiter":",","ignoreFirstLine":false,"recycle":true,"variableNames":"id,title","remoteFilePath":"http://120.24.7.58:9000/bucket/1702282773153-b577f8b5c103447faf75dce8a7ee0005-test.csv","name":"CSV商品数据集合"},
    
    {"sourceType":"csv","delimiter":",","ignoreFirstLine":false,"recycle":true,"variableNames":"phone","remoteFilePath":"http://120.24.7.58:9000/bucket/1702282773153-b577f8b5c103447faf75dce8a7ee0005-test.csv","name":"CSV登录集合"},
    
    {"sourceType":"csv","delimiter":",","ignoreFirstLine":false,"recycle":true,"variableNames":"price,detail","remoteFilePath":"http://120.24.7.58:9000/bucket/1702282773153-b577f8b5c103447faf75dce8a7ee0005-test.csv","name":"CSV商品数据集合二"}]
    ```

    

  * JMX脚本里面的文件路径是写死本地的，云测平台压测执行的时候，**CSV参数文件如何和JMX脚本关联起来？**

    * 通过分布式文件存储相关的可变参数，文件名称需要和JMX里面可变参数名称匹配

    ![image-20240108145754600](img/image-20240108145754600.png)

  * 测试完成后，如何清理相关临时参数文件数据？

    * 测试完成后，通过临时的JMX脚本找到可变参数的文件路径，执行删除

    ![image-20240108145902886](img/image-20240108145902886.png)















#### 第6集 JMX压测引擎之可变参数链路开发实战《上》

**简介：  JMX压测引擎之可变参数链路开发实战《上》**

* 需求
  * 封装可变参数对象，映射relation字段的JSON数组
  * 根据远程文件地址读取内容到本地创建临时文件封装

* 编码实战

  * 参数对象封装

  ```
  @Data
  public class CSVDataFileDTO {
      /**
       * 必填，文件名 比如： CSV商品数据集合
       */
      private String name;
  
      /**
       * 必填，文件远程上传路径
       */
      private String remoteFilePath;
  
      /**
       * 下载到本地到临时文件路径
       */
      private String localFilePath;
  
      /**
       * 类型，目前只支持csv
       */
      private String sourceType = "csv";
      /**
       * 设置分隔符为逗号
       */
      private String delimiter = ",";
      /**
       * 设置是否忽略第一行
       */
      private Boolean ignoreFirstLine = false;
      /**
       * 是否循环读取数据
       */
      private Boolean recycle = true;
  
      /**
       * 变量名
       */
      private String variableNames;
  
  }
  ```

  * 根据远程文件地址读取内容到本地创建临时文件封装

  ```
  
      @Override
      public String copyRemoteFileToLocalTempFile(String remoteFilePath) {
  
          String localTempFile = System.getProperty("user.dir")+ File.separator+"static"+File.separator+ IdUtil.simpleUUID() +"."+ CustomFileUtil.getSuffix(remoteFilePath);
          CustomFileUtil.mkdir(localTempFile);
          try {
              String tempFileUrl = getTempFileUrl(remoteFilePath);
              // 从远程URL获取输入流
              URL url = new URL(tempFileUrl);
              InputStream inputStream = url.openStream();
              // 将输入流的内容持久化到磁盘上的文件
              Path localFile = Path.of(localTempFile);
              Files.copy(inputStream, localFile, StandardCopyOption.REPLACE_EXISTING);
              // 关闭资源
              inputStream.close();
              return localFile.toFile().getPath();
          }catch (Exception e){
              throw new BizException(BizCodeEnum.FILE_REMOTE_DOWNLOAD_FAILED,e);
          }
  
      }
  ```

  













#### 第7集 JMX压测引擎之可变参数链路开发实战《下》

**简介：  JMX压测引擎之可变参数链路开发实战《下》**

* 需求

  * 开发JMX关联可变参数文件

* 编码实战

  ```
    /**
       * 将测试计划和参数文件进行关联，
       * 每个元素都有 testclass、testname、enabled等属性，用于区分，
       * 多个csv文件，要求上传的文件名和jmx里面配置的csv文件名一样，才可以替换成功
       *
       * @param testPlanTree 测试计划树
       */
      public void parseParamFilesToScript(HashTree testPlanTree) {
          FileService fileService = applicationContext.getBean(FileService.class);
  
          // 获取关系
          String relation = stressCaseDO.getRelation();
          // 将关系转为CSVDataFileDTO对象的列表
          List<CSVDataFileDTO> csvDataFileDTOS = JsonUtil.json2List(relation, CSVDataFileDTO.class);
  
          // 定义CSV data set的列表
          List<CSVDataSet> csvDataSetList = new ArrayList<>();
  
          // 对脚本进行遍历
          SearchByClass<TestElement> testElementVisitor = new SearchByClass<>(TestElement.class);
          testPlanTree.traverse(testElementVisitor);
          Collection<TestElement> testElementCollection = testElementVisitor.getSearchResults();
  
          // 提取压测脚本中是CSV配置类的，存储到list里面
          for (TestElement testElement: testElementCollection) {
              if (testElement instanceof CSVDataSet csvDataSet) {
                  String csvIsEnable = csvDataSet.getProperty("TestElement.enabled").getStringValue();
                  // 如果当前的CSV Data Set是启用状态
                  if (Objects.equals(csvIsEnable, "true") ){
                      // 将当前的CSV Data Set放置到列表中
                      csvDataSetList.add(csvDataSet);
                  }
              }
          }
  
          // 通过列表的遍历修改脚本中CSV Data Set的filename(CSV和脚本关联)
          for (CSVDataSet csvDataSetElement: csvDataSetList) {
              // 获取csv文件名称，然后匹配
              String csvDataSetSlotName = csvDataSetElement.getProperty("TestElement.name").getStringValue();
              if(csvDataFileDTOS!= null){
                  for(CSVDataFileDTO csvDataFileDTO : csvDataFileDTOS){
                      if (Objects.equals(csvDataSetSlotName, csvDataFileDTO.getName())) {
                          String localTempFilePath = fileService.copyRemoteFileToLocalTempFile(csvDataFileDTO.getRemoteFilePath());
                          csvDataSetElement.setProperty("filename", localTempFilePath);
                      }
                  }
              }
          }
      }
  ```

  * JSON工具类

  ```
  @Slf4j
  public class JsonUtil {
      private static final ObjectMapper MAPPER = new ObjectMapper();
      static {
  
          //设置可用单引号
          MAPPER.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);
  
          //序列化的时候序列对象的所有属性
          MAPPER.setSerializationInclusion(JsonInclude.Include.ALWAYS);
  
          //反序列化的时候如果多了其他属性,不抛出异常
          MAPPER.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
  
          //下划线和驼峰互转
          //mapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
  
          //如果是空对象的时候,不抛异常
          MAPPER.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
  
          //取消时间的转化格式,默认是时间戳,可以取消,同时需要设置要表现的时间格式
          MAPPER.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
          MAPPER.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
      }
  
  
      public static ObjectMapper get() {
          return MAPPER;
      }
  
  
      /**
       * 对象转为Json字符串
       * @param data
       * @return
       */
      public static String obj2Json(Object obj) {
          String jsonStr = null;
          try {
              jsonStr = MAPPER.writeValueAsString(obj);
          } catch (JsonProcessingException e) {
              log.error("json格式化异常:{}",e);
          }
          return jsonStr;
      }
      /**
       * json字符串转为对象
       * @param str
       * @param valueType
       * @return
       */
      public static <T> T json2Obj(String jsonStr, Class<T> beanType) {
          T obj = null;
          try {
              obj = MAPPER.readValue(jsonStr, beanType);
          } catch (Exception e){
              log.error("json格式化异常:{}",e);
          }
          return obj;
      }
  
      /**
       * json数据转换成pojo对象list
       * @param jsonData
       * @param beanType
       * @return
       */
      public static <T> List<T> json2List(String jsonData, Class<T> beanType) {
          JavaType javaType = MAPPER.getTypeFactory().constructParametricType(List.class, beanType);
          try {
              return MAPPER.readValue(jsonData, javaType);
          } catch (Exception e) {
              log.error("json格式化异常:{}",e);
          }
          return new ArrayList<>(0);
      }
  
  
  
  }
  ```

  













#### 第8集 压测结束清理资源文件相关接口开发

**简介：  压测结束清理资源文件相关接口开发**

* 需求

  * 清理压测结束后的相关资源文件
  * 完善模版方法里面的骨架内容

* 编码实战

  ```
  
      public void clearData(){
          // 对脚本进行遍历
          SearchByClass<TestElement> testElementVisitor = new SearchByClass<>(TestElement.class);
          testPlanHashTree.traverse(testElementVisitor);
          Collection<TestElement> testElementCollection = testElementVisitor.getSearchResults();
          // 提取压测脚本中是CSV配置类的，存储到list里面
          for (TestElement testElement: testElementCollection) {
              if (testElement instanceof CSVDataSet csvDataSet) {
                  String filename = csvDataSet.getProperty("filename").getStringValue();
                  Path path = Paths.get(filename);
                  try {
                      Files.delete(path);
                  } catch (IOException e) {
                      throw new RuntimeException(e);
                  }
              }
          }
  
      }
  ```

  



















#### 第9集  JMX测试引擎执行类开发之可变参数链路测试

**简介：   JMX测试引擎执行类开发之可变参数链路测试**

* 需求

  * 上传JMX脚本，增加可变参数用例，执行测试用例

  ```
  [{"sourceType":"csv","delimiter":",","ignoreFirstLine":false,"recycle":true,"variableNames":"id","remoteFilePath":"http://120.79.56.211:9000/bucket/id.csv","name":"商品id集合"}]
  
  
  
  INSERT INTO `test_engine`.`stress_case` (`id`, `project_id`, `module_id`, `environment_id`, `name`, `description`, `assertion`, `relation`, `stress_source_type`, `thread_group_config`, `jmx_url`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (2, 1, 1, 1, 'CSV测试用例', NULL, NULL, '[{\"sourceType\":\"csv\",\"delimiter\":\",\",\"ignoreFirstLine\":false,\"recycle\":true,\"variableNames\":\"id\",\"remoteFilePath\":\"http://120.79.56.211:9000/bucket/id.csv\",\"name\":\"商品id集合\"}]', 'JMX', NULL, 'http://120.79.56.211:9000/bucket/query_csv.jmx', NULL, NULL, NULL, NULL, NULL, NULL, '2024-01-09 06:54:24', '2024-01-09 06:56:37');
  ```

  * 断点调试查看是否成功执行输出日志

* 测试实战

![image-20240109144441893](img/image-20240109144441893.png)









![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第十二章 滴云自动化测试平台测试报告开发实战



#### 第1集  新版Kafka3.X-Kraft架构介绍和部署实战

**简介：   新版Kafka3.X-Kraft架构介绍和部署实战**

* 需求

  * 海量压测报告，不能通过RPC直接保存，需要中间加个消息队列缓冲
  * 多个MQ中间里面，选择Kafka进行处理，需要部署Kafka

  <img src="img/image-20240110144546174.png" alt="image-20240110144546174" style="zoom:50%;" />

* **什么是Kafka-Kraft架构**

  - 是 Kafka 在 2.8.0 版本中引入的一种新的复制协议和存储系统架构
  - 之前Kafka元数据存储在zk中，运行时动态选举controller，由controller进行Kafka集群管理。
  - 而Kraft模式不依赖ZK集群，用controller节点代替ZK，元数据保存在controller中，由controller直接进行Kafka集群管理
  - Kafka-Kraft 将 Kafka 的元数据和控制逻辑从 ZooKeeper 中解耦，使得 Kafka 集群不再依赖 ZooKeeper

  ![img](img/image-20230725144419509.png)

* 容器化部署实战

  * 下载安装包 ，使用**【wget】或者【浏览器】远程下载相关依赖包（需要替换群里最新的）**

    ```
    原生资料下载方式(账号 - 密码 - ip地址 - 端口 需要替换群里最新的，其他路径不变)
    wget --http-user=用户名 --http-password=密码 http://ip:端口/dcloud_test/software_install_part3.zip
    
    
    #比如 命令行下
    wget --http-user=admin --http-password=xdclass.net888 http://47.115.31.28:9088/dcloud_test/software_install_part3.zip
    
    # 比如 浏览器直接访问
    http://47.115.31.28:9088/dcloud_test/software_install_part3.zip
    ```

  





















#### 第2集  SpringBoot3.X整合新版Kafka3.X综合实战

**简介：   SpringBoot3.X整合新版Kafka3.X综合实战**

* 需求

  * SpringBoot3.X整合Kafka配置，测试消息的生产和消费实战

* 编码实战

  * 增加依赖 压测引擎服务和数据服务

  ```
   <dependency>
              <groupId>org.springframework.kafka</groupId>
              <artifactId>spring-kafka</artifactId>
  </dependency>
  ```

  * 增加配置文件

    * 压测引擎服务

    ```
    spring.kafka.producer.bootstrap-servers=120.24.7.58:9092
    ```

    * 数据服务

    ```
    # 指定 Kafka 服务器的地址和端口。多个服务器使用逗号分隔。
    spring.kafka.producer.bootstrap-servers=120.24.7.58:9092
    spring.kafka.consumer.bootstrap-servers=120.24.7.58:9092
    
    #配置监听器的确认模式。这里设置为 manual_immediate，表示手动确认模式，即在消息处理完成后立即进行确认。
    spring.kafka.listener.ack-mode=manual_immediate
    
    #设置消费者是否自动提交偏移量。这里配置为 false，即禁用自动提交。
    spring.kafka.consumer.enable-auto-commit=false
    
    #配置偏移量读取策略
    spring.kafka.consumer.auto-offset-reset=earliest
    ```

  * 单元测试代码

    * 数据服务-消费者代码

    ```
    public class KafkaTopicConfig {
    
        public static final String STRESS_TOPIC_NAME = "stress_report_topic";
    
        public static final String API_TOPIC_NAME = "api_report_topic";
    
        public static final String UI_TOPIC_NAME = "ui_report_topic";
    
        public static final String REPORT_STATE_TOPIC_NAME = "report_state_topic";
    }
    
    
    @Component
    public class MQListener {
    
      
        /**
         * 消费监听 压测日志详情
         *
         * @param record
         */
        @KafkaListener(topics = {KafkaTopicConfig.STRESS_TOPIC_NAME}, groupId = "xdclass-stress-test-gp")
        public void onStressReportDetailMessage(ConsumerRecord<?, ?> record, Acknowledgment ack, @Header(KafkaHeaders.RECEIVED_TOPIC) String topic) {
            // 打印出消息内容
            System.out.println("消费：" + record.topic() + "-" + record.partition() + "-" + record.value());
            reportDetailService.handleStressReportDetail(record.value().toString());
            ack.acknowledge();
    
        }
    }
    ```

    

    * 测试引擎-生产者代码

    ```
    @SpringBootTest
    public class KafkaTest {
    
        @Resource
        private KafkaTemplate<String, String> kafkaTemplate;
    
        @Test
        public void send() {
            kafkaTemplate.send(KafkaTopicConfig.STRESS_TOPIC_NAME, "case_id_1","test xdclass");
        }
    }
    ```

    

    

    

    



#### 第3集  滴云自动化测试平台-压测引擎测试报告发送实战

**简介：   滴云自动化测试平台-压测引擎测试报告开发实战**

* 需求
  * 压测引擎消息发送封装，支持接口自动化、UI自动化、压力测试三种类型

* 编码实战

  ```
  @Service
  public class KafkaResultSenderServiceImpl implements ResultSenderService {
  
  
      @Resource
      private KafkaTemplate<String, String> kafkaTemplate;
  
  
      @Override
      public void sendResult(CaseInfoDTO caseInfoDTO, TestTypeEnum reportTypeEnum, String result) {
  
          // 根据reportTypeEnum选择不同的方法
          switch (reportTypeEnum) {
              case UI:
                  // 发送UI压测结果
                  sendUiResult(caseInfoDTO, result);
                  break;
              case STRESS:
                  // 发送压测结果
                  sendStressResult(caseInfoDTO, result);
                  break;
              case API:
                  // 发送API压测结果
                  sendApiResult(caseInfoDTO, result);
                  break;
              default:
                  break;
          }
  
  
      }
  
      /**
       * 发送压测结果
       *
       * @param caseInfoDTO
       * @param result
       */
      private void sendStressResult(CaseInfoDTO caseInfoDTO, String result) {
          kafkaTemplate.send(KafkaTopicConfig.STRESS_TOPIC_NAME, "case_id_" + caseInfoDTO.getId(), result);
      }
  
      /**
       * 发送UI执行结果
       *
       * @param caseInfoDTO
       * @param result
       */
      private void sendUiResult(CaseInfoDTO caseInfoDTO, String result) {
          kafkaTemplate.send(KafkaTopicConfig.UI_TOPIC_NAME, "case_id_" + caseInfoDTO.getId(), result);
      }
  
      /**
       * 发送API执行结果
       *
       * @param caseInfoDTO
       * @param result
       */
      private void sendApiResult(CaseInfoDTO caseInfoDTO, String result) {
          kafkaTemplate.send(KafkaTopicConfig.API_TOPIC_NAME, "case_id_" + caseInfoDTO.getId(), result);
      }
  
  
  }
  ```

  













#### 第4集  数据服务-压测报告消费者开发实战和链路测试

**简介：数据服务-压测报告消费者开发实战和链路测试**

* 需求
  * 消费压测报告，保存相关测试报告明细到数据库

* 编码实战

  ```
  
  @Override
  public void handleStressReportDetail(String reportContent) {
          StressSampleResultDTO stressSampleResultDTO = JsonUtil.json2Obj(reportContent, StressSampleResultDTO.class);
          ReportDetailStressDO reportDetailStressDO = SpringBeanUtil.copyProperties(stressSampleResultDTO, ReportDetailStressDO.class);
          reportDetailStressMapper.insert(reportDetailStressDO);
  }
  
  ```

* 链路测试实战

![image-20240110180350853](img/image-20240110180350853.png)











#### 第5集 【重点】压测报告统计状态更新问题和方案设计

**简介：【重点】压测报告统计状态更新问题和方案设计**

* 问题描述

  * 压测用例执行过程中会一直发送测试报告，**测试报告状态是怎么变化的**？
  * 压测报告的统计聚合信息什么时候统计会比较好？
  * 如何知道某个压测用例执行完成后，队列中的测试报告都消费完成了？

  <img src="img/image-20240110183056351.png" alt="image-20240110183056351" style="zoom:50%;" />

  

* 方案设计
  * 测试用例执行完成后，RPC调用 修改report的状态为 统计中
  * 消费者：查询如果测试报告明细，然后睡眠一段时间；再查询一次测试报告明细，对比是否有还有更新；
  * 如果测试报告明细还有更新，则重新发送MQ消息， 继续第二步等待消费消息和检测是否更新，也更新统计信息；
  * 如果测试报告明细没更新.则修改report状态，为执行成功
* 链路数据交互图

![image-20240111142303473](img/image-20240111142303473.png)























#### 第6集 压测报告统计状态和聚合统计开发实战《上》

**简介：压测报告统计状态更新和聚合统计开发实战**

* 需求

  * 开发测试用例执行完成后，RPC调用 修改report的状态为 统计中

* 编码实战

  ```
  	
      /** data-service的contoller
       * 远程更新测试报告状态
       * @param reportUpdateReq
       */
      @PutMapping("update")
      public void update(@RequestBody ReportUpdateReq reportUpdateReq){
          reportService.updateReportState(reportUpdateReq);
      }
  
  
  
    
      /**  feign接口
       * 更新测试报告
       * @param reportUpdateReq
       * @return
       */
      @PutMapping(value = "/api/v1/report/update")
      void updateReport(@RequestBody ReportUpdateReq reportUpdateReq);
  
  
  
    
    /**
       * 更新测试报告
       */
      public void updateReport() {
          //测试引擎非活跃的时候，避免数据处理不及时
          while (!getEngine().isActive()){
              ReportFeignService reportFeignService = applicationContext.getBean(ReportFeignService.class);
              //更新测试报告
              ReportUpdateReq reportUpdateReq = ReportUpdateReq.builder().id(reportDTO.getId()).
                      state(ReportStateEnum.COUNTING_REPORT.name()).endTime(System.currentTimeMillis()).build();
              reportFeignService.updateReport(reportUpdateReq);
              break;
          }
  
      }
  ```

  









#### 第7集 压测报告统计状态更新和聚合统计开发实战《下》

**简介：压测报告统计状态更新和聚合统计开发实战**

* 需求
  * 查询如果测试报告明细，然后睡眠一段时间；再查询一次测试报告明细，对比是否有还有更新；
  * 如果测试报告明细还有更新，则重新发送MQ消息， 继续第二步等待消费消息和检测是否更新，也更新统计信息；
  * 如果测试报告明细没更新.则修改report状态，为执行成功

* 编码实战

  * 测试报告状态查询和聚合统计测试报告信息

  ```
  
      @Override
      public void updateReportState(ReportUpdateReq reportUpdateReq) {
  
          ReportDTO reportDTO = ReportDTO.builder().id(reportUpdateReq.getId()).endTime(reportUpdateReq.getEndTime()).executeState(reportUpdateReq.getState()).build();
          ReportDO reportDO = reportMapper.selectById(reportDTO.getId());
  
          //发送一个消息-> 消费者读取最新报告，睡眠3秒 再读取最新报告，如果有更新，则重新发送消息；如果没更新.则处理完成测试报告
          LambdaQueryWrapper<ReportDetailStressDO> queryWrapper = new LambdaQueryWrapper<>(ReportDetailStressDO.class)
                  .eq(ReportDetailStressDO::getReportId, reportDTO.getId()).orderByDesc(ReportDetailStressDO::getSamplerCount).last("limit 1");
  
          ReportDetailStressDO oldReportDetailDO = stressReportDetailMapper.selectOne(queryWrapper);
          try {
              TimeUnit.SECONDS.sleep(5);
          } catch (InterruptedException e) {
          }
  
          ReportDetailStressDO newReportDetailDO = stressReportDetailMapper.selectOne(queryWrapper);
          if (newReportDetailDO.getSamplerCount() > oldReportDetailDO.getSamplerCount()) {
              //有更新，则重新发送消息；
              reportDO.setExecuteState(ReportStateEnum.COUNTING_REPORT.name());
              kafkaTemplate.send(KafkaTopicConfig.REPORT_STATE_TOPIC_NAME, "report_id_" + reportDTO.getId(), JsonUtil.obj2Json(reportUpdateReq));
          } else {
              //没更新.则处理完成测试报告
              reportDO.setExecuteState(ReportStateEnum.EXECUTE_SUCCESS.name());
          }
          reportDO.setEndTime(reportDTO.getEndTime());
          reportDO.setExpandTime(reportDTO.getEndTime() - reportDO.getStartTime());
          reportDO.setQuantity(newReportDetailDO.getSamplerCount());
          reportDO.setFailQuantity(newReportDetailDO.getErrorCount());
          reportDO.setPassQuantity(reportDO.getQuantity() - reportDO.getFailQuantity());
          Map<String, Object> summaryMap = new HashMap<>();
          summaryMap.put("QPS", newReportDetailDO.getRequestRate());
          summaryMap.put("错误请求百分比", newReportDetailDO.getErrorPercentage());
          summaryMap.put("平均响应时间(毫秒)", newReportDetailDO.getMeanTime());
          summaryMap.put("最大响应时间(毫秒)", newReportDetailDO.getMaxTime());
          summaryMap.put("最小响应时间(毫秒)", newReportDetailDO.getMinTime());
          reportDO.setSummary(JsonUtil.obj2Json(summaryMap));
          //更新报告状态
          reportMapper.updateById(reportDO);
  
  
      }
  ```

  * 消息消费

  ```
    /**
       * 消费监听，处理测试报告和更新状态
       *
       * @param record
       */
      @KafkaListener(topics = {KafkaTopicConfig.REPORT_STATE_TOPIC_NAME}, groupId = "xdclass-report-test-gp")
      public void onStressReportStateMessage(ConsumerRecord<?, ?> record, Acknowledgment ack, @Header(KafkaHeaders.RECEIVED_TOPIC) String topic) {
          // 打印出消息内容
          System.out.println("消费：" + record.topic() + "-" + record.partition() + "-" + record.value());
          reportService.updateReportState(JsonUtil.json2Obj(record.value().toString(), ReportUpdateReq.class));
          ack.acknowledge();
  
      }
  
  ```

  

















#### 第8集 JMX压测引擎用例执行+报告查看全链路测试

**简介：JMX压测引擎用例执行+报告查看全链路测试**

* 需求
  *  JMX压测引擎全链路测试，执行用例，产生测试报告明细发送成+消费成功
  * 测试报告状态更新正确+测试报告概述生成成功
* 测试实战

<img src="img/image-20240110183500003.png" alt="image-20240110183500003" style="zoom:40%;" />











![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第十三章 云测平台SIMPLE压测引擎和链路讲解



#### 第1集  压测引擎SIMPLE类型功能体验和设计说明

**简介：   压测引擎SIMPLE类型功能体验和设计说明**

* 需求
  * JMX类型压测引擎：本地上传录制的JMX脚本进行执行
  * SIMPLE类型压测引擎：直接在线创建测试计划,生成JMX脚本
  * 云测平台正式域名为  dmeter.cn

* 线程组基本信息配置

![image-20240112143021053](img/image-20240112143021053.png)

* 采样器配置

![image-20240112143040609](img/image-20240112143040609.png)

* 断言和参数化配置

![image-20240112143055631](img/image-20240112143055631.png)













#### 第2集 压测引擎动态生成压测脚本快速案例实战

**简介：  压测引擎动态生成压测脚本快速案例实战**

* 需求

  * 理清什么是在线生成压测脚本
  * 可以通过java代码案例直接生成jmx脚本，并完成测试

* 案例实战

  ```
  
      @Test
      public void testJmeterOnline() throws IOException {
  
          StandardJMeterEngine jmeter = StressTestUtil.getJmeterEngine();
          // 创建JMeter的TestPlan树结构并设置相关属性
          HashTree testPlanTree = new HashTree();
          // 设置HTTP请求的名称、协议、域名、端口、路径和方法
          HTTPSamplerProxy httpSampler = new HTTPSamplerProxy();
          httpSampler.setName("HTTP Sampler");
          httpSampler.setProtocol("http");
          httpSampler.setDomain("127.0.0.1");
          httpSampler.setPort(8082);
          httpSampler.setPath("/api/v1/test/query");
          httpSampler.setMethod("GET");
          httpSampler.setProperty(TestElement.TEST_CLASS, HTTPSamplerProxy.class.getName());
          httpSampler.setProperty(TestElement.GUI_CLASS, HttpTestSampleGui.class.getName());
          httpSampler.setEnabled(true);
          // 添加请求参数
          httpSampler.addArgument("id", "1");
  
          // 创建Loop Controller
          LoopController loopController = new LoopController();
          loopController.setLoops(1);
          loopController.setFirst(true);
          loopController.setProperty(TestElement.TEST_CLASS, LoopController.class.getName());
          loopController.setProperty(TestElement.GUI_CLASS, LoopControlPanel.class.getName());
          loopController.initialize();
  
          //Thread Group 创建Thread Group
          ThreadGroup threadGroup = new ThreadGroup();
          threadGroup.setName("API Thread Group");
          threadGroup.setNumThreads(5); //Users
          threadGroup.setRampUp(2); //Seconds
          threadGroup.setSamplerController(loopController);
          threadGroup.setProperty(TestElement.TEST_CLASS, ThreadGroup.class.getName());
          threadGroup.setProperty(TestElement.GUI_CLASS, ThreadGroupGui.class.getName());
          threadGroup.setIsSameUserOnNextIteration(true);
          threadGroup.setScheduler(false);
  
  
          //Test Plan，将Test Plan、Thread Group和HTTP Sampler添加到Test Plan树结构中
          TestPlan testPlan = new TestPlan("JMeter Script From Java Code");
          testPlan.setProperty(TestElement.TEST_CLASS, TestPlan.class.getName());
          testPlan.setProperty(TestElement.GUI_CLASS, TestPlanGui.class.getName());
          testPlan.setUserDefinedVariables((Arguments) new ArgumentsPanel().createTestElement());
  
          testPlanTree.add(testPlan);
          HashTree threadGroupHashTree = testPlanTree.add(testPlan, threadGroup);
          threadGroupHashTree.add(httpSampler);
  
          //保存Test Plan到JMX文件,方便调试使用，可以不生成
          String jmxFilePath = IdUtil.simpleUUID() +".jmx";
          File jmxFile = new File(jmxFilePath);
          jmxFile.createNewFile();
          SaveService.saveTree(testPlanTree, new FileOutputStream(jmxFile));
  
          // Summariser对象
          Summariser summer = null;
          // Summariser名称
          String summariserName = JMeterUtils.getPropDefault("summariser.name", "summary");
          if (!summariserName.isEmpty()) {
              // 创建Summariser对象
              summer = new Summariser(summariserName);
          }
          // 结果日志文件名
          String logFile = "example_simple.csv";
          // 结果收集器
          TestResultCollector logger = new TestResultCollector(summer);
          logger.setFilename(logFile);
          // 将结果收集器添加到测试计划树上
          testPlanTree.add(testPlanTree.getArray()[0], logger);
          // 配置JMeter引擎
          jmeter.configure(testPlanTree);
          // 运行JMeter测试
          jmeter.run();
  
      }
  
  ```

  















#### 第3集 压测引擎动态生成压测脚本架构设计思路

**简介：  压测引擎动态生成压测脚本架构设计思路**

* 需求
  * 基于上集的案例，进行平台化设计，相关配置存储数据库，动态组装测试脚本
  * 和JMX类型不一样，SIMPLE类型压测支持**多环境切换**
  * 理清数据库表的关键字段内容

* 架构设计说明

  * 交互链路图讲解

  ![image-20240113113903642](img/image-20240113113903642.png)

  * 数据库特殊字段说明

    * thread_group_config

    ```
    {
        "threadGroupName":"测试",
        "numThreads":"2",
        "rampUp":"1",
        "loopCount":"5",
        "schedulerEnabled":false,
        "duration":0,
        "delay":0
    }
    ```

    * assertion

    ```
    [
        {
            "name":"响应码",
            "action":"EQUAL",
            "from":"RESPONSE_CODE",
            "value":"200"
        },
        {
            "name":"响应头",
            "action":"CONTAIN",
            "from":"RESPONSE_HEADER",
            "value":"cookies"
        }
    ]
    ```

    * header

    ```
    [
        {
            "key":"a",
            "value":"b"
        },
        {
            "key":"c",
            "value":"d"
        },
        {
            "key":"Content-Type",
            "value":"application/x-www-form-urlencoded"
        }
    ]
    ```

    * query（专门是get方式查询拼接query参数）

    ```
    [
        {
            "key":"id",
            "value":"1"
        }
    ]
    ```

    

    * body（专门是post方式提交）

    ```
    # JSON方式
    非参数化：{"id":52,"amount":2323}
    参数化：{"id":"${id}","amount":2323}
    
    # X-WWW-FORM-URLENCODED 方式
    非参数化：mail=794666918@qq.com&pwd=11111
    参数化：mail=${mail}&pwd=11111
    ```

    

* 设计思考
  * 是否可以把http相关参数路径等也封装成json对象存储，然后区分不同的采样器



















#### 第4集 在线生成压测脚本JSON配置类映射开发实战

**简介：  在线生成压测脚本JSON配置类映射开发实战**

* 需求

  * 把SIMPLE类型配置存储在表的json对象，开发对应的映射类

* 开发实战

  ```
  @Data
  public class ThreadGroupConfigDTO {
  
      /**
       * 线程组名称
       */
      private String threadGroupName;
  
      /**
       * 线程数
       */
      private Integer numThreads;
  
      /**
       * 线程组启动时间
       */
      private Integer rampUp;
  
      /**
       * 循环次数，如果-1则是永久循环
       */
      private Integer loopCount;
  
  
  
      /**
       * 是否配置调度器
       */
      private Boolean schedulerEnabled;
  
      /**
       * 持续时间，秒
       */
      private Integer duration;
  
      /**
       * 启动延长时间，秒
       */
      private Integer delay;
  }
  
  @Data
  public class KeyValueDTO {
      private String key;
      private String value;
  }
  
  
  
  @Data
  public class StressAssertionDTO {
  
      /**
       * 断言名称
       */
      private String name;
  
      /**
       * 断言规则，"contain|equal"
       */
      private String action;
  
      /**
       * 断言字段类型， "responseCode|responseData|responseHeader"
       */
      private String from;
  
      /**
       * 断言目标值
       */
      private String value;
  }
  
  
  public enum StressAssertActionEnum {
      /**
       * 包括
       */
      CONTAIN,
  
      /**
       * 完全匹配
       */
      EQUAL;
  
  }
  
  
  
  public enum StressAssertFieldFromEnum {
      /**
       * 响应码
       */
      RESPONSE_CODE,
  
      /**
       * 响应头
       */
      RESPONSE_HEADER,
  
      /**
       * 响应体
       */
      RESPONSE_DATA;
  
  }
  ```

  















![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第十四章 云测平台在线生成压测脚本开发实战



#### 第1集  在线生成压测脚本骨架方法开发实战

**简介：   压测引擎SIMPLE类型功能体验和设计说明**

* 需求
  * 参考JMX类型，开发StressSimpleEngine类
  * 拆分案例代码，并完成 assembleTestPlan的实现类骨架

* 编码实战

  * 多环境配置

  ```
  
  private void runSimpleStressCase(StressCaseDO stressCaseDO, ReportDTO reportDTO) {
          EnvironmentDO environmentDO = environmentMapper.selectById(stressCaseDO.getEnvironmentId());
  
          //创建引擎
          BaseStressEngine stressEngine = new StressSimpleEngine( environmentDO,stressCaseDO,reportDTO,applicationContext);
  
          //运行压测
          stressEngine.startStressTest();
  
  }
  ```

  * 测试计划组装

  ```
  
      public void assembleTestPlan() {
  
  
          //获取结果收集器
          EngineSampleCollector resultCollector = super.getResultCollector( applicationContext.getBean(KafkaResultSenderServiceImpl.class));
  
          //获取测试计划
  
          //创建hashTree
          ListedHashTree testHashTree = new ListedHashTree();
  
          // 创建测试计划
          TestPlan testPlan = createTestPlan();
  
          // 创建线程组,里面配置了循环控制器
          ThreadGroup threadGroup = createThreadGroup();
  
          //创建HTTP请求头
          HeaderManager headerManager = createHeaderManager();
  
          // 创建http请求收集器
          HTTPSamplerProxy httpSamplerProxy = createHTTPSamplerProxy();
  
          //创建断言列表
          List<ResponseAssertion> responseAssertionList = createResponseAssertion();
  
          //处理参数化数据
          List<CSVDataSet> csvDataSetList = createCSVDataSet();
  
          HashTree threadGroupHashTree = testHashTree.add(testPlan, threadGroup);
  
          // 将http请求采样器添加到线程组下
          threadGroupHashTree.add(httpSamplerProxy);
  
          //添加压测结果收集器
          threadGroupHashTree.add(resultCollector);
  
          if (headerManager != null) {
              threadGroupHashTree.add(headerManager);
          }
          if (responseAssertionList != null) {
              threadGroupHashTree.add(responseAssertionList);
          }
          if (csvDataSetList != null) {
              threadGroupHashTree.add(csvDataSetList);
          }
  
          super.setTestPlanHashTree(testHashTree);
  
      }
  ```

  













#### 第2集  压测平台测试计划和线程组配置开发实战

**简介：   压测平台测试计划和线程组配置开发实战**

* 需求
  * 开发在线生成测试计划的骨架方法开发实战
  * 功能方法：测试计划、线程组配置、循环控制器解析

* 编码实战

  ```
  /**
       * 创建测试计划
       *
       * @return
       */
      public TestPlan createTestPlan() {
  
          TestPlan testPlan = new TestPlan(stressCaseDO.getName());
          testPlan.setProperty(TestElement.TEST_CLASS, TestPlan.class.getName());
          testPlan.setProperty(TestElement.GUI_CLASS, TestPlanGui.class.getName());
          testPlan.setUserDefinedVariables((Arguments) new ArgumentsPanel().createTestElement());
          testPlan.setSerialized(true);
          testPlan.setTearDownOnShutdown(true);
          return testPlan;
      }
  
  
      public ThreadGroup createThreadGroup() {
  
          ThreadGroupConfigDTO configDTO = JsonUtil.json2Obj(stressCaseDO.getThreadGroupConfig(), ThreadGroupConfigDTO.class);
          ThreadGroup threadGroup = new ThreadGroup();
          threadGroup.setName(configDTO.getThreadGroupName());
          threadGroup.setNumThreads(configDTO.getNumThreads());
          threadGroup.setRampUp(configDTO.getRampUp());
  
          //调度器配置
          if (configDTO.getSchedulerEnabled()) {
              threadGroup.setScheduler(true);
              threadGroup.setDuration(configDTO.getDuration());
              threadGroup.setDelay(configDTO.getDelay());
          }
  
          //创建循环控制器
          LoopController loopController = createLoopController(configDTO.getLoopCount());
          //设置线程组循环控制器
          threadGroup.setSamplerController(loopController);
          threadGroup.setEnabled(true);
          threadGroup.setProperty(new StringProperty(ThreadGroup.ON_SAMPLE_ERROR, "continue"));
          threadGroup.setProperty(TestElement.TEST_CLASS, ThreadGroup.class.getName());
          threadGroup.setProperty(TestElement.GUI_CLASS, ThreadGroupGui.class.getName());
          return threadGroup;
      }
  
      /**
       * 创建循环控制器
       */
      public LoopController createLoopController(Integer loopCount) {
          // 创建循环控制器
          LoopController loopController = new LoopController();
          loopController.setLoops(loopCount);
          loopController.setFirst(true);
          loopController.setProperty(TestElement.TEST_CLASS, LoopController.class.getName());
          loopController.setProperty(TestElement.GUI_CLASS, LoopControlPanel.class.getName());
          loopController.initialize();
          return loopController;
      }
  
  ```

  







#### 第3集  压测平台HTTP请求头和采样器开发实战

**简介：   压测平台HTTP请求头和采样器开发实战**

* 需求

  * 开发在线生成测试计划的骨架方法开发实战
  * 功能方法：创建HTTP请求头、创建http请求收集器和请求参数管理

* 编码实战

  ```
     //将请求头参数存入HeaderManager对象中
      private HeaderManager createHeaderManager() {
  
          if (StringUtils.isBlank(stressCaseDO.getHeader())) {
              return null;
          }
          List<KeyValueDTO> requestHeaders = JsonUtil.json2List(stressCaseDO.getHeader(), KeyValueDTO.class);
          if (requestHeaders == null || requestHeaders.isEmpty()) {
              return null;
          }
          HeaderManager headerManager = new HeaderManager();
          headerManager.setEnabled(true);
          headerManager.setName("headers");
          headerManager.setProperty(TestElement.GUI_CLASS, HeaderPanel.class.getName());
          headerManager.setProperty(TestElement.TEST_CLASS, HeaderManager.class.getName());
          requestHeaders.forEach(keyValueConfig -> {
              headerManager.add(new Header(keyValueConfig.getKey(), keyValueConfig.getValue()));
          });
          return headerManager;
  
      }
      
      
     
      /**
       * 创建HTTP请求采样器
       *
       * @return
       */
      public HTTPSamplerProxy createHTTPSamplerProxy() {
  
          HTTPSamplerProxy httpSampler = new HTTPSamplerProxy();
          httpSampler.setProperty(TestElement.TEST_CLASS, HTTPSamplerProxy.class.getName());
          httpSampler.setProperty(TestElement.GUI_CLASS, HttpTestSampleGui.class.getName());
          httpSampler.setContentEncoding("UTF-8");
          httpSampler.setName(stressCaseDO.getName());
          httpSampler.setProtocol(environmentDO.getProtocol());
          httpSampler.setDomain(environmentDO.getDomain());
          httpSampler.setPort(environmentDO.getPort());
  
          httpSampler.setMethod(stressCaseDO.getMethod());
  
          httpSampler.setProperty("HTTPSampler.path", stressCaseDO.getPath());
  
          httpSampler.setAutoRedirects(false);
          httpSampler.setUseKeepAlive(true);
          httpSampler.setFollowRedirects(true);
          httpSampler.setPostBodyRaw(true);
  
          //处理请求参数
          if (HttpMethod.GET.name().equals(stressCaseDO.getMethod()) && StringUtils.isNotBlank(stressCaseDO.getQuery())) {
              List<KeyValueDTO> keyValueDTOS = JsonUtil.json2List(stressCaseDO.getQuery(), KeyValueDTO.class);
              for (KeyValueDTO keyValueDTO : keyValueDTOS) {
                  httpSampler.addArgument(keyValueDTO.getKey(), keyValueDTO.getValue());
              }
          } else {
              Arguments sampleArguments = createArguments();
              httpSampler.setArguments(sampleArguments);
          }
          return httpSampler;
      }
      
      
      
       /**
       * 创建请求参数
       *
       * @return 请求参数实例
       */
      public Arguments createArguments() {
          Arguments sampleArguments = new Arguments();
          sampleArguments.setProperty(TestElement.TEST_CLASS, Arguments.class.getName());
          sampleArguments.setProperty(TestElement.GUI_CLASS, HTTPArgumentsPanel.class.getName());
          //当前没用，主要是记录content-type方便类型判断
          String bodyType = stressCaseDO.getBodyType();
          HTTPArgument httpArgument = new HTTPArgument();
          httpArgument.setValue(stressCaseDO.getBody());
          httpArgument.setAlwaysEncoded(false);
          sampleArguments.addArgument(httpArgument);
          return sampleArguments;
      }
  
  ```

  









#### 第4集 动态生成压测脚本多方法链路测试实战《上》

**简介：  动态生成压测脚本基础链路测试实战**

* 需求
  * 组装测试计划基本骨架，完成链路测试
  * 测试需求
    * 支持get方法带参数+请求头提交
    * 支持post方法带参数+请求头提交
      * json格式
      * 表单格式

* 案例实战

  * 方法骨架编码实战

  ```
          HashTree threadGroupHashTree = testHashTree.add(testPlan, threadGroup);
          // 将http请求采样器添加到线程组下
          threadGroupHashTree.add(httpSamplerProxy);
          //添加压测结果收集器
          threadGroupHashTree.add(resultCollector);
          if (headerManager != null) {
              threadGroupHashTree.add(headerManager);
          }
          super.setTestPlanHashTree(testHashTree);
  ```

* 链路测试实战

  * 录入用例

  ```
  INSERT INTO `test_engine`.`stress_case` (`id`, `project_id`, `module_id`, `environment_id`, `name`, `description`, `assertion`, `relation`, `stress_source_type`, `thread_group_config`, `jmx_url`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (3, 1, 1, 1, 'SIMPLE用例Get查询', NULL, NULL, NULL, 'SIMPLE', '{\"threadGroupName\":\"测试\",\"numThreads\":\"2\",\"rampUp\":\"1\",\"loopCount\":\"2\",\"schedulerEnabled\":false,\"duration\":0,\"delay\":0}', NULL, '/api/v1/test/query', 'GET', '[{\"key\":\"id\",\"value\":2},{\"key\":\"age\",\"value\":99}]', '[{\"key\":\"token\",\"value\":\"66666\"},{\"key\":\"name\",\"value\":\"jack\"}]', NULL, NULL, '2024-01-14 13:45:58', '2024-01-14 13:55:43');
  ```

  * 支持get方法带参数+请求头提交
  * thread_group_config

  ```
  {"threadGroupName":"测试","numThreads":"2","rampUp":"1","loopCount":"2","schedulerEnabled":false,"duration":0,"delay":0}
  ```

  * query

  ```
  [{"key":"id","value":2},{"key":"age","value":99}]
  ```

  * header

  ```
  [{"key":"token","value":"66666"},{"key":"name","value":"jack"}]
  ```

<img src="img/image-20240114133253617.png" alt="image-20240114133253617" style="zoom:50%;" />



















#### 第5集 动态生成压测脚本多方法链路测试实战《下》

**简介：  动态生成压测脚本基础链路测试实战**

* 需求
  * 组装测试计划基本骨架，完成链路测试
  * 测试需求
    * 支持get方法带参数提交
    * 支持post方法带参数提交
      * json格式
      * 表单格式

* 链路测试实战

  * 用例录入

  ```
  INSERT INTO `test_engine`.`stress_case` (`id`, `project_id`, `module_id`, `environment_id`, `name`, `description`, `assertion`, `relation`, `stress_source_type`, `thread_group_config`, `jmx_url`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (4, 1, 1, 1, 'SIMPLE用例post-json提交', NULL, NULL, NULL, 'SIMPLE', '{\"threadGroupName\":\"测试\",\"numThreads\":\"2\",\"rampUp\":\"1\",\"loopCount\":\"2\",\"schedulerEnabled\":false,\"duration\":0,\"delay\":0}', NULL, '/api/v1/test/pay_json', 'POST', NULL, '[{\"key\":\"token\",\"value\":\"66666\"},{\"key\":\"name\",\"value\":\"jack\"},{\"key\":\"Content-Type\",\"value\":\"application/json\"}]', '{\"id\":1,\"amount\":8899}', 'JSON', '2024-01-14 14:43:10', '2024-01-14 14:45:38');
  INSERT INTO `test_engine`.`stress_case` (`id`, `project_id`, `module_id`, `environment_id`, `name`, `description`, `assertion`, `relation`, `stress_source_type`, `thread_group_config`, `jmx_url`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (5, 1, 1, 1, 'SIMPLE用例post-form表单', NULL, NULL, NULL, 'SIMPLE', '{\"threadGroupName\":\"测试\",\"numThreads\":\"2\",\"rampUp\":\"1\",\"loopCount\":\"2\",\"schedulerEnabled\":false,\"duration\":0,\"delay\":0}', NULL, '/api/v1/test/login_form', 'POST', NULL, '[{\"key\":\"token\",\"value\":\"66666\"},{\"key\":\"name\",\"value\":\"jack\"},{\"key\":\"Content-Type\",\"value\":\"application/x-www-form-urlencoded\"}]', 'mail=7892323@qq.com&pwd=123', 'FORM', '2024-01-14 14:48:12', '2024-01-14 14:51:12');
  ```

  

  * 支持post方法带参数+请求头提交

    * json格式
    * 表单格式

    <img src="img/image-20240114134019205.png" alt="image-20240114134019205" style="zoom:50%;" />











![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第十五章 进阶在线生成压测脚本参数化-断言实战



#### 第1集  Jmeter压测原生断言配置和jmx脚本解析实战

**简介：   Jmeter压测原生断言配置和jmx脚本解析实战**

* 什么是断言assert
  - 指期望用户指定的条件满足，它是当用户定义的约束条件不满足时触发异常
  - 简单说：**判断程序结果是否符合预期**
  - 什么时候应该用断言
    - 多数情况都可以，但是推荐使用较为简单的断言，比如响应断言
    - 复杂断言会消耗压测机器的性能

- 增加断言

  - 步骤： 线程组 -> 添加 -> 断言 -> 响应断言

  ![image-20220920180756687](img/image-20220920180756687.png)

  * 测试字段（选择哪些字段进行断言）
    - **响应文本 Text response：** 响应服务器返回的文本内容
    - **响应代码 Response Code：** 断言Http 响应码是否符合预期，比如 200
    - 响应消息 Response Message ： 验证响应消息是否按预期显示
    - 响应标头 Response Headers ： 断言查看特定的 HTTP 标头是否存在
    - 文档（文本）Document (text)： 基本不用，高负载可能会占用大量内存导致OOM
    - URL样例 URL Sampled ： 针对请求的 URL 使用以确保它符合预期

  - 模式匹配的规则
    - **包括 Contains：** 响应内容【包含】需要匹配，支持正则表达式。
    - **匹配 Matches：** 响应内容要【完全匹配】需要匹配代表响应成功，大小写不敏感，支持正则表达式。
    - **相等 Equals：** 响应内容要【完全等于】需要匹配代表响应成功，大小写敏感，内容是字符串
    - 字符串Substring: 响应内容【包含需要匹配】的内容才代表响应成功，大小写敏感，内容是字符串
    - **不相等 Not：** 取反操作，不相等
    - OR： 应用 OR 组合中的每个断言，将多个断言模式进行OR连接
  - 案例实战
    - http响应码断言
    - 响应文本断言















#### 第2集【新特性】新版JDK之多条件匹配switch应用场景

**简介：  新版JDK特性优化之多条件匹配switch应用场景**

* 背景

  * 多个逻辑条件匹配的时候，大家最熟悉的是if和else，另外有不少同学会有switch
  * 传统switch存在比较多的使用问题
    * **自上而下的匹配**：
      - 默认情况下，switch语句是自上而下匹配的。
      - 如果忘记写`break`，后面的case语句无论是否匹配都会执行，这被称为“case穿透”。
    * **共用块范围**：
      - 所有case语句共享同一个块范围。
      - 在不同的case语句中定义的变量名不能重复。
    * **不能作为返回值**：
      - 整个switch语句不能作为表达式的返回值。
  * 新版JDK里面对switch做出了很大的优化

* 知识点讲解

  * 旧版本switch案例

  ```
  public static void testOldSwitch1(int i){
    
    switch(i){
      case 0:
        System.out.println("zero");
      case 1:
        System.out.println("one");
      case 2:
        System.out.println("two");
      default:
        System.out.println("default");
    }
  }
   
  public static void testOldSwitch2(int i){
    switch(i){
      case 0:
        System.out.println("zero");
        break;
      case 1:
        System.out.println("one");
        break;
      case 2:
        System.out.println("two");
        break;
      default:
        System.out.println("default");
    }
  }
  ```

  

  * 新版本switch案例

    * JDK12，对case增加了另一种写法，使用case C -> { } 代替break语句
      * 使⽤箭头函数，不⽤声明break, 会⾃动终⽌, 如果case语句中只有一条语句，可以省略大括号
      * case 标签-> 与 case 标签：不能混用， 一个 switch 语句块中使用一种语法格式。
    * ⽀持多个值匹配,使⽤逗号分隔
    * JDK13中引入了yield语句，用于返回值

    ```
    public static void testNewSwitch1(int i){
      switch(i){
        case 0 -> {
          System.out.println("zero");
          System.out.println("这是多⾏语句测试案例");
        }
        case 1,111 -> System.out.println("one");
        case 2,22 -> System.out.println("two");
        default -> System.out.println("default");
      }
    }
    
    
    public static  void testNewSwitch2() {
            int week = 3;
            String day = switch (week){
                case 1 -> {
                    System.out.println("星期日，小滴课堂老王和湧哥今天去会所按摩");
                    yield "星期日";
                }
                case 2,3,4,5,6 -> {
                    System.out.println("工作日，冰冰和Anna白天再摸鱼");
                    yield "2-6工作日";
                }
                case 7 -> {
                    System.out.println("星期六，小滴课堂湧哥独自录制算法大课熬夜中");
                    yield "星期六";
                }
                default -> {
                    System.out.println("假期放假被安排相亲");
                    yield "其他日期";
                }
            };
            System.out.println("day = " + day);
        }
    ```

    













#### 第3集 云测平台在线生成压测脚本之断言配置开发实战

**简介：  云测平台在线生成压测脚本之断言配置开发实战**

* 需求
  * 参考原生Jmeter压测配置断言例子，使用Java代码配置jmx断言

* 编码实战

  ```
  
      /**
       * 创建响应断言
       *
       * @return 响应断言列表
       */
      private List<ResponseAssertion> createResponseAssertion() {
          if (StringUtils.isBlank(stressCaseDO.getAssertion())) {
              return null;
          }
          // 将断言DTO列表转换为ResponseAssertion列表
          List<StressAssertionDTO> assertionDTOList = JsonUtil.json2List(stressCaseDO.getAssertion(), StressAssertionDTO.class);
  
          // 创建响应断言列表
          List<ResponseAssertion> responseAssertionList = new ArrayList<>(assertionDTOList.size());
  
          // 遍历断言DTO列表
          for (StressAssertionDTO stressAssertionDTO : assertionDTOList) {
              // 创建响应断言
              ResponseAssertion responseAssertion = new ResponseAssertion();
              responseAssertion.setName(stressAssertionDTO.getName());
              responseAssertion.setAssumeSuccess(false);
  
              // 设置断言规则，比如包含、完全匹配等
              String action = stressAssertionDTO.getAction();
              StressAssertActionEnum stressAssertActionEnum = StressAssertActionEnum.valueOf(action);
              switch (stressAssertActionEnum) {
                  case CONTAIN -> responseAssertion.setToContainsType();
                  case EQUAL -> responseAssertion.setToEqualsType();
                  default -> throw new BizException(BizCodeEnum.STRESS_ASSERTION_UNSUPPORTED_ACTION);
              }
  
  
              // 设置断言类型，比如响应头，响应体等
              StressAssertFieldFromEnum stressAssertFieldFromEnum = StressAssertFieldFromEnum.valueOf(stressAssertionDTO.getFrom());
              switch (stressAssertFieldFromEnum) {
                  case RESPONSE_CODE -> responseAssertion.setTestFieldResponseCode();
                  case RESPONSE_HEADER -> responseAssertion.setTestFieldResponseHeaders();
                  case RESPONSE_DATA -> responseAssertion.setTestFieldResponseData();
                  default -> throw new BizException(BizCodeEnum.STRESS_ASSERTION_UNSUPPORTED_FROM);
              }
  
              // 增加测试的结果数据
              responseAssertion.addTestString(stressAssertionDTO.getValue());
              responseAssertionList.add(responseAssertion);
          }
  
          // 返回响应断言列表
          return responseAssertionList;
      }
  ```

  











#### 第4集 云测平台在线生成压测脚本断言链路测试实战

**简介：  云测平台在线生成压测脚本断言链路测试实战**

* 需求
  * 配置测试用例，增加断言类型，进行链路测试
  * 断言
    * 响应码断言
    * 响应体断言

* 链路测试实战

  * 断言字段录入

  ```
  [{"name":"响应码","action":"EQUAL","from":"RESPONSE_CODE","value":"200"}]
  
  
  [{"name":"响应码","action":"EQUAL","from":"RESPONSE_CODE","value":"200"},{"name":"响应头","action":"CONTAIN","from":"RESPONSE_HEADER","value":"cookies"}]
  ```

  * 用例sql录入

  ```
  INSERT INTO `test_engine`.`stress_case` (`id`, `project_id`, `module_id`, `environment_id`, `name`, `description`, `assertion`, `relation`, `stress_source_type`, `thread_group_config`, `jmx_url`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (6, 1, 1, 1, 'SIMPLE用例Get-响应码断言-查询', NULL, '[{\"name\":\"响应码\",\"action\":\"EQUAL\",\"from\":\"RESPONSE_CODE\",\"value\":\"200\"},{\"name\":\"响应头\",\"action\":\"CONTAIN\",\"from\":\"RESPONSE_HEADER\",\"value\":\"cookies\"}]', NULL, 'SIMPLE', '{\"threadGroupName\":\"测试\",\"numThreads\":\"2\",\"rampUp\":\"1\",\"loopCount\":\"2\",\"schedulerEnabled\":false,\"duration\":0,\"delay\":0}', NULL, '/api/v1/test/query', 'GET', '[{\"key\":\"id\",\"value\":2},{\"key\":\"age\",\"value\":99}]', '[{\"key\":\"token\",\"value\":\"66666\"},{\"key\":\"name\",\"value\":\"jack\"}]', NULL, NULL, '2024-01-15 02:31:54', '2024-01-15 02:37:35');
  ```

  

<img src="img/image-20240114141138381.png" alt="image-20240114141138381" style="zoom:30%;" />

















#### 第5集 在线生成压测脚本之可变参数开发实战

**简介：  在线生成压测脚本之可变参数开发实战**

* 需求

  - 业务开发里面参数一般不是固定方式，单参数可能走缓存则影响性能，所以会采用可变参数进行压测
  - 比如压测商品详情，查看id从1~100 的商品详情
  - 逻辑和JMX压测案例类似，使用java代码在线配置可变参数案例

* 编码实战

  ```
  
      private List<CSVDataSet> createCSVDataSet() {
          if (StringUtils.isBlank(stressCaseDO.getRelation())) {
              return null;
          }
          FileService fileService = applicationContext.getBean(FileService.class);
  
          // 将关系转为CSVDataFileDTO对象的列表
          List<CSVDataFileDTO> csvDataFileDTOS = JsonUtil.json2List(stressCaseDO.getRelation(), CSVDataFileDTO.class);
  
          // 定义CSV data set的列表，CSVDataSet坑，不能直接操作属性名，比如，csvDataSet.setFilename("xxxxx"); 不然不生效
          List<CSVDataSet> csvDataSetList = new ArrayList<>();
          for (CSVDataFileDTO csvDataFileDTO : csvDataFileDTOS) {
              // 创建CSVDataSet并设置属性
              CSVDataSet csvDataSet = new CSVDataSet();
              csvDataSet.setName(csvDataFileDTO.getName());
              csvDataSet.setEnabled(true);
              csvDataSet.setProperty("fileEncoding", "UTF-8");
              csvDataSet.setProperty(TestElement.GUI_CLASS, TestBeanGUI.class.getName());
              csvDataSet.setProperty(TestElement.TEST_CLASS, CSVDataSet.class.getName());
              // 设置分隔符
              csvDataSet.setProperty("delimiter", csvDataFileDTO.getDelimiter());
              // 设置是否引用数据
              csvDataSet.setProperty("quotedData", false);
              // 设置共享模式
              csvDataSet.setProperty("shareMode", "shareMode.all");
              // 设置是否停止线程
              csvDataSet.setProperty("stopThread", false);
              // 设置CSV文件路径
              String localTempFilePath = fileService.copyRemoteFileToLocalTempFile(csvDataFileDTO.getRemoteFilePath());
  
              csvDataSet.setProperty("filename", localTempFilePath);
              // 设置是否忽略第一行
              csvDataSet.setProperty("ignoreFirstLine", csvDataFileDTO.getIgnoreFirstLine());
              // 设置是否循环读取数据
              csvDataSet.setProperty("recycle", csvDataFileDTO.getRecycle());
              // 设置变量名
              csvDataSet.setProperty("variableNames", csvDataFileDTO.getVariableNames());
              csvDataSetList.add(csvDataSet);
          }
          return csvDataSetList;
      }
  ```

  









#### 第6集 在线生成压测脚本之可变参数链路测试实战

**简介：  在线生成压测脚本之可变参数链路测试实战**

* 需求
  * 配置可变参数测试用例，进行测试实战

* 链路测试实战

  * relation

  ```
  [{"sourceType":"csv","delimiter":",","ignoreFirstLine":false,"recycle":true,"variableNames":"id","remoteFilePath":"http://120.79.56.211:9000/bucket/id.csv","name":"商品id集合"}]
  ```

  * 用例录入

  ```
  INSERT INTO `test_engine`.`stress_case` (`id`, `project_id`, `module_id`, `environment_id`, `name`, `description`, `assertion`, `relation`, `stress_source_type`, `thread_group_config`, `jmx_url`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (7, 1, 1, 1, 'SIMPLE用例Get查询-参数化', NULL, NULL, '[{\"sourceType\":\"csv\",\"delimiter\":\",\",\"ignoreFirstLine\":false,\"recycle\":true,\"variableNames\":\"id\",\"remoteFilePath\":\"http://120.79.56.211:9000/bucket/id.csv\",\"name\":\"商品id集合\"}]', 'SIMPLE', '{\"threadGroupName\":\"测试\",\"numThreads\":\"5\",\"rampUp\":\"1\",\"loopCount\":\"2\",\"schedulerEnabled\":false,\"duration\":0,\"delay\":0}', NULL, '/api/v1/test/query', 'GET', '[{\"key\":\"id\",\"value\":\"${id}\"},{\"key\":\"age\",\"value\":99}]', '[{\"key\":\"token\",\"value\":\"66666\"},{\"key\":\"name\",\"value\":\"jack\"}]', NULL, NULL, '2024-01-15 03:29:56', '2024-01-15 03:36:46');
  ```

  

<img src="img/image-20240114141721397.png" alt="image-20240114141721397" style="zoom:30%;" />









![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第十六章 在线生成压测脚本异步压测实战和多用例综合测试



#### 第1集 压测用例执行超时问题分析和异步方案

**简介：  压测用例执行超时问题分析和异步方案**

* 问题分析

  * 压测用例执行中，前端需要一直等待压测结束才可以响应用户，

  * 如果压测样本请求数1千内则很快执行完成，但是如果是1千以上则容易产生比较多的超时问题

    ![image-20240114142427138](img/image-20240114142427138.png)

* 解决方案

  * 为了提升系统性能，异步处理是不可或缺的
  * 为了实现异步处理，通常有多种方法可供选择，包括线程、线程池、定时任务和回调函数等
  * 在这些方法中，线程和线程池是最常用的手段，但这可能会带来一定的复杂性

  <img src="img/image-20240114142403536.png" alt="image-20240114142403536" style="zoom:50%;" />

  * SpringBoot异步请求配置

    * 在springboot的启动类上面加上@EnableAsync注解

    * 在需要处理异步请求的控制器类中，创建一个异步方法，使用`@Async`注解为异步方法, 无返回值调用

    * 如果需要有返回值则用Future调用

    * 当调用标记有异步方法的注解接口时，将会触发异步方法的执行

    * 注意

      * @Async 失效的几个原因：
        * 注解 @Async 的方法不是 public 方法；
        * 注解 @Async 的返回值只能为 void 或 Future；
        * 注解 @Async 方法使用 static 修饰也会失效；
        * 启动类没加 @EnableAsync 注解；
        * 调用方和 @Async 不能在一个类中；
        * 在 Async 方法上标注 @Transactional 是不行的，但在 Async 方法调用的方法上标注 @Transcational 是有效的；

      

* 开发实战
  * 增加启动类允许异步注解  `@EnableAsync`
  * 增加异步方法注解 `@Async`

















#### 第2集 【重点】新版SpringBoot3.X异步任务自定义线程池

**简介：  新版SpringBoot3.X异步方法自定义线程池实战**

* 异步任务的线程池问题 

  * 直接使用 @Async 会有风险，默认使用线程池是Spring 自带的 SimpleAsyncTaskExecutor 线程池

  * 会不断的创建线程，当并发大的时候会严重影响性能，可以修改默认线程池策略或者使用自定义线程池

* 解决方案就是使用自定义线程池

  ```
  @Configuration
  @EnableAsync
  public class CustomTestAsyncConfiguration {
  
      @Bean("testExecutor")
      public Executor stressTestExecutor() {
          ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
          // 设置线程池的核心线程数：线程池创建时候初始化的线程数
          executor.setCorePoolSize(10);
          // 设置线程池的最大线程数：线程池最大的线程数，只有在缓冲队列满了之后才会申请超过核心线程数的线程
          executor.setMaxPoolSize(20);
          // 缓冲队列：用来缓冲执行任务的队列
          executor.setQueueCapacity(500);
          // 设置线程池中除了核心线程之外的线程的最长存活时间, 允许线程的空闲时间60秒：当超过了空闲时间到达之后会被销毁
          executor.setKeepAliveSeconds(60);
          // 设置线程池中所有线程的名字前缀：设置好了之后可以方便定位处理任务所在的线程池
          executor.setThreadNamePrefix("xdclass-test-");
          // 缓冲队列满了之后的拒绝策略：由调用线程处理（一般是主线程）
          executor.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());
          executor.initialize();
          return executor;
      }
      
  }
  
  //指定bean线程池名称
  @Async("testExecutor")
  ```

* 总结【方便记忆】

  - **先是CorePoolSize是否满足，然后是Queue阻塞队列是否满，最后才是MaxPoolSize是否满足**

* 面试题

  * 请你说下 ThreadPoolTaskExecutor线程池 有哪几个重要参数，什么时候会创建线程
    * 查看核心线程池是否已满，不满就创建一条线程执行任务，否则执行第二步。
    * 查看阻塞队列是否已满，不满就将任务存储在阻塞队列中，否则执行第三步。
    * 查看线程池是否已满，即是否达到最大线程池数，不满就创建一条线程执行任务，否则就按照策略处理无法执行的任务。

  - 高并发下核心线程怎么设置？（**架构大课有底层原理和实操分析**）
    - 分IO密集还是CPU密集
      - CPU密集设置为跟核心数一样大小
      - IO密集型设置为2倍CPU核心数
    - 非固定，根据实际情况压测进行调整，俗称【调参程序员】【调参算法工程师】

   

* 配置实战

![image-20240114145315740](img/image-20240114145315740.png)













#### 第3集 在线生成压测计划全链路多用例测试实战

**简介：  在线生成压测计划全链路多用例测试实战**

* 需求
  * 滴云自动化测试平台压测引擎JMX和SIMPLE类型引擎基本开发完成
  * SIMPLE类型压测引擎需要进行多用例测试
    * get方法提交+请求头+断言+参数化
    * post方法提交+请求头+断言+参数化
      * json方式
      * 表单方式

* 链路测试实战

  * 用例录入

  ```
  INSERT INTO `test_engine`.`stress_case` (`id`, `project_id`, `module_id`, `environment_id`, `name`, `description`, `assertion`, `relation`, `stress_source_type`, `thread_group_config`, `jmx_url`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (8, 1, 1, 1, 'SIMPLE用例Get查询-综合', NULL, '[{\"name\":\"响应码\",\"action\":\"EQUAL\",\"from\":\"RESPONSE_CODE\",\"value\":\"200\"}]', '[{\"sourceType\":\"csv\",\"delimiter\":\",\",\"ignoreFirstLine\":false,\"recycle\":true,\"variableNames\":\"id\",\"remoteFilePath\":\"http://120.79.56.211:9000/bucket/id.csv\",\"name\":\"商品id集合\"}]', 'SIMPLE', '{\"threadGroupName\":\"测试\",\"numThreads\":\"10\",\"rampUp\":\"1\",\"loopCount\":\"10\",\"schedulerEnabled\":false,\"duration\":0,\"delay\":0}', NULL, '/api/v1/test/query', 'GET', '[{\"key\":\"id\",\"value\":\"${id}\"},{\"key\":\"age\",\"value\":667788}]', '[{\"key\":\"token\",\"value\":\"66666\"},{\"key\":\"name\",\"value\":\"jack\"}]', NULL, NULL, '2024-01-15 06:44:23', '2024-01-15 06:45:23');
  INSERT INTO `test_engine`.`stress_case` (`id`, `project_id`, `module_id`, `environment_id`, `name`, `description`, `assertion`, `relation`, `stress_source_type`, `thread_group_config`, `jmx_url`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (9, 1, 1, 1, 'SIMPLE用例post-综合', NULL, '[{\"name\":\"响应码\",\"action\":\"EQUAL\",\"from\":\"RESPONSE_CODE\",\"value\":\"200\"}]', '[{\"sourceType\":\"csv\",\"delimiter\":\",\",\"ignoreFirstLine\":false,\"recycle\":true,\"variableNames\":\"id\",\"remoteFilePath\":\"http://120.79.56.211:9000/bucket/id.csv\",\"name\":\"商品id集合\"}]', 'SIMPLE', '{\"threadGroupName\":\"测试\",\"numThreads\":\"10\",\"rampUp\":\"1\",\"loopCount\":\"10\",\"schedulerEnabled\":false,\"duration\":0,\"delay\":0}', NULL, '/api/v1/test/login_form', 'POST', NULL, '[{\"key\":\"token\",\"value\":\"66666\"},{\"key\":\"name\",\"value\":\"jack\"},{\"key\":\"Content-Type\",\"value\":\"application/x-www-form-urlencoded\"}]', 'mail=7892323@qq.com&pwd=${id}', NULL, '2024-01-15 06:47:06', '2024-01-15 06:50:49');
  INSERT INTO `test_engine`.`stress_case` (`id`, `project_id`, `module_id`, `environment_id`, `name`, `description`, `assertion`, `relation`, `stress_source_type`, `thread_group_config`, `jmx_url`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (10, 1, 1, 1, 'SIMPLE用例post-综合-json', NULL, '[{\"name\":\"响应码\",\"action\":\"EQUAL\",\"from\":\"RESPONSE_CODE\",\"value\":\"200\"}]', '[{\"sourceType\":\"csv\",\"delimiter\":\",\",\"ignoreFirstLine\":false,\"recycle\":true,\"variableNames\":\"id\",\"remoteFilePath\":\"http://120.79.56.211:9000/bucket/id.csv\",\"name\":\"商品id集合\"}]', 'SIMPLE', '{\"threadGroupName\":\"测试\",\"numThreads\":\"10\",\"rampUp\":\"1\",\"loopCount\":\"10\",\"schedulerEnabled\":false,\"duration\":0,\"delay\":0}', NULL, '/api/v1/test/pay_json', 'POST', NULL, '[{\"key\":\"token\",\"value\":\"66666\"},{\"key\":\"name\",\"value\":\"jack\"},{\"key\":\"Content-Type\",\"value\":\"application/json\"}]', '{\"id\":\"${id}\",\"amount\":8899}', NULL, '2024-01-15 06:51:52', '2024-01-15 06:53:08');
  ```

  * get方式测试用例参数录入

  * post方式测试用例参数录入

    

















#### 第4集 滴云自动化测试平台-压测引擎模块开发总结

**简介：  滴云自动化测试平台-压测引擎模块开发总结**

* 大家此刻的心情应该如下，TM终于把压测引擎开发好了

<img src="img/image-20240114150848929.png" alt="image-20240114150848929" style="zoom:30%;" />

* 知识点总结规划
  * 从压测平台需求分析，到数据库表设计，到技术框架选择，到项目搭建
  * 封装基础工具类，AI大模型辅助编码 效率提升，基础模块CURD快速开发
  * JMX类型引擎开发，模版方法设计模式应用，自定义压测结果收集器
  * 分布式文件存储开发，新版Kafka-Kraft搭建和实战
  * SIMPLE类型压测引擎开发，异步任务+自定义线程池配置
  * 还有很多可以做的...**作为作业等待大家的探索设计，开源社区方向**
    * 整体代码逻辑优化和bug修复
    * 压测断言字段和规则支持多类型
    * 压测参数化支持多数据源
    * 压测报告传输组件和持久化数据源支持多类型
    * 压测采样器支持多协议类型
    * ...

<img src="img/image-20240114151833002.png" alt="image-20240114151833002" style="zoom:50%;" />













![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第十七章 云测平台-接口自动化测试需求和功能初体验



#### 第1集 接口自动化测试需求说明和功能初体验

**简介：  接口自动化测试需求说明和功能初体验**

* 接口自动化测试介绍

  * 一种通过编写脚本或使用自动化工具，主要用于验证系统组件之间的通信和数据交换是否正常
  * 通过自动化测试可以快速发现接口中的问题，及时进行修复，确保系统的稳定性和可靠性
  * **互联网公司接口自动化测试的常见工具包括Jmeter、Postman、SoapUI、TestNG、HttpRunner等**

* 常规进行接口自动化测试的步骤

  * 编写测试用例
    * 根据接口的需求和功能，编写相应的测试用例，**包括正常、边界和异常等各种情况下的测试**
  * 准备测试数据
    * 根据测试用例的要求，准备相应的测试数据，可以通过手动输入、数据库查询、文件导入等方式进行准备。
  * 搭建测试环境
    * 搭建适合接口自动化测试的测试环境，包括测试服务器、数据库、接口调用工具等。
  * 编写测试脚本
    * 使用适合的编程语言和工具，编写接口自动化测试脚本，**包括发送接口请求、接收和解析接口响应、校验接口结果等步骤**
  * 执行测试脚本
    * 执行编写好的测试脚本，发送接口请求，并对接口的响应结果进行校验。记录测试结果和日志。
  * 分析测试结果
    * 根据测试脚本的执行结果和日志，分析接口的测试结果。如果有失败的测试用例，需要进行排查和修复。
  * 定期执行测试
    * **根据项目需求，定期执行接口自动化测试，保证接口的稳定性和功能的正确性**
  * 生成测试报告
    * 根据测试结果，生成测试报告。报告应包括测试的概述、测试用例的执行情况、错误日志和建议等。
  * 维护和优化
    * 根据接口的变更和项目需求，及时维护和优化接口自动化测试脚本，保持测试的准确性和可靠性。

* 云测平台需要解决的接口自动化测试需求

  * **开发和测试团队质量交付比较差**
    - 每次需要本地安装一系列环境和驱动，且兼容性也差，测试和开发人员工作效率低
    - 维护多个测试工具，**每次测试都需要重新部署环境、容易丢失，自动化测试脚本分散，版本不一致、维护性差**
  * **本地测试、手工测试和自动化测试脚本不通用**
    - 不同的测试类型需要使用不同的测试工具和技术，**老王用了Postman，冰冰用了Jmeter，湧哥自己写脚本**
    - 导致测试人员需要学习和掌握多种测试方法和工具，增加了测试成本和学习成本。
  *  **测试报告分散不统一**
    - 在测试过程中，测试人员需要记录和整理测试结果，通常使用Excel等工具进行管理。
    - 不同测试人员使用的格式和内容可能不一致，导致测试报告分散不统一，难以汇总和分析。
  * **重复性工作过多**
    - 测试过程中需要进行很多重复性的工作，如数据准备、环境配置、脚本执行等
    - 这些工作需要消耗大量的时间和精力，影响测试效率。
  * **难以发现潜在的问题**
    - 手动测试存在局限性，无法覆盖所有的测试场景和用例，难以发现潜在的问题。
    - 测试脚本分散，没统一维护，测试报告历史查看不了，没有给团队沉淀积累经验

  ![image-20240120111603551](img/image-20240120111603551.png)

* 滴云自动化测试平台-**接口自动化测试功能初体验**
  * 接口管理
  * 用例管理
  * 多接口编排自动化测试
  * 接口测试报告查看

![image-20240125153746901](img/image-20240125153746901.png)















#### 第2集 云测平台-接口自动化测试数据库表设计

**简介：  云测平台-接口自动化测试数据库表设计**

* 需求

  * 基于云测平台-接口自动化的产品界面，设计相关的数据库表
  * 接口模块管理、接口管理、用例模块管理、用例管理、多接口场景编排相关设计

  ![image-20240120102839415](img/image-20240120102839415.png)

* 数据库表关系和设计说明

  * ER图概述

  ![image-20240120104234013](img/image-20240120104234013.png)

  * 下载资料 ，使用**【wget】或者【浏览器】远程下载相关依赖包（需要替换群里最新的）**

    ```
    原生资料下载方式(账号 - 密码 - ip地址 - 端口 需要替换群里最新的，其他路径不变)
    wget --http-user=用户名 --http-password=密码 http://ip:端口/dcloud_test/dcloud_api_sql.zip
    
    #比如 命令行下
    wget --http-user=admin --http-password=xdclass.net888 http://47.115.31.28:9088/dcloud_test/dcloud_api_sql.zip
    
    # 比如 浏览器直接访问
    http://47.115.31.28:9088/dcloud_test/dcloud_api_sql.zip
    ```

    

  * 数据库表说明

    * 接口模块管理

    * 接口管理

    

    















#### 第3集 【重点】多接口编排自动化测试数据库表设计

**简介：  多接口编排自动化测试数据库表设计**

* 需求

  * 接口自动化测试，一般不止单独测试某个接口，一个功能可能涉及多个接口
    * 比如下单功能：需要查询商品、登录、加入购物车、创建订单 多个接口关联编排起来
  * 其中也涉及到不同接口之间的参数传递
    * 比如 加入购物车接口，依赖登录接口的token

  ![image-20240120103031053](img/image-20240120103031053.png)

* 数据库表说明

  * 用例模块

  * 接口测试用例

  * 用例步骤管理

  

  











#### 第4集 【重点】多接口编排数据库表特殊字段存储架构

**简介：  【重点】多接口编排数据库表特殊字段存储架构**

* 需求

  * 多接口编排测试，涉及不同的规则，比如接口上下文提取、跨接口参数传递、断言字段源和规则等，需要设计好字段和存储明细
  * 参考压测引擎设计，特殊字段采用JSON字符串存储，并且复用相关代码，统一规范

  ![image-20240120114215066](img/image-20240120114215066.png)

  <img src="img/image-20240120114420494.png" alt="image-20240120114420494" style="zoom:50%;" />

* 特别字段和存储说明如下

  * API表

    * query、header、body 统一JSON数组存储，例如下面格式

    ```
    [{"key":"mail","value":"xdclass"},{"key":"pwd","value":"123456"}]
    ```

  * api_case_step表

    * query、header、body 统一JSON数组存储，例如下面格式

    ```
    [{"key":"mail","value":"xdclass"},{"key":"pwd","value":"123456"}]
    ```

    * assertion字段

    ```
    [{"from":"RESPONSE_DATA","type":"JSONPATH","action":"EQUAL","express":"$.success","value":"true"}]
    ```

    * relation（**指当前步骤，需要提取对应的参数，放到容器里面供其他地方使用，和压测引擎不一样**）

    ```
    [{"from":"RESPONSE_DATA","type":"JSONPATH","express":"$.data","name":"token"}]
    ```

    * 模版参数 字段，当前接口需要依赖其他接口存储的参数，则采用 `{{ XXX }}` 进行获取，例如下面格式

    ```
    //会从容器里面寻找 token 变量，替换到当前这个
    [{"key":"Content-Type","value":"application/json"},{"key":"token","value":"{{token}}"}]
    ```

    ![image-20240120114320931](img/image-20240120114320931.png)











#### 第5集 云测平台接口自动化测试-模拟接口开发

**简介：  云测平台接口自动化测试-模拟接口开发**

* 需求
  * 由于需要进行接口自动化测试，需要准备几个待测接口用于测试
  * 支持 GET请求，POST请求(JSON和表单提交，文件上传)，多接口直接参数关联
  * 先开发部分接口，后续不满足则进行修改

* 备注：**接口自动化测试中，公司里面常见问题**

  - 公司里面 多数都是前后端分离，项目启动后，开发人员应该先定义接口文档，测试人员应该尽早拿到接口文档进行编写测试用例

  - 没文档怎么办？

    - 老旧系统：找你上司或者接手的开发人员进行获取；实在没法就只能抓包
      - 如果是后端直接返回页面+数据，一次性渲染好，则没法做接口测试
      - app的话，通过客户端app抓包
    - 如果里面参数涉及复杂的加密逻辑且开发人员不能协助，这个就基本没戏了

    - 新系统：找开发人员先定义接口，按照流程规范走，找技术负责人协调

* 模拟接口编码实战

  ```
      private static Set<String> TOKNE_SET = new HashSet<>();
  
      @GetMapping("/api/v2/test/detail")
      @ResponseBody
      public JsonData detail(Long id) {
          return JsonData.buildSuccess("传入id=" + id);
      }
  
      /**
       * form表单登录，生成令牌
       *
       * @param mail
       * @param pwd
       * @return
       */
      @PostMapping("/api/v2/test/login_form")
      @ResponseBody
      public JsonData loginApi(String mail, String pwd) {
  
          if ("xdclass".equals(mail) && "123456".equals(pwd)) {
              String token = IdUtil.simpleUUID();
              TOKNE_SET.add(token);
              return JsonData.buildSuccess(token);
          }
          return JsonData.buildError("登录失败，账号密码错误");
      }
  
  
      /**
       * 模拟下单，需要登录token，然后增加订单号
       *
       * @param map
       * @param request
       * @return
       */
      @PostMapping("/api/v2/test/buy")
      @ResponseBody
      public JsonData buy(@RequestBody Map<String, String> map, HttpServletRequest request) {
          String token = request.getHeader("token");
          if (TOKNE_SET.contains(token)) {
              map.put("order_id", IdUtil.simpleUUID());
              return JsonData.buildSuccess(map);
          } else {
              return JsonData.buildError("请登录，再下单");
          }
      }
  
  
      /**
       * 模拟文件上传
       *
       * @param file
       * @return
       */
      @PostMapping("/api/v2/test/upload")
      @ResponseBody
      public JsonData upload(@RequestParam("file") MultipartFile file) {
          if (file != null) {
              String originalFilename = file.getOriginalFilename();
              String contentType = file.getContentType();
              Map<String, String> map = new HashMap<>();
              map.put("originalFilename", originalFilename);
              map.put("contentType", contentType);
              return JsonData.buildSuccess(map);
          } else {
              return JsonData.buildError("上传文件失败,文件为空");
          }
      }
  ```

  













![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第十八章 云测平台-接口自动化测试引擎开发实战



#### 第1集 接口测试引擎逆向工程配置和枚举配置

**简介：  接口测试引擎逆向工程配置和枚举配置战**

* 需求
  * 基于接口自动化测试引擎设计的数据表，生成相关实体类
  * 新增接口自动化配置相关枚举类说明

* 开发实战

  * 逆向工程配置

  ```
    String[] tables = {
                  "api", "api_case",
                  "api_case_module", "api_case_step","api_module"
          };
  ```

  * 接口自动化测试相关枚举类新增

  ```
  public enum ApiRelateTypeEnum {
  
      /***
       * 正则
       */
      REGEXP,
      /**
       * jsonpath规则
       */
      JSONPATH
  }
  
  /**
   * API关联字段来源
   */
  public enum ApiRelateFieldFromEnum {
          /**
           * 请求头
           */
          REQUEST_HEADER,
          /**
           * 请求体
           */
          REQUEST_BODY,
          /**
           * 请求查询参数
           */
          REQUEST_QUERY,
          /**
           * 响应头
           */
          RESPONSE_HEADER,
          /**
           * 响应体
           */
          RESPONSE_DATA;
  
  }
  
  
  public enum ApiBodyTypeEnum {
  
      /**
       * 表单提交
       */
      FORM_DATA,
      /**
       * 表单提交
       */
      X_WWW_FORM_URLENCODED,
      /**
       * JSON提交
       */
      JSON,
      /**
       * TEXT提交
       */
      TEXT,
      /**
       * 二进制提交，比如file
       */
      BINARY;
  }
  
  
  /**
   * 断言类型
   */
  public enum ApiAssertTypeEnum {
      /**
       * 正则
       */
      REGEXP,
      /**
       * jsonpath
       */
      JSONPATH
  }
  
  
  public enum ApiAssertFieldFromEnum {
      /**
       * 响应码
       */
      RESPONSE_CODE,
  
      /**
       * 响应头
       */
      RESPONSE_HEADER,
  
      /**
       * 响应体
       */
      RESPONSE_DATA;
  
  }
  
  public enum ApiAssertActionEnum {
      /**
       * 包含
       */
      CONTAIN,
      /**
       * 不包含
       */
      NOT_CONTAIN,
      /**
       * 等于
       */
      EQUAL,
      /**
       * 不等于
       */
      NOT_EQUAL,
      /**
       * 大于
       */
      GREAT_THEN,
      /**
       * 小于
       */
      LESS_THEN;
  }
  ```

  







#### 第2集 接口自动化测试引擎-接口模块开发实战

**简介：  接口自动化测试引擎-接口模块管理开发实战**

* 需求
  * 开发接口自动化测试基础模块（**本集和后续的几集可以适当倍速播放，都是常规模块的CRUD**）

* 编码实战

  ```
  
      @GetMapping("/list")
      public JsonData getId(@RequestParam long projectId) {
          return JsonData.buildSuccess(apiModuleService.list(projectId));
      }
  
  
      @GetMapping("/find")
      public JsonData getId(@RequestParam("projectId") long projectId,@RequestParam("moduleId") long moduleId) {
          return JsonData.buildSuccess(apiModuleService.getById(projectId, moduleId));
      }
  
      @PostMapping("/save")
      public JsonData save(@RequestBody @Validated ApiModuleSaveReq apiModuleSaveReq) {
          return JsonData.buildSuccess(apiModuleService.save(apiModuleSaveReq));
      }
  
  
      @PostMapping("/update")
      public JsonData update(@RequestBody @Validated ApiModuleUpdateReq apiModuleUpdateReq) {
          return JsonData.buildSuccess(apiModuleService.update(apiModuleUpdateReq));
      }
  
      @PostMapping("/del")
      public JsonData deleteId(@RequestBody @Validated ApiModuleDelReq apiModuleDelReq) {
          return JsonData.buildSuccess(apiModuleService.delete(apiModuleDelReq.getId(), apiModuleDelReq.getProjectId()));
      }
  ```

  





#### 第3集 接口自动化测试引擎-接口管理开发实战

**简介：  接口自动化测试引擎-接口模块管理开发实战**

* 需求

  * 接口管理开发实战的基础模块

* 编码实战

  ```
      @GetMapping("/find")
      public JsonData getById(@RequestParam("projectId") long projectId,@RequestParam("id") long caseId) {
          return JsonData.buildSuccess(apiService.getById(projectId,caseId));
      }
  
      @Operation(summary = "保存")
      @PostMapping("/save")
      public JsonData save(@RequestBody @Validated ApiSaveReq apiSaveReq) {
          return JsonData.buildSuccess(apiService.save(apiSaveReq));
      }
  
      @Operation(summary = "修改")
      @PostMapping("/update")
      public JsonData update(@RequestBody @Validated ApiUpdateReq apiUpdateReq) {
          return JsonData.buildSuccess(apiService.update(apiUpdateReq));
      }
  
      @Operation(summary = "删除")
      @PostMapping("/del")
      public JsonData deleteId(@RequestBody @Validated ApiDelReq delReq) {
          return JsonData.buildSuccess(apiService.delete(delReq.getId(), delReq.getProjectId()));
      }
  ```

  



















#### 第4集 接口自动化测试引擎-用例模块管理开发实战

**简介：  接口自动化测试引擎-用例模块开发实战**

* 需求

  * 用例模块管理开发实战

* 编码实战

  ```
  
      @Operation(summary = "列表")
      @GetMapping("/list")
      public JsonData getId(@RequestParam("projectId") long projectId) {
          return JsonData.buildSuccess(apiCaseModuleService.list(projectId));
      }
  
  
      @Operation(summary = "获取")
      @GetMapping("/find")
      public JsonData getId(@RequestParam("projectId") long projectId,@RequestParam("moduleId") long moduleId) {
          return JsonData.buildSuccess(apiCaseModuleService.getById(projectId, moduleId));
      }
  
      @Operation(summary = "保存")
      @PostMapping("/save")
      public JsonData save(@RequestBody @Validated ApiCaseModuleSaveReq apiCaseModuleSaveReq) {
          return JsonData.buildSuccess(apiCaseModuleService.save(apiCaseModuleSaveReq));
      }
  
      @Operation(summary = "修改")
      @PostMapping("/update")
      public JsonData update(@RequestBody @Validated ApiCaseModuleUpdateReq apiCaseModuleUpdateReq) {
          return JsonData.buildSuccess(apiCaseModuleService.update(apiCaseModuleUpdateReq));
      }
  
      @Operation(summary = "删除")
      @PostMapping("/del")
      public JsonData deleteId(@RequestBody @Validated ApiCaseModuleDelReq apiCaseModuleDelReq) {
          return JsonData.buildSuccess(apiCaseModuleService.delete(apiCaseModuleDelReq.getId(), apiCaseModuleDelReq.getProjectId()));
      }
  ```

  













#### 第5集 接口自动化测试引擎-用例管理开发实战

**简介：  接口自动化测试引擎-用例管理开发实战**

* 需求

  * 用例管理开发实战

* 编码实战

  ```
  
      @Operation(summary = "获取")
      @GetMapping("/find")
      public JsonData getId(@Validated ApiCaseFindReq apiCaseFindReq) {
          return JsonData.buildSuccess(apiCaseService.getById(apiCaseFindReq.getId(), apiCaseFindReq.getProjectId()));
      }
  
      @Operation(summary = "保存")
      @PostMapping("/save")
      public JsonData save(@RequestBody @Validated ApiCaseSaveReq apiCaseSaveReq) {
          return JsonData.buildSuccess(apiCaseService.save(apiCaseSaveReq));
      }
  
      @Operation(summary = "更新")
      @PostMapping("/update")
      public JsonData update(@RequestBody @Validated ApiCaseUpdateReq apiCaseUpdateReq) {
          return JsonData.buildSuccess(apiCaseService.update(apiCaseUpdateReq));
      }
  
      @Operation(summary = "删除")
      @PostMapping("/del")
      public JsonData deleteId(@RequestBody @Validated ApiCaseDelReq apiCaseDelReq) {
          return JsonData.buildSuccess(apiCaseService.delete(apiCaseDelReq.getId(), apiCaseDelReq.getProjectId()));
      }
  ```

  













#### 第6集 接口自动化测试引擎-用例步骤管理开发实战

**简介：  接口自动化测试引擎-用例管理开发实战**

* 需求

  * 用例步骤管理开发实战

* 编码实战

  ```
  
      @Operation(summary = "保存")
      @PostMapping("/save")
      public JsonData save(@RequestBody @Validated ApiCaseStepSaveReq apiCaseStepSaveReq) {
          return JsonData.buildSuccess(apiCaseStepService.save(apiCaseStepSaveReq));
      }
  
      @Operation(summary = "修改")
      @PostMapping("/update")
      public JsonData update(@RequestBody @Validated ApiCaseStepUpdateReq apiCaseStepUpdateReq) {
          return JsonData.buildSuccess(apiCaseStepService.update(apiCaseStepUpdateReq));
      }
  
      @Operation(summary = "删除")
      @PostMapping("/del")
      public JsonData deleteId(@RequestBody @Validated ApiCaseStepDelReq apiCaseStepDelReq) {
          return JsonData.buildSuccess(apiCaseStepService.delete(apiCaseStepDelReq.getId(), apiCaseStepDelReq.getProjectId()));
      }
  ```

  











![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第十九章 接口测试框架Restassured和JSONPath实战



#### 第1集 接口测试框架Restassured介绍

**简介：  接口测试框架Restassured介绍**

* 市场上的主流的接口测试框架

  * Postman：提供了类似RestAssured的功能，包括请求发送、断言和响应处理等。
  * Apache HttpClient：一个用于发送HTTP请求的Java库，提供了更底层的控制和定制化。
  * JUnit：虽然JUnit主要用于单元测试，但它可以与RestAssured等库集成，用于编写针对API接口的集成测试。
  * MockMvc：是Spring框架下的一个模拟框架，用于模拟Web请求和响应

* 云测平台采用的接口测试框架【Restassured】

  * 一个基于Java的轻量级接口测试框架，主要用于简化基于HTTP协议的接口测试，简单易用、功能强大、可扩展性好
  * 官网：http://rest-assured.io
  * 优点
    * 简单易用，RestAssured提供了简单易用的API，可以轻松地编写测试代码。
    * 功能强大，**支持多种请求方法、断言和验证响应内容、状态码、响应时间等特性**
    * 可扩展性好，RestAssured可以与TestNG、JUnit等测试框架完美集成。
    * 支持多种数据格式处理，RestAssured可以处理JSON和XML格式的数据
    * 支持结构化解析和多种解析方式，**支持xpath/jsonpath/gpath等解析方式**
    * 对Spring的支持比较全面，方便使用Spring框架的开发者
  * 缺点
    * 依赖性强：RestAssured依赖于Java和HTTP协议，对于非Java或非HTTP协议的接口可能不太适用。
    * 需要配置测试环境：在使用RestAssured进行接口自动化测试之前，需要搭建相应的测试环境，包括服务器、数据库等。
    * 非0基础上手：虽然RestAssured提供了简单易用的API，但对于初学者来说，仍然需要一定的学习成本才能掌握。

* SpringBoot3.X整合

  * 依赖增加

  ```
   				<dependency>
              <groupId>io.rest-assured</groupId>
              <artifactId>rest-assured</artifactId>
          </dependency>
  
          <dependency>
              <groupId>io.rest-assured</groupId>
              <artifactId>rest-assured-all</artifactId>
          </dependency>
  
          <dependency>
              <groupId>io.rest-assured</groupId>
              <artifactId>spring-web-test-client</artifactId>
          </dependency>
  ```

  * 快速开始（**初步体验，下集详细说语法**）
    * given：设置测试预设，包括请求头、请求参数、请求体、cookie等
    * when：所要执行的操作，配置发起请求的网址（GET / POST 请求）
    * then：解析结果、断言

  ```
  @SpringBootTest
  public class AssuredTest {
  
      @Test
      public void testBase() {
          RestAssured.given()
                  .param("id", 1)
                  .when()
                  .get("http://127.0.0.1:8082/api/v2/test/detail")
                  .then()
                  .log()
                  .all()
                  .statusCode(200);
      }
  
  }
  ```

  



















#### 第2集 Restassured框架常用方法最佳实践《上》

**简介：  Restassured框架常用方法最佳实践《上》**

* 需求

  * 掌握Restassured常用的最佳实践和API案例

  * 基础语法格式
    * RestAssured的语法采用简洁的链式调用方式
    * 以“given()”开始，设置测试预设，包括请求头、请求参数、请求体、cookie等；
    * 然后使用“when()”指定请求的URL（GET、POST等请求）；
    * 最后使用“then()”进行断言和解析响应结果
  * 参数配置
    * 请求头参数：使用“header()”方法设置请求头信息，例如“header("Content-Type", "application/json")”。
    * 请求参数
      * 对于GET请求，使用“param()”方法设置URL参数，例如“param("key", "value")”；
      * 对于POST请求，可以使用“body()”方法设置请求体内容
    * 文件上传
      * 提供multiPart() 的方法可以指定文件(file)、字节数组(byte-array)、输入流或者是上传文件

* 案例实战

  * GET
    * log()可以向控制台输出返回的信息
    * log().all() 可以返回所有响应中的数据

  ```
   @Test
      public void testBase() {
          RestAssured.given()
                  .queryParam("id", 1)
                  .when()
                  .get("http://127.0.0.1:8082/api/v2/test/detail")
                  .then()
                  .log().all()
                  .statusCode(200);
      }
  ```

  * POST方式form表单

  ```
    @Test
      public void testPostForm(){
          RestAssured.given()
                  .formParam("mail", "xdclass")
                  .formParam("pwd","123456")
                  .when()
                  .post("http://127.0.0.1:8082/api/v2/test/login_form")
                  .then()
                  .log().all()
                  .statusCode(200);
      }
  ```

  * POST方式json+header

  ```
   @Test
      public void testPostJsonHeader(){
          Map<String,String> params = new HashMap<>();
          params.put("title","云测平台大课");
          RestAssured.given()
                  .header("token","7a9b7dcbba2443c5a80fbfa62da63e69")
                  //.header("Content-Type","application/json")
                  .contentType(ContentType.JSON)
                  .body(JsonUtil.obj2Json(params))
                  .when()
                  .post("http://127.0.0.1:8082/api/v2/test/buy")
                  .then()
                  .log()
                  .all()
                  .statusCode(200);
      }
  ```

  * 文件上传

  ```
      @Test
      public void testFile(){
          RestAssured.given()
                  .multiPart(new File("/Users/xdclass/Desktop/测试jmx/id.csv"))
                  .when()
                  .post("http://127.0.0.1:8082/api/v2/test/upload")
                  .then()
                  .log().all()
                  .statusCode(200);
      }
  ```

  

















#### 第3集 Restassured框架常用方法最佳实践《下》

**简介：  Restassured框架常用方法最佳实践《下》**

* 需求

  * 响应断言

    * 使用“statusCode()”方法指定期望的响应状态码，例如“statusCode(200)”；
    * 还可以使用“body()”方法对响应内容进行断言，例如“body("key", equalTo("value"))”

    | 类型   | 断言方法     | 含义       |
    | ------ | ------------ | ---------- |
    | 状态码 | statusCode() | 响应状态码 |
    | 响应头 | header()     | 响应头信息 |
    | 内容   | body()       | 内容匹配   |

  * 内置结果解析

    * 自带GPath解析
      * 是来自groovy 编程语言的广泛使用的 XML 和 JSON 解析器 GPath可以处理html、xml、json
      * 跟JSONpath的区别就是不需要从$开始写了，GPATH直接从JSON消息的第一层数据开始
      * 通过 extract().response() 将响应结果保存到 Response 类型的变量，使用Gpath提取响应中的某一个具体的数据
        * 提取JSON：res.jsonPath().get(“XXX.XXX.XXX”);
        * 提取xml：res.xmlPath().get(“XXX.XXX.XXX”);
        * 提取HTML：res.htmlPath().get(“XXX.XXX.XXX”);
    * JSON解析
      * 支持对JSON格式的响应数据进行解析，可以使用“jsonPath()”方法指定JSON路径进行查询和断言。
    * XML解析
      * 支持对XML格式的响应数据进行解析，可以使用“xmlPath()”方法指定XML路径进行查询和断言。

* 案例实战

  * 断言测试

  ```
      @Test
      public void testAssert(){
          Map<String,String> params = new HashMap<>();
          params.put("title","云测平台大课");
          RestAssured.given()
                  .header("token","7a9b7dcbba2443c5a80fbfa62da63e69")
                  .header("Content-Type","application/json")
                  .body(JsonUtil.obj2Json(params))
                  .when()
                  .post("http://127.0.0.1:8082/api/v2/test/buy")
                  .then()
                  .log()
                  .all()
                  .statusCode(200)
                  .body("code", equalTo(1));
      }
  ```

  * 结果解析

  ```
      @Test
      public void testResponse(){
          Map<String,String> params = new HashMap<>();
          params.put("title","云测平台大课");
          Response response = RestAssured.given()
                  .header("token", "7a9b7dcbba2443c5a80fbfa62da63e69")
                  //.header("Content-Type","application/json")
                  .contentType(ContentType.JSON)
                  .body(JsonUtil.obj2Json(params))
                  .log().headers()//打印请求头
                  .log().body()//打印请求体
                  .when()
                  .post("http://127.0.0.1:8082/api/v2/test/buy")
                  .then()
                  .log()
                  .all()
                  .statusCode(200).extract().response();
  
          Object data = response.jsonPath().get("data");
          System.out.println(data);
      }
  ```

  

















#### 第4集 内容解析之JSONPath语法快速上手

**简介：  内容解析之JSONPath语法快速上手**

* 什么是JSONPath

  * 一种用于在JSON（JavaScript Object Notation）数据中定位和提取特定元素的查询语言
  * 类似于XPath对XML的作用，可以轻松地按照特定的路径表达式，从复杂的JSON结构中获取所需的数据
  * 路径可以是绝对路径或相对路径，从根节点开始，通过使用“.”来访问子节点。
  * 支持多种操作符，如比较操作符（==、!=）、逻辑操作符（&&、||）等，以便进行各种数据查询和处理。
  * 允许处理复杂的嵌套JSON结构，指定路径以访问深层嵌套的对象或数组，并可以使用迭代符号来处理多个层级的数据。
  * 由于JSONPath的通用性和易用性，许多开发工具和框架都支持JSONPath，如JaywayJsonPath等
  * 语法特点

  | JSONPath | 描述                             |
  | -------- | -------------------------------- |
  | $        | 根节点                           |
  | @        | 当前节点                         |
  | …        | 忽略位置，选择所有符合条件的元素 |
  | *        | 匹配所有元素节点                 |
  | .        | 取子节点                         |
  | []       | 取子节点，支持名称或者下标       |
  | [,]      | 支持迭代器中做多选               |
  | ?()      | 支持过滤操作                     |

* 案例实战

  * 网站：JSONPath在线解析
  * 数据准备

  ```
  {  
    "name": "小滴课堂-湧哥",  
    "age": 30,  
    "address": {  
      "street": "老王隔壁街道",  
      "city": "广州市",  
      "state": "TH",  
      "zip": "10001"  
    },  
    "phoneNumbers": ["123-456-7890", "987-654-3210"],  
    "hobbies": ["按摩", "喝酒", "写Bug"],  
    "isStudent": false,  
    "subjects": {  
      "math": 95,  
      "english": 80,  
      "science": 85  
    }  
  }
  ```

  * 案例操作
    * 获取name属性的值：`$.name`
    * 获取address对象中的city属性：`$.address.city`
    * 获取phoneNumbers数组中的第一个元素：`$.phoneNumbers[0]`
    * 获取hobbies数组中的所有元素：`$.hobbies[*]`
    * 获取subjects对象中math属性的值：`$.subjects.math`
    * 获取subjects对象中大于等于90的属性值：`$.subjects[?(@ >= 90)]`
    * 获取phoneNumbers数组中长度大于等于2的元素：`$.phoneNumbers[?(@.length >= 2)]`

  

  









#### 第5集 Restassured和JSONPath整合案例实战

**简介：  Restassured和JSONPath整合案例实战**

* 需求

  * SpringBoot3.X集成JSONPath解析
  * 整合Restassured接口测试框架响应结果利用JSONPath解析

* 编码实战

  * 添加依赖

  ```
     <dependency>
              <groupId>com.jayway.jsonpath</groupId>
              <artifactId>json-path</artifactId>
     </dependency>
  ```

  * 编码测试

  ```
   @Test
      public void testResponseJsonPath(){
          Map<String,String> params = new HashMap<>();
          params.put("title","云测平台大课");
          Response response = RestAssured.given()
                  .header("token", "b002db226fd74224a576e6525ef6854f")
                  //.header("Content-Type","application/json")
                  .contentType(ContentType.JSON)
                  .body(JsonUtil.obj2Json(params))
                  .log().headers()//打印请求头
                  .log().body()//打印请求体
                  .when()
                  .post("http://127.0.0.1:8082/api/v2/test/buy")
                  .then()
                  .log()
                  .all()
                  .statusCode(200).extract().response();
  
          String result = JsonPath.read(response.asString(), "$.data.order_id");
          System.out.println(result);
      }
  ```

  









![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第二十章 云测平台核心-接口测试引擎开发



#### 第1集 接口自动化测试用例执行链路解析和开发

**简介：接口自动化测试用例执行链路解析**

* 需求
  * 掌握接口自动化测试链路，包括多接口编排测试、断言、发送测试报告等
  * 开发接口自动化测试用例执行接口

* 架构链路图说明

  * 难点思考：**多接口编排如何做？**

  ![image-20240122110043183](img/image-20240122110043183.png)

* 执行用例接口开发

  ```
  @GetMapping("/execute")
      public JsonData executeId(@RequestParam("projectId")Long projectId,@RequestParam("id") Long caseId) {
          return JsonData.buildSuccess(apiCaseService.execute(caseId, projectId));
      }
      
      
   public JsonData execute(long id, long projectId) {
          LambdaQueryWrapper<ApiCaseDO> queryWrapper = new LambdaQueryWrapper<>();
          queryWrapper.eq(ApiCaseDO::getId, id).eq(ApiCaseDO::getProjectId, projectId);
  
          ApiCaseDO apiCaseDO = apiCaseMapper.selectOne(queryWrapper);
          if(apiCaseDO != null){
              // 获取API用例关联的API用例步骤列表
              List<ApiCaseStepDO> stepList = getApiCaseStepList(id);
              if (stepList == null || stepList.isEmpty()) {
                  throw new BizException(BizCodeEnum.API_CASE_STEP_IS_EMPTY);
              }
              // 执行
              CaseInfoDTO caseInfoDTO = new CaseInfoDTO();
              caseInfoDTO.setId(id);
              caseInfoDTO.setModuleId(apiCaseDO.getModuleId());
              caseInfoDTO.setName(apiCaseDO.getName());
              //生成测试报告
              ReportSaveReq reportSaveReq = ReportSaveReq.builder()
                      .projectId(apiCaseDO.getProjectId())
                      .caseId(apiCaseDO.getId())
                      .startTime(System.currentTimeMillis())
                      .executeState(ReportStateEnum.EXECUTING.name())
                      .name(apiCaseDO.getName()).type(TestTypeEnum.API.name()).build();
              JsonData jsonData = reportFeignService.saveReport(reportSaveReq);
  
              if(jsonData.isSuccess()) {
                  ReportDTO reportDTO = jsonData.getData(ReportDTO.class);
                  ApiExecuteEngine apiExecuteEngine = new ApiExecuteEngine(reportDTO);
                  ApiCaseResultDTO resultDTO = apiExecuteEngine.execute(caseInfoDTO, stepList);
                  return JsonData.buildSuccess(resultDTO);
              }else {
                  return JsonData.buildResult(BizCodeEnum.REPORT_SAVE_FAILED);
              }
          }else {
              return JsonData.buildError("用例不存在");
          }
      }
  ```

  











#### 第2集 用例测试结果对象和SpringContext工具类封装

**简介：用例测试结果对象和SpringContext对象工具类封装**

* 需求

  * 接口自动化测试用例结果属性封装
  * 接口测试引擎里面需要获取相关的Spring容器对象，封装工具类

* 编码实战

  * 测试用例结果封装

    ```
    @Data
    public class ApiCaseResultDTO {
    
        private Long reportId;
    
        private Boolean executeState;
    
        private Long startTime;
    
        private Long endTime;
    
        private Long expendTime;
    
        private Integer quantity;
    
        private Integer passQuantity;
    
        private Integer failQuantity;
    
        private List<ApiCaseResultItemDTO> list;
    }
    
    @Data
    public class ApiCaseResultItemDTO  {
    
        private Long reportId;
    
        private Boolean executeState;
    
        private Boolean assertionState;
    
        private String exceptionMsg;
    
        private Long expendTime;
    
    		private String requestHeader;
    
        private String requestBody;
    
        private String requestQuery;
    
        private String responseHeader;
    
        private String responseBody;
    
        private ApiCaseStepDTO step;
    }
    
    ```

  * Spring容器对象封装工具类

    ```
    public class SpringContextHolder {
    
        /**
         * 保存ApplicationContext,可在项目中任意位置中取出ApplicationContext
         */
        private static ApplicationContext applicationContext;
    
    
        public static void setApplicationContext(ApplicationContext applicationContext) {
            SpringContextHolder.applicationContext = applicationContext;
        }
    
        /**
         * 通过name获取 Bean.
         * @param name
         * @return
         */
        public static Object getBean(String name){
            return applicationContext.getBean(name);
        }
    
        /**
         * 通过class获取class下的全部Bean.
         * @param clazz
         * @param <T>
         * @return
         */
        public static <T> Map<String, T> getBeans(Class<T> clazz){
            return applicationContext.getBeansOfType(clazz);
        }
    
        /**
         * 通过class获取Bean.
         * @param clazz
         * @param <T>
         * @return
         */
        public static <T> T getBean(Class<T> clazz){
            return applicationContext.getBean(clazz);
        }
    }
    
    
    
    
    public static void main(String[] args) {
            ConfigurableApplicationContext applicationContext = SpringApplication.run(EngineApplication.class, args);
            SpringContextHolder.setApplicationContext(applicationContext);
    }
    ```

    









#### 第3集 Restassured配置和ApiRequeset封装实战

**简介：Restassured配置和ApiRequeset封装实战**

* 需求
  * 开发ApiRequeset请求工具类，用于请求相关模块开发
  * 解析相关JSON数组对象，处理基础路径、请求头、请求参数、创建Restassured请求对象

* 编码实战

  ```
  @Data
  public class ApiRequest {
      private String base;
  
      private String path;
  
      private String assertion;
  
      private String relation;
  
      private String query;
  
      private String header;
  
      private String body;
  
      private String bodyType;
  
      private List<ApiJsonAssertionDTO> assertionList;
  
      private List<ApiJsonRelationDTO> relationList;
  
      private List<KeyValueDTO> queryList;
  
  
      private List<KeyValueDTO> headerList;
  
      private List<KeyValueDTO> bodyList;
  
      private RequestSpecification request = RestAssured.given();
  
      public ApiRequest(String base, String path, String assertion, String relation, String query, String header, String body, String bodyType) {
          this.base = base;
          this.path = path;
          this.assertion = assertion;
          this.relation = relation;
          this.query = query;
          this.header = header;
          this.body = body;
          this.bodyType = bodyType;
  
          this.assertionList = StringUtils.isBlank(assertion) ?
                  null : Arrays.stream(JsonUtil.json2Obj(assertion, ApiJsonAssertionDTO[].class)).toList();
          this.relationList = StringUtils.isBlank(relation)?
                  null : Arrays.stream(JsonUtil.json2Obj(relation, ApiJsonRelationDTO[].class)).toList();
          this.queryList =  StringUtils.isBlank(query) ?
                  null : Arrays.stream(JsonUtil.json2Obj(query, KeyValueDTO[].class)).toList();
          this.headerList =  StringUtils.isBlank(header) ?
                  null :Arrays.stream(JsonUtil.json2Obj(header, KeyValueDTO[].class)).toList();
          this.bodyList =  StringUtils.isBlank(body)?
                  null :Arrays.stream(JsonUtil.json2Obj(body, KeyValueDTO[].class)).toList();
      }
  
      /**
       * 创建请求配置
       * @return
       */
      public RequestSpecification createRequest() {
          // 装配基础路径 
          ApiWireUtil.wireBase(request, base, path);
  
          // 装配请求头
          ApiWireUtil.wireHeader(request, headerList);
  
          // 装配请求参数
          ApiWireUtil.wireQuery(request, queryList);
  
          // 装配请求体
          ApiWireUtil.wireBody(request, bodyType, bodyList);
  
          return request;
      }
  }
  ```

* **思考下问题：接口之间关联参数怎么做，即存和取**

























#### 第4集 【重点】多接口编排之接口依赖参数传递解决方案

**简介：多接口编排-接口依赖参数传递解决方案**

* **难点问题：**
  * **多接口编排，不同接口之间有参数依赖，如何进行传递**

<img src="img/image-20240123143043623.png" alt="image-20240123143043623" style="zoom:30%;" />

* **解决方案：ThreadLocal**

  - 全称thread local variable（线程局部变量）功用非常简单，使用场合主要解决多线程中数据因并发产生不一致问题。

  - ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某时间访问到的并不是同一个对象

  - 这样就隔离了多个线程对数据的数据共享，这样的结果是耗费了内存

  - 但大大减少了线程同步所带来性能消耗，也减少了线程并发控制的复杂度。 

  - 总结起来就是：同个线程共享数据

  - 应用场景

    - ThreadLocal 用作每个线程内需要独立保存信息，方便同个线程的其他方法获取该信息的场景。 

    - 每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过ThreadLocal 直接获取到

    - 避免了传参，类似于全局变量的概念

      - 比如用户登录令牌解密后的信息传递（用户权限信息、从用户系统获取到的用户名、用户ID）

      ![image-20210204002205526](img/image-20210204002205526.png)



* 解决方案概述

  * 封装 ThreadLocal，里面存储Map结构，即可保存多个参数

  ```
  ThreadLocal<Map<String, String>> THREAD_LOCAL = new ThreadLocal<>();
  ```

  * 同个用例里面多个请求执行都是同个线程，可以实现参数存储和获取
  * 接口需要使用到依赖参数，使用的是 `{{ xxx }}` , 这类可以使用正则表达式进行替换

![image-20240123150318609](img/image-20240123150318609.png)















#### 第5集 多接口编排-依赖参数传递开发实战《上》

**简介：多接口编排-依赖参数传递开发实战《上》**

* 需求

  * 开发多接口依赖参数传递模块，封装 ThreadLocal，里面存储Map结构
  * 处理ApiRequest对象，组装请求头，请求参数，请求体可以实现参数存储和获取
  * 完善 ApiWireUtil 相关方法，实现关联参数处理

* 编码实战

  ```
  public class ApiRelationContext {
      private static final ThreadLocal<Map<String, String>> THREAD_LOCAL = new ThreadLocal<>();
  
      public static Map<String, String> get() {
          return THREAD_LOCAL.get();
      }
  
      public static String get(String key) {
          Map<String, String> map = THREAD_LOCAL.get();
          if (map == null) {
              return null;
          }
          return map.get(key);
      }
  
      public static void set(String key, String value) {
          if (THREAD_LOCAL.get() == null) {
              THREAD_LOCAL.set(new HashMap<>(16));
          }
          THREAD_LOCAL.get().put(key, value);
      }
  
      public static void remove() {
          String filePaths = get("filePaths");
          if(filePaths!=null){
              String[] filePathArr = filePaths.split(",");
              for(String filePath : filePathArr){
                  Path path = Paths.get(filePath);
                  try {
                      Files.delete(path);
                  } catch (IOException e) {
                      throw new RuntimeException(e);
                  }
              }
          }
          THREAD_LOCAL.remove();
      }
  }
  
  
  ```











#### 第6集 多接口编排-依赖参数传递开发实战《下》

**简介：多接口编排-依赖参数传递开发实战《下》**

* 需求
  * 开发多接口依赖参数传递模块，封装 ThreadLocal，里面存储Map结构
  * 处理ApiRequest对象，组装请求头，请求参数，请求体可以实现参数存储和获取
  * 完善 ApiWireUtil 相关方法，实现关联参数处理

* 编码实战

  ```
  public class ApiRegexpUtil {
      /**
       * 正则表达式 - 关联取值
       * 匹配以 {{ 开头，以 }} 结尾，且中间不包含 }} 的字符串
       */
      public static final String REGEXP = "\\{\\{([^}]+)}}";
  
      /**
       * 正则表达式具名 - 关联取值
       * @param name
       * @return
       */
      public static String byName(String name) {
          return "\\{\\{(" + name + ")}}";
      }
  }
  
  
  @Test
  public void regexp() {
          // 测试正则表达式
          String url = "https://xdclass.net/get/{{name}}/{{detail}}";
          Pattern pattern = Pattern.compile(ApiRegexpUtil.REGEXP);
          Matcher matcher = pattern.matcher(url);
  
          while (matcher.find()) {
              String group = matcher.group(1);
              System.out.println(group);
              String byName = ApiRegexpUtil.byName(group);
              System.out.println(byName);
              System.out.println(url.replaceAll(byName, "1"));
          }
  }
  
  
  
  public class ApiRelationGetUtil {
      /**
       * 获取参数或获取关联参数
       * 正则匹配是否为关联参数表达式 如不是则返回原参数
       * @param string 关联参数
       * @return 关联参数
       */
      public static String getParameter(String string) {
          String newString = string;
          Pattern pattern = Pattern.compile(ApiRegexpUtil.REGEXP);
          Matcher matcher = pattern.matcher(string);
          if (matcher.find()) {
              String parameter = matcher.group(1);
              // 取参数
              String fetched = ApiRelationContext.get(parameter);
              if (fetched == null) {
                  // 关联参数不存在
                  throw new BizException(BizCodeEnum.API_RELATION_NOT_EXIST);
              }
              newString = string.replaceAll(ApiRegexpUtil.byName(parameter), fetched);
          }
          return newString;
      }
  }
  
  
  
   public static void wireHeader(RequestSpecification request, List<KeyValueDTO> list) {
          if (list == null || list.isEmpty()) {
              return;
          }
  
          HashMap<String, Object> map = new HashMap<>();
          for (KeyValueDTO item : list) {
              // 正则匹配是否为关联参数表达式 如不是则返回原参数
              String value = ApiRelationGetUtil.getParameter(item.getValue());
              item.setValue(value);
              map.put(item.getKey(), value);
          }
          request.headers(map);
      }
  ```
  














#### 第7集 ApiRequeset多类型请求体Body开发实战

**简介：ApiRequeset多类型请求体Body开发实战**

* 需求
  * 开发ApiRequeset请求工具类，用于请求相关模块开发，处理请求体内容封装
  * **支持多个FORM_DATA，X_WWW_FORM_URLENCODED，JSON，BINARY等格式参数处理**
  * 数据库body字段存储类型说明
    * JSON类型的话原始存储
    * 其他类型则是Key-Value数组类型存储
  
* 编码实战

  ```
  
      /**
       * 装配请求体
       *
       * @param request
       * @param bodyType 请求体类型
       * @param list
       */
      public static void wireBody(RequestSpecification request, RequestBodyDTO requestBody, List<KeyValueDTO> list) {
          if (ApiBodyTypeEnum.JSON.name().equals(requestBody.getBodyType())) {
              //解析
              String modifiedJson = traverseAndModify(requestBody.getBody());
              requestBody.setBody(modifiedJson);
              request.body(modifiedJson);
          } else {
              // 设置请求体
              ApiBodyTypeEnum bodyTypeEnum = ApiBodyTypeEnum.valueOf(requestBody.getBodyType());
              for (KeyValueDTO item : list) {
                  switch (bodyTypeEnum) {
                      case FORM_DATA, X_WWW_FORM_URLENCODED:
                          String value = ApiRelationGetUtil.getParameter(item.getValue());
                          item.setValue(value);
                          request.formParam(item.getKey(), value);
                          break;
                      case BINARY:
                          FileService fileService = SpringContextHolder.getBean(FileService.class);
                          String localTempFile = fileService.copyRemoteFileToLocalTempFile(item.getValue());
                          File file = new File(localTempFile);
                          request.multiPart(file);
                          //放置threadLocal里面，后续清理相关资料
                          String filePaths = ApiRelationContext.get("filePaths");
                          if (filePaths != null) {
                              filePaths = filePaths + "," + file.getAbsolutePath();
                              ApiRelationContext.set("filePaths", filePaths);
                          } else {
                              filePaths = file.getAbsolutePath();
                              ApiRelationContext.set("filePaths", filePaths);
                          }
                          item.setValue(filePaths);
                          break;
                      default:
                          throw new IllegalStateException("Unexpected value: " + requestBody.getBodyType());
                  }
              }
          }
      }
  
  
      public static String traverseAndModify(String json) {
          JSONObject jsonObject = JSON.parseObject(json);
          traverseJsonObject(jsonObject);
          return JSON.toJSONString(jsonObject);
      }
  
     private static void traverseJsonObject(JSONObject jsonObject) {
      if (jsonObject != null) {
          for (String key : jsonObject.keySet()) {
              Object value = jsonObject.get(key);
              if (value instanceof JSONObject) {
                  traverseJsonObject((JSONObject) value);
              } else if (value instanceof JSONArray) {
                  JSONArray jsonArray = (JSONArray) value;
                  for (int i = 0; i < jsonArray.size(); i++) {
                      Object subValue = jsonArray.get(i);
                      if (subValue instanceof String subStringValue) {
                          String parameterizedValue = ApiRelationGetUtil.getParameter(subStringValue);
                          jsonArray.remove(subStringValue);
                          jsonArray.add(parameterizedValue);
                          // 仅在实际需要日志记录时，使用占位符记录
                          // log.info("Parameterized string: {} -> {}", subStringValue, parameterizedValue);
                      } else if (subValue instanceof JSONObject subJsonObject) {
                          traverseJsonObject(subJsonObject);
                      } else {
                          log.error("Unsupported type encountered: {}", subValue.getClass().getName());
                      }
                  }
              } else if (value instanceof String stringValue) {
                  String parameterizedValue = ApiRelationGetUtil.getParameter(stringValue);
                  jsonObject.put(key, parameterizedValue);
                  // 仅在实际需要日志记录时，使用占位符记录
                  // log.info("Parameterized string: {} -> {}", stringValue, parameterizedValue);
              } else {
                  log.error("Unsupported type encountered: {}", value.getClass().getName());
              }
          }
      }
  }
  ```
  
  













#### 第8集 接口自动化测试用例执行链路开发实战

**简介：接口自动化测试用例执行链路开发实战**

* 需求
  * 完善接口自动化测试用例执行链路开发，包括测试报告概述处理
  * 完善接口自动化测试报告发送接口

* 编码实战

  ```
   public ApiCaseResultDTO execute(CaseInfoDTO caseInfo, List<ApiCaseStepDO> stepList) {
          try {
              // 执行步骤数量
              int quantity = stepList.size();
              // 开始时间
              long startTime = System.currentTimeMillis();
              ApiCaseResultDTO result = doExecute(null, stepList);
              // 结束时间
              long endTime = System.currentTimeMillis();
  
              // 设置步骤列表执行信息
              result.setReportId(reportDTO.getId());
              result.setStartTime(startTime);
              result.setEndTime(endTime);
              result.setExpendTime(endTime - startTime);
              result.setQuantity(quantity);
              int passQuantity = result.getList()
                      .stream()
                      .filter(item -> {
                                  item.setReportId(reportDTO.getId());
                                  return item.getExecuteState() && item.getAssertionState();
                              })
                      .toList()
                      .size();
              result.setPassQuantity(passQuantity);
              result.setFailQuantity(result.getQuantity() - passQuantity);
              result.setExecuteState(Objects.equals(result.getQuantity(), result.getPassQuantity()));
              // 发送执行结果
              resultSenderService.sendResult(caseInfo, TestTypeEnum.API, JsonUtil.obj2Json(result));
              return result;
          } finally {
              // 释放资源
              ApiRelationContext.remove();
          }
      }
  ```

  













![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第二十一章 接口测试引擎递归设计和关联参数存储



#### 第1集 多接口编排之测试结果传递和调用解决方案

**简介：多接口编排之测试结果传递和调用解决方案**

* **问题：一个用例包括多个接口步骤，如何知道多个接口请求，每个接口的的结果如何向下传递并最终汇总**

<img src="img/image-20240123154015913.png" alt="image-20240123154015913" style="zoom:50%;" />

* **解决方案：递归处理**

  * 程序调用自身的编程技巧称为递归( recursion) ，做为一种算法在程序设计语言中广泛应用，
  * 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法
  * 优点
    * 递归能让代码看起来更简洁，更容易理解
    * 例如你要写一个函数来计算一个数字的阶乘，如果使用递归，只需要写几行代码就可以了。
  * 缺点
    * 每次函数调用都需要在内存中保存一些信息，如果调用的次数太多，就会占用很多内存，甚至导致程序崩溃
  * 案例

  ```
  public class PowerExample {  
      public static void main(String[] args) {  
          int base = 2;  
          int exponent = 3;  
          int result = power(base, exponent);  
          System.out.println(base + "的" + exponent + "次幂是：" + result);  
      }  
    
      public static int power(int base, int exponent) {  
          if (exponent == 0) {  
              return 1;  
          } else {  
              return base * power(base, exponent - 1);  
          }  
      }  
  }
  ```

  

* 具体解决方案说明

  * 封装`doExecute` 方法，递归调用对应的逻辑方法，把 用例执行结果和用例步骤列表作为入参
  * 方法返回值需要是 `ApiCaseResultDTO`  对象
  * 用例步骤列表入参，每执行一步需要移除 已经执行过的 用例步骤，保存当前用例步骤执行结果
  * 跳出条件就是 用例步骤列表为空

  `public ApiCaseResultDTO doExecute(ApiCaseResultDTO result, List<ApiCaseStepDO> stepList) `

![image-20240128173132914](img/image-20240128173132914.png)



















#### 第2集 多接口编排之doExecute核心业务逻辑编码实战

**简介：多接口编排之doExecute核心业务逻辑编码实战**

* 需求

  * 完成多接口编排doExecute递归方法开发
  * 包括多环境、步骤创建请求对象、执行请求和步骤请求结果处理等

  ![image-20240128173132914](img/image-20240128173132914.png)

* 编码实战

  ```
   public ApiCaseResultDTO doExecute(ApiCaseResultDTO result, List<ApiCaseStepDO> stepList) {
          if (result == null) {
              result = new ApiCaseResultDTO();
              result.setList(new ArrayList<>());
          }
          if (result.getList() == null) {
              result.setList(new ArrayList<>());
          }
          if (stepList == null || stepList.isEmpty()) {
              return result;
          }
  
          ApiCaseStepDO step = stepList.get(0);
          // 步骤信息初始化
          ApiCaseResultItemDTO resultItem = new ApiCaseResultItemDTO();
          result.getList().add(resultItem);
          resultItem.setStep(SpringBeanUtil.copyProperties(step, ApiCaseStepDTO.class));
          resultItem.setExecuteState(true);
          resultItem.setAssertionState(true);
  
          // 获取当前步骤的环境
          EnvironmentDO environmentDO = environmentMapper.selectById(step.getEnvironmentId());
          String base = EnvironmentUtil.getUrl(environmentDO);
          // 创建请求配置
          ApiRequest request = new ApiRequest(base, step.getPath(), step.getAssertion(), step.getRelation(), step.getQuery(), step.getHeader(), step.getBody(), step.getBodyType());
          RequestSpecification given = request.createRequest();
  
          try {
              // 请求开始时间
              long startTime = System.currentTimeMillis();
  
              // 发送请求
              Response response = given
                      .request(step.getMethod())
                      .thenReturn();
              // 请求结束时间
              long endTime = System.currentTimeMillis();
              // 设置当前步骤结束信息
              resultItem.setExpendTime(endTime - startTime);
              resultItem.setRequestHeader(JsonUtil.obj2Json(request.getHeaderList()));
              resultItem.setRequestQuery(JsonUtil.obj2Json(request.getQueryList()));
              if(step.getBodyType().equals(ApiBodyTypeEnum.JSON.name())){
                  resultItem.setRequestBody(request.getRequestBody().getBody());
              }else {
                  resultItem.setRequestBody(JsonUtil.obj2Json(request.getBodyList()));
              }
              resultItem.setResponseBody(response.getBody().asString());
              resultItem.setResponseHeader(JsonUtil.obj2Json(response.getHeaders()));
  
          } catch (BizException e) {
              e.printStackTrace();
              // 断言失败
              resultItem.setAssertionState(false);
          } catch (Exception e) {
              e.printStackTrace();
              resultItem.setExecuteState(false);
              // 记录异常信息
              StringWriter sw = new StringWriter();
              e.printStackTrace(new PrintWriter(sw));
              resultItem.setExceptionMsg(sw.toString());
          }
          // 下轮递归
          stepList.remove(0);
          return doExecute(result, stepList);
      }
  ```

  









#### 第3集 响应结果处理之接口关联取值存储编码实战《上》

**简介：响应结果处理之接口关联取值存储编码实战《上》**

* 需求

  * 前面开发了多接口依赖参数传递模块，封装 ThreadLocal，里面存储Map结构

  ```
  ThreadLocal<Map<String, String>> THREAD_LOCAL = new ThreadLocal<>();
  ```

  ![image-20240123150318609](img/image-20240123150318609.png)

  * 封装了`ApiRelationGetUtil` 取值方法，但是针对响应结果存储接口方法还没开发
  * 需要开发存储关联参数的方法，且支持多种参数提取类型：**JSONPath和正则提取，包括未来可以拓展更多**
  * 数据库relation字段存储 `[{"from":"RESPONSE_DATA","type":"JSONPATH","express":"$.data","name":"token"}]`

![image-20240128181224621](img/image-20240128181224621.png)

* 编码实战

  ```
  public static void dispatcher(ApiRequest request, Response response) {
          if (request.getRelationList() == null) {
              return;
          }
  
          for (ApiJsonRelationDTO relation : request.getRelationList()) {
              ApiRelateTypeEnum typeEnum = ApiRelateTypeEnum.valueOf(relation.getType());
              switch (typeEnum) {
                  case REGEXP:
                      regexp(request, response, relation);
                      break;
  
                  case JSONPATH:
                      jsonpath(request, response, relation);
                      break;
  
                  default:
                      throw new BizException(BizCodeEnum.API_OPERATION_UNSUPPORTED_FROM);
              }
          }
      }
      
      
  // 关联取值
  ApiRelationSaveUtil.dispatcher(request, response);
  ```

  







#### 第4集 响应结果处理之接口关联取值存储编码实战《下》

**简介：响应结果处理之接口关联取值存储编码实战《下》**

* 需求
  * 完成多接口关联参数模块， 处理响应结果，解析`relation` 字段完成相关参数提取
  * **需要支持：JSONPath和正则提取**

* 编码实战

  ```
   /**
       * 关联取值 JSONPATH
       * @param request 请求对象
       * @param response 响应对象
       * @param relation
       */
      public static void jsonpath(ApiRequest request, Response response, ApiJsonRelationDTO relation) {
          try {
              ApiRelateFieldFromEnum fieldFromEnum = ApiRelateFieldFromEnum.valueOf(relation.getFrom());
              String value = switch (fieldFromEnum) {
                  case REQUEST_HEADER -> request.getHeader();
                  case REQUEST_BODY -> request.getRequestBody().getBody();
                  case REQUEST_QUERY -> request.getQuery();
                  case RESPONSE_HEADER -> JsonUtil.obj2Json(response.getHeaders());
                  case RESPONSE_DATA -> response.getBody().asString();
                  default -> throw new BizException(BizCodeEnum.API_OPERATION_UNSUPPORTED_FROM);
              };
  
              Object json = JsonPath.read(value , relation.getExpress());
              if (json != null) {
                  ApiRelationContext.set(relation.getName(), String.valueOf(json));
              }
          } catch (Exception e) {
              throw new BizException(BizCodeEnum.API_OPERATION_UNSUPPORTED_RELATION,e);
          }
      }
  
      /**
       * 关联取值 REGEXP
       * @param request 请求对象
       * @param response 响应对象
       * @param relation
       */
      public static void regexp(ApiRequest request, Response response, ApiJsonRelationDTO relation) {
          try {
              Pattern pattern = Pattern.compile(relation.getExpress());
              ApiRelateFieldFromEnum fieldFromEnum = ApiRelateFieldFromEnum.valueOf(relation.getFrom());
              String value = switch (fieldFromEnum) {
                  case REQUEST_HEADER -> request.getHeader();
                  case REQUEST_BODY -> request.getRequestBody().getBody();
                  case REQUEST_QUERY -> request.getQuery();
                  case RESPONSE_HEADER -> response.getHeaders().toString();
                  case RESPONSE_DATA -> response.getBody().toString();
                  default -> throw new BizException(BizCodeEnum.API_OPERATION_UNSUPPORTED_FROM);
              };
              Matcher matcher = pattern.matcher(value);
              if (matcher.find()) {
                  ApiRelationContext.set(relation.getName(), matcher.group());
              }
          } catch (Exception e) {
              throw new BizException(BizCodeEnum.API_OPERATION_UNSUPPORTED_RELATION,e);
          }
      }
    
    
      /**
       * API操作
       */
      API_OPERATION_UNSUPPORTED_FROM(230004, "不支持的来源操作"),
      API_OPERATION_UNSUPPORTED_ASSERTION(230005, "不支持的断言操作"),
      API_OPERATION_UNSUPPORTED_RELATION(230006, "不支持的关联取值"),
      API_RELATION_NOT_EXIST(230007, "关联参数不存在"),
      API_ASSERTION_FAILED(230008, "API断言失败"),
      API_FILE_NOT_EXIST(230010, "API上传文件不存在"),
  ```

  











#### 第5集 接口自动化测试之用例多类型断言解决方案设计

**简介：接口自动化测试之用例多类型断言解决方案设计**

* 需求

  * 如何判断接口是否满足业务需求，前面学过压测引擎，大家应该记得 断言assert
    - 指期望用户指定的条件满足，它是当用户定义的约束条件不满足时触发异常
    - 简单说：**判断程序结果是否符合预期**
  * 断言也是提取响应结果，支持多类型参数提取，包括  **JSONPath和正则提取，包括未来可以拓展更多**
  * 数据库字段  assertion 字段存储 如下案例

  ```
  [{"from":"RESPONSE_DATA","type":"JSONPATH","action":"EQUAL","express":"$.success","value":"true"}]
  ```

![image-20240128181203759](img/image-20240128181203759.png)

* 编码实战

  ```
  
      /**
       * 断言行动分配器
       * @param value 值
       * @param expectValue 预期值
       * @return
       */
      public static boolean assertionDispatcher(String action, String value, String expectValue) {
          ApiAssertActionEnum assertActionEnum = ApiAssertActionEnum.valueOf(action);
          return switch (assertActionEnum) {
              // 包含
              case CONTAIN -> value.contains(expectValue);
  
              // 不包含
              case NOT_CONTAIN -> !value.contains(expectValue);
  
              // 相等
              case EQUAL -> value.equals(expectValue);
  
              // 不相等
              case NOT_EQUAL -> !value.equals(expectValue);
  
              // 大于
              case GREAT_THEN -> Long.parseLong(value) > Long.parseLong(expectValue);
  
              // 小于
              case LESS_THEN -> Long.parseLong(value) < Long.parseLong(expectValue);
  
              default -> throw new BizException(BizCodeEnum.API_OPERATION_UNSUPPORTED_ASSERTION);
          };
      }
  ```

  









#### 第6集 接口自动化测试之用例多类型断言编码实战

**简介：接口自动化测试之用例多类型断言编码实战**

* 需求
  * 完成接口自动化响应结果处理，多类型断言业务逻辑开发
  * 开发支持多类型参数提取，包括  **JSONPath和正则提取，包括未来可以拓展更多**
  * 解析数据库字段  assertion 字段存储

* 编码实战

  ```
      /**
       * 断言来源分配器
       * @param request
       * @param response
       */
      public static void dispatcher(ApiRequest request, Response response) {
          if (request.getAssertion() == null) {
              return;
          }
  
          for (ApiJsonAssertionDTO assertion : request.getAssertionList()) {
              boolean state = true;
              String express = assertion.getExpress();
              String expectValue = assertion.getValue();
              ApiAssertFieldFromEnum fieldFromEnum = ApiAssertFieldFromEnum.valueOf(assertion.getFrom());
              try {
                  if (ApiAssertTypeEnum.JSONPATH.name().equals(assertion.getType())) {
                      // jsonpath定位
                      state = switch (fieldFromEnum) {
                          case RESPONSE_CODE -> {
                              String stringify = String.valueOf(response.getStatusCode());
                              Object responseCode = JsonPath.read(stringify, express);
                              yield assertionDispatcher(assertion.getAction(), String.valueOf(responseCode), expectValue);
                          }
  
                          case RESPONSE_HEADER -> {
                              String stringify = JsonUtil.obj2Json(response.getHeaders());
                              Object responseHeader = JsonPath.read(stringify, express);
                              yield assertionDispatcher(assertion.getAction(), String.valueOf(responseHeader), expectValue);
                          }
  
                          case RESPONSE_DATA -> {
  
                              String stringify = response.getBody().asString();
                              //String stringify = JsonUtil.obj2Json(body);
                              Object responseBody = JsonPath.read(stringify, express);
                              yield assertionDispatcher(assertion.getAction(), String.valueOf(responseBody), expectValue);
                          }
  
                          default -> {
                              log.error("不支持的断言来源: {}", fieldFromEnum);
                              throw new BizException(BizCodeEnum.API_OPERATION_UNSUPPORTED_FROM);
                          }
                      };
  
                  } else if (ApiAssertTypeEnum.REGEXP.name().equals(assertion.getType())) {
                      // 正则表达式定位
                      Pattern pattern = Pattern.compile(express);
                      state = switch (fieldFromEnum) {
                          case RESPONSE_CODE -> {
                              String responseCode = String.valueOf(response.getStatusCode());
                              Matcher matcher = pattern.matcher(responseCode);
                              yield matcher.find() && assertionDispatcher(assertion.getAction(), matcher.group(), expectValue);
                          }
  
                          case RESPONSE_HEADER -> {
                              String responseHeader = JsonUtil.obj2Json(response.getHeaders());
                              Matcher matcher = pattern.matcher(responseHeader);
                              yield matcher.find() && assertionDispatcher(assertion.getAction(), matcher.group(), expectValue);
                          }
  
                          case RESPONSE_DATA -> {
                              String responseBody = JsonUtil.obj2Json(response.getBody().asString());
                              Matcher matcher = pattern.matcher(responseBody);
                              yield matcher.find() && assertionDispatcher(assertion.getAction(), matcher.group(), expectValue);
                          }
  
                          default ->{
                              log.error("不支持的断言来源: {}", fieldFromEnum);
                              throw new BizException(BizCodeEnum.API_OPERATION_UNSUPPORTED_FROM);
                          }
  
                      };
                  }
  
                  if (!state) {
                      // 断言失败
                      throw new BizException(BizCodeEnum.API_ASSERTION_FAILED);
                  }
              } catch (Exception e) {
                  e.printStackTrace();
                  throw new BizException(BizCodeEnum.API_ASSERTION_FAILED);
              }
          }
      }
  ```

  













![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第二十二章 云测平台-接口自动化引擎全链路测试实战



#### 第1集 接口自动化测试引擎之基础案例测试实战

**简介：接口自动化测试引擎基础案例测试实战**

* 需求

  * 进行初步链路测试，可以实现接口自动化测试请求
  * 生成初步测试报告，测试接口类型如下
    * GET请求
    * POST请求：FORM表单、JSON格式

  * Bug修复

    * BodyType类型空判断，如果是GET请求 或 Body为空 则不用进行处理相关请求Body

    ![image-20240130160730273](img/image-20240130160730273.png)

    ![image-20240130160559477](img/image-20240130160559477.png)

    * 消息发送组件 RedisResultSenderServiceImpl 注解去除，避免Spring工具类同时获取两个Bean对象
    * 测试接口 `/api/v2/test/buy`  入参改为 `Map<String,Object> map`

* 测试用例数据录入

  * GET请求

  ```
  INSERT INTO `test_engine`.`api_case_step` (`id`, `project_id`, `environment_id`, `case_id`, `num`, `name`, `description`, `assertion`, `relation`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (39, 1, 1, 1, 0, 'GET单接口请求', NULL, NULL, NULL, '/api/v2/test/detail', 'GET', '[{\"key\":\"id\",\"value\":4444}]', NULL, NULL, NULL, '2024-01-30 06:32:11', '2024-01-30 06:32:11');
  ```

  * POST请求-FORM表单

  ```
  INSERT INTO `test_engine`.`api_case_step` (`id`, `project_id`, `environment_id`, `case_id`, `num`, `name`, `description`, `assertion`, `relation`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (40, 1, 1, 2, 0, 'POST-Form表单', NULL, NULL, NULL, '/api/v2/test/login_form', 'POST', NULL, '[{\"key\":\"Content-Type\",\"value\":\"application/x-www-form-urlencoded\"}]', '[{\"key\":\"mail\",\"value\":\"xdclass\"},{\"key\":\"pwd\",\"value\":\"123456\"}]', 'X_WWW_FORM_URLENCODED', '2024-01-30 06:49:09', '2024-01-30 06:49:46');
  ```

  * POST请求-JSON格式

  ```
  INSERT INTO `test_engine`.`api_case_step` (`id`, `project_id`, `environment_id`, `case_id`, `num`, `name`, `description`, `assertion`, `relation`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (41, 1, 1, 3, 0, 'POST-Json', NULL, NULL, NULL, '/api/v2/test/buy', 'POST', NULL, '[{\"key\":\"Content-Type\",\"value\":\"application/json\"},{\"key\":\"token\",\"value\":\"a59829bc81d24cecb5d1824483c77618\"}]', '{\"id\":111,\"title\":\"小滴课堂架构大课\",\"product\":{\"id\":1,\"price\":99},\"list\":[\"云测平台\",\"会员\"]}', 'JSON', '2024-01-30 06:52:37', '2024-01-30 07:13:19');
  ```

  

  













#### 第2集 接口自动化测试多接口编排测试实战

**简介：接口自动化测试多接口编排测试实战**

* 需求
  * 案例测试多接口编排，一个用例里面执行多个接口，并且返回结果

* 测试用例数据录入

```
INSERT INTO `test_engine`.`api_case_step` (`id`, `project_id`, `environment_id`, `case_id`, `num`, `name`, `description`, `assertion`, `relation`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (42, 1, 1, 4, 0, '步骤一GET单接口请求', NULL, NULL, NULL, '/api/v2/test/detail', 'GET', '[{\"key\":\"id\",\"value\":4444}]', NULL, NULL, NULL, '2024-01-30 06:32:11', '2024-01-30 07:17:33');
INSERT INTO `test_engine`.`api_case_step` (`id`, `project_id`, `environment_id`, `case_id`, `num`, `name`, `description`, `assertion`, `relation`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (43, 1, 1, 4, 1, '步骤二POST-Form表单', NULL, NULL, NULL, '/api/v2/test/login_form', 'POST', NULL, '[{\"key\":\"Content-Type\",\"value\":\"application/x-www-form-urlencoded\"}]', '[{\"key\":\"mail\",\"value\":\"xdclass\"},{\"key\":\"pwd\",\"value\":\"123456\"}]', 'X_WWW_FORM_URLENCODED', '2024-01-30 06:49:09', '2024-01-30 07:17:44');
INSERT INTO `test_engine`.`api_case_step` (`id`, `project_id`, `environment_id`, `case_id`, `num`, `name`, `description`, `assertion`, `relation`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (44, 1, 1, 4, 2, '步骤三 POST-Json', NULL, NULL, NULL, '/api/v2/test/buy', 'POST', NULL, '[{\"key\":\"Content-Type\",\"value\":\"application/json\"},{\"key\":\"token\",\"value\":\"a59829bc81d24cecb5d1824483c77618\"}]', '{\"id\":111,\"title\":\"小滴课堂架构大课\",\"product\":{\"id\":1,\"price\":99},\"list\":[\"云测平台\",\"会员\"]}', 'JSON', '2024-01-30 06:52:37', '2024-01-30 07:17:45');
```















#### 第3集 多接口编排测试实战之多类型参数传递实战

**简介：多接口编排测试实战之多类型参数传递实战**

* 需求

  * 案例测试多接口编排，一个用例里面执行多个接口，并且返回结果
  * 需要自动提取接口关联参数案例实战，支持JSONPath和正则方式提取

* 测试用例数据录入

  * JSONPath提取

  ```
  INSERT INTO `test_engine`.`api_case_step` (`id`, `project_id`, `environment_id`, `case_id`, `num`, `name`, `description`, `assertion`, `relation`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (45, 1, 1, 5, 0, '参数传递-jsonpath-步骤一GET单接口请求', NULL, NULL, NULL, '/api/v2/test/detail', 'GET', '[{\"key\":\"id\",\"value\":4444}]', NULL, NULL, NULL, '2024-01-30 06:32:11', '2024-01-30 07:24:46');
  INSERT INTO `test_engine`.`api_case_step` (`id`, `project_id`, `environment_id`, `case_id`, `num`, `name`, `description`, `assertion`, `relation`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (46, 1, 1, 5, 1, '参数传递-jsonpath-步骤二POST-Form表单', NULL, NULL, '[{\"from\":\"RESPONSE_DATA\",\"type\":\"JSONPATH\",\"express\":\"$.data\",\"name\":\"token\"}]', '/api/v2/test/login_form', 'POST', NULL, '[{\"key\":\"Content-Type\",\"value\":\"application/x-www-form-urlencoded\"}]', '[{\"key\":\"mail\",\"value\":\"xdclass\"},{\"key\":\"pwd\",\"value\":\"123456\"}]', 'X_WWW_FORM_URLENCODED', '2024-01-30 06:49:09', '2024-01-30 07:24:48');
  INSERT INTO `test_engine`.`api_case_step` (`id`, `project_id`, `environment_id`, `case_id`, `num`, `name`, `description`, `assertion`, `relation`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (47, 1, 1, 5, 2, '参数传递-jsonpath-步骤三POST-Json', NULL, NULL, NULL, '/api/v2/test/buy', 'POST', NULL, '[{\"key\":\"Content-Type\",\"value\":\"application/json\"},{\"key\":\"token\",\"value\":\"{{token}}\"}]', '{\"id\":111,\"title\":\"小滴课堂架构大课\",\"product\":{\"id\":1,\"price\":99},\"list\":[\"云测平台\",\"会员\"]}', 'JSON', '2024-01-30 06:52:37', '2024-01-30 07:24:50');
  ```

  * 正则提取

  ```
  INSERT INTO `test_engine`.`api_case_step` (`id`, `project_id`, `environment_id`, `case_id`, `num`, `name`, `description`, `assertion`, `relation`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (48, 1, 1, 6, 0, '参数传递-正则-步骤一GET单接口请求', NULL, NULL, NULL, '/api/v2/test/detail', 'GET', '[{\"key\":\"id\",\"value\":4444}]', NULL, NULL, NULL, '2024-01-30 06:32:11', '2024-01-30 07:35:48');
  INSERT INTO `test_engine`.`api_case_step` (`id`, `project_id`, `environment_id`, `case_id`, `num`, `name`, `description`, `assertion`, `relation`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (49, 1, 1, 6, 1, '参数传递-正则-步骤二POST-Form表单', NULL, NULL, '[{\"from\":\"RESPONSE_DATA\",\"type\":\"REGEXP\",\"express\":\"([a-zA-Z0-9]{11,})\",\"name\":\"token\"}]', '/api/v2/test/login_form', 'POST', NULL, '[{\"key\":\"Content-Type\",\"value\":\"application/x-www-form-urlencoded\"}]', '[{\"key\":\"mail\",\"value\":\"xdclass\"},{\"key\":\"pwd\",\"value\":\"123456\"}]', 'X_WWW_FORM_URLENCODED', '2024-01-30 06:49:09', '2024-01-30 07:37:50');
  INSERT INTO `test_engine`.`api_case_step` (`id`, `project_id`, `environment_id`, `case_id`, `num`, `name`, `description`, `assertion`, `relation`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (50, 1, 1, 6, 2, '参数传递-正则-步骤三POST-Json', NULL, NULL, NULL, '/api/v2/test/buy', 'POST', NULL, '[{\"key\":\"Content-Type\",\"value\":\"application/json\"},{\"key\":\"token\",\"value\":\"{{token}}\"}]', '{\"id\":111,\"title\":\"小滴课堂架构大课\",\"product\":{\"id\":1,\"price\":99},\"list\":[\"云测平台\",\"会员\"]}', 'JSON', '2024-01-30 06:52:37', '2024-01-30 07:35:52');
  ```

  













#### 第4集 多接口编排测试实战之多类型断言案例

**简介：多接口编排测试实战之多类型断言案例**

* 需求

  * 案例测试多接口编排，一个用例里面执行多个接口，并且返回结果
  * 每个测试多个断言数据源和规则，包括响应码，响应体，有正则提取也有jsonpath提取

* 测试用例数据录入

  ```
  INSERT INTO `test_engine`.`api_case_step` (`id`, `project_id`, `environment_id`, `case_id`, `num`, `name`, `description`, `assertion`, `relation`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (51, 1, 1, 7, 0, '参数传递-断言-步骤一GET单接口请求', NULL, '[{\"from\":\"RESPONSE_CODE\",\"type\":\"REGEXP\",\"action\":\"EQUAL\",\"express\":\"200\",\"value\":\"201\"}]', NULL, '/api/v2/test/detail', 'GET', '[{\"key\":\"id\",\"value\":4444}]', NULL, NULL, NULL, '2024-01-30 06:32:11', '2024-01-30 07:48:17');
  INSERT INTO `test_engine`.`api_case_step` (`id`, `project_id`, `environment_id`, `case_id`, `num`, `name`, `description`, `assertion`, `relation`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (52, 1, 1, 7, 1, '参数传递-断言-步骤二POST-Form表单', NULL, '[{\"from\":\"RESPONSE_CODE\",\"type\":\"JSONPATH\",\"action\":\"EQUAL\",\"express\":\"$\",\"value\":\"201\"}]', '[{\"from\":\"RESPONSE_DATA\",\"type\":\"JSONPATH\",\"express\":\"$.data\",\"name\":\"token\"}]', '/api/v2/test/login_form', 'POST', NULL, '[{\"key\":\"Content-Type\",\"value\":\"application/x-www-form-urlencoded\"}]', '[{\"key\":\"mail\",\"value\":\"xdclass\"},{\"key\":\"pwd\",\"value\":\"123456\"}]', 'X_WWW_FORM_URLENCODED', '2024-01-30 06:49:09', '2024-01-30 07:48:20');
  INSERT INTO `test_engine`.`api_case_step` (`id`, `project_id`, `environment_id`, `case_id`, `num`, `name`, `description`, `assertion`, `relation`, `path`, `method`, `query`, `header`, `body`, `body_type`, `gmt_create`, `gmt_modified`) VALUES (53, 1, 1, 7, 2, '参数传递-断言-步骤三POST-Json', NULL, '[{\"from\":\"RESPONSE_DATA\",\"type\":\"JSONPATH\",\"action\":\"EQUAL\",\"express\":\"$.success\",\"value\":\"true\"}]', NULL, '/api/v2/test/buy', 'POST', NULL, '[{\"key\":\"Content-Type\",\"value\":\"application/json\"},{\"key\":\"token\",\"value\":\"{{token}}\"}]', '{\"id\":111,\"title\":\"小滴课堂架构大课\",\"product\":{\"id\":1,\"price\":99},\"list\":[\"云测平台\",\"会员\"]}', 'JSON', '2024-01-30 06:52:37', '2024-01-30 07:42:49');
  ```

  <img src="img/image-20240130160451964.png" alt="image-20240130160451964" style="zoom:30%;" />

* 作业改进点

  * 断言失败信息如何返回，改进增加断言错误信息

  ![image-20240130160512555](img/image-20240130160512555.png)























![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第二十三章 滴云自动化测试平台-接口自动化测试报告



#### 第1集 接口自动化测试报告库表设计和逆向工程

**简介：接口自动化测试报告库表设计和逆向工程**

* 需求

  * 接口自动化测试报告相关表设计
  * 逆向工程生成相关实体类

* 编码实战

  * 数据库表介绍

    ```
    CREATE TABLE `report_detail_api` (
      `id` bigint unsigned NOT NULL AUTO_INCREMENT,
      `report_id` bigint unsigned DEFAULT NULL COMMENT '所属报告ID',
      `execute_state` tinyint unsigned DEFAULT '0' COMMENT '执行状态',
      `assertion_state` tinyint unsigned DEFAULT '0' COMMENT '断言状态',
      `exception_msg` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT '异常信息',
      `expend_time` bigint unsigned DEFAULT NULL COMMENT '消耗时间',
      `request_header` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT '请求头',
      `request_query` longtext COLLATE utf8mb4_general_ci COMMENT '请求参数',
      `request_body` longtext COLLATE utf8mb4_general_ci COMMENT '请求体',
      `response_header` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT '响应头数据',
      `response_body` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT '响应体数据',
      `environment_id` bigint unsigned DEFAULT NULL COMMENT '所属环境ID',
      `case_id` bigint unsigned DEFAULT NULL COMMENT '所属API用例ID',
      `num` bigint unsigned DEFAULT NULL COMMENT '序号',
      `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'API用例步骤名称',
      `description` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'API用例步骤描述',
      `assertion` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT '响应断言',
      `relation` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT '关联参数',
      `path` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '请求路径',
      `method` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '请求方法 [GET POST PUT PATCH DELETE HEAD OPTIONS]',
      `query` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT '查询参数',
      `header` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT '请求头',
      `body` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT '请求体',
      `body_type` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '请求体格式 [form-data x-www-form-urlencoded json raw file]',
      `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP,
      `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
      PRIMARY KEY (`id`)
    ) ENGINE=InnoDB AUTO_INCREMENT=59 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
    ```

    

  * 逆向工程配置

















#### 第2集 接口自动化测试报告-消费者开发实战

**简介：接口自动化测试报告-消费者开发实战**

* 需求

  * 开发接口自动化测试的报告明细处理
  * 更新测试报告概述和接口测试明细保存

* 编码实战

  ```
   /**
       * 消费监听 API报告
       *
       * @param record
       */
  @KafkaListener(topics = {KafkaTopicConfig.API_TOPIC_NAME}, groupId = "xdclass-api-test-gp")
  public void onApiReportDetailMessage(ConsumerRecord<?, ?> record, Acknowledgment ack, @Header(KafkaHeaders.RECEIVED_TOPIC) String topic) {
          System.out.println("API消费：" + record.topic() + "-" + record.partition() + "-" + record.value());
  
          reportDetailService.handleApiReportDetail(record.value().toString());
  
          ack.acknowledge();
      }
      
      
      
   public void handleApiReportDetail(String reportContent) {
  
          ApiCaseResultDTO apiCaseStepResultDTO = JsonUtil.json2Obj(reportContent, ApiCaseResultDTO.class);
          //处理测试报告概述
          ReportDO reportDO = reportMapper.selectById(apiCaseStepResultDTO.getReportId());
  
          //处理完成测试报告
          reportDO.setExecuteState(ReportStateEnum.EXECUTE_SUCCESS.name());
          reportDO.setEndTime(apiCaseStepResultDTO.getEndTime());
          reportDO.setExpandTime(apiCaseStepResultDTO.getExpendTime());
          reportDO.setQuantity(Long.valueOf(apiCaseStepResultDTO.getQuantity()));
          reportDO.setFailQuantity(Long.valueOf(apiCaseStepResultDTO.getFailQuantity()));
          reportDO.setPassQuantity(reportDO.getQuantity() - reportDO.getFailQuantity());
          //更新报告状态
          reportMapper.updateById(reportDO);
  
          //处理接口测试明细
          List<ApiCaseResultItemDTO> stepList = apiCaseStepResultDTO.getList();
          stepList.forEach(item -> {
              ReportDetailApiDO reportDetailApiDO = SpringBeanUtil.copyProperties(item, ReportDetailApiDO.class);
              ApiCaseStepDTO step = item.getStep();
              reportDetailApiDO.setEnvironmentId(step.getEnvironmentId());
              reportDetailApiDO.setCaseId(step.getCaseId());
              reportDetailApiDO.setNum(step.getNum());
              reportDetailApiDO.setName(step.getName());
              reportDetailApiDO.setDescription(step.getDescription());
              reportDetailApiDO.setAssertion(step.getAssertion());
              reportDetailApiDO.setRelation(step.getRelation());
              reportDetailApiDO.setPath(step.getPath());
              reportDetailApiDO.setMethod(step.getMethod());
              reportDetailApiDO.setQuery(step.getQuery());
              reportDetailApiDO.setHeader(step.getHeader());
              reportDetailApiDO.setBody(step.getBody());
              reportDetailApiDO.setBodyType(step.getBodyType());
              reportDetailApiMapper.insert(reportDetailApiDO);
          });
  
      }
  ```

  

















#### 第3集 接口自动化测试引擎+测试报告全链路测试

**简介：接口自动化测试引擎全链路测试**

* 需求

  * 完成云测平台-接口自动化测试引擎全链路测试
  * 多接口编排+断言+参数关联+测试报告生成

  ![image-20240131144943612](img/image-20240131144943612.png)

* 链路测试实战















#### 第4集 滴云自动化测试平台-接口自动化测试引擎总结

**简介：滴云自动化测试平台-接口自动化测试引擎总结**

* 大家此刻的心情应该如下，TM终于把压测引擎-接口自动化测试引擎开发好了

  <img src="img/image-20240114150848929.png" alt="image-20240114150848929" style="zoom:30%;" />

* 知识点总结规划

  * **从接口自动化测试需求分析，到数据库表设计，到技术框架选择，到项目搭建**

  * **完成接口自动化测试引擎的多业务解决方案设计+核心逻辑开发**

  * **掌握了Restassured测试框架使用+封装，JsonPath、Gpath解析规则**

  * **封装了ApiExecuteEngine，支持递归处理多接口请求**

  * **封装了ApiRelationContext，采用了ThreadLocal存储不同接口的关联参数依赖**

  * **支持多接口编排、多类型请求方式、不同接口多断言规则和处理，接口自动化测试报告处理等**

  * 还有很多可以做的...**作为作业等待大家的探索设计，开源社区方向**

    * 整体代码逻辑优化和bug修复

    * 接口自动化测试参数提取和断言规则支持更多类型

    * 接口自动化报告传输组件和持久化数据源支持多类型

    * 接口自动化测试引擎支持多协议类型

    * 一键导入外部接口测试平台文档：Postman、Swagger等

    * ...

      

<img src="img/image-20240131150106993.png" alt="image-20240131150106993" style="zoom:50%;" />













![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第二十四章 滴云自动化测试平台-Web UI自动化测试介绍



#### 第1集 【面试高频】另一种爬虫-UI自动化介绍和应用场景

**简介：另一种爬虫-UI自动化介绍和应用场景【面试高频】**

* 什么是Web UI自动化测试

  * 利用软件工具模拟用户在图形界面上与应用程序交互的过程，自动执行测试用例并验证UI的功能是否符合预期
  * 使用自动化工具来打开网站/定位页面元素、操作元素（如输入文本、点击按钮等）模拟用户行为（如下拉菜单、滑动页面等）
  * 通过UI自动化测试可以 提高测试效率、确保回归测试的全面性，减少重复工作，且对持续集成和持续部署过程帮助很大

  <img src="img/image-20240221114535438.png" alt="image-20240221114535438" style="zoom:50%;" />



* **优点：**

  * **高效率**
    * 可以在较短时间内执行大量的测试用例，提高测试效率，对于回归测试，可以显著减少测试所需的时间和人力。
  * **减少人为错误**
    * 自动化测试脚本是由代码控制的，相比于人工测试，可以减少由于人为因素导致的错误。
  * **可重复性和一致性**
    * 自动化测试脚本可以反复执行，每次测试的条件和步骤都是一致的，保证测试的一致性和可重复性。
  * **更好的资源利用**
    * 自动化测试可以在非工作时间执行，如夜间，充分利用无人值守时间，提高了资源的利用率。

* **缺点：**

  * **不能完全取代手工测试**
    * 自动化测试虽然可以执行大量的测试用例，但对于一些需要人脑判断结果的测试用例
    * 或者对于新功能的首次测试，仍然需要手工测试。
  * **测试脚本的维护成本高**
    * 当被测系统的UI或功能发生变化时，自动化测试脚本也需要进行修改，会增加测试的工作量。
  * **测试质量依赖性强**
    * 自动化测试的效果在很大程度上取决于测试脚本的质量。
    * 如果测试脚本设计得不合理或者存在缺陷，那么自动化测试的结果可能也会存在问题。

  * **技术门槛高**
    * 自动化测试需要测试人员具备一定的编程能力，能够编写和维护测试脚本
    * 这对于一些非技术背景的测试人员来说，可能会有一定的难度。



* **适用场景**

  * **需求稳定的项目**：当软件需求相对稳定，不经常发生变动时，自动化测试可以更加有效地实施。

  * **UI界面变动少**：如果用户界面（UI）设计稳定，不会频繁更改，自动化测试脚本的维护成本会降低，使得自动化测试更加可行。

  * **项目周期长**：对于长期项目，自动化测试可以在项目的整个生命周期中持续提供价值，通过不断的回归测试来确保软件质量。

  * **大量的回归测试**：在需要进行大量回归测试的情况下，自动化测试可以大幅度提高效率和准确性。

    <img src="img/image-20240221120133956.png" alt="image-20240221120133956" style="zoom:50%;" />

* **不适用的场景**：

  - **需求频繁变更的项目**：如果项目的需求经常变动，那么自动化测试脚本也需要不断地更新，这会增加维护成本。
  - **初创期的产品**：对于处于初创阶段的产品，由于功能和界面可能会有很大的变动，自动化测试可能不是最佳选择。
  - **一次性或短期项目**：对于只需要运行一次或短期的测试项目，建立自动化测试可能不值得，因为其回报周期较长。















#### 第2集 【面试高频】Web UI自动化技术解决方案选择和思考

**简介：Web UI自动化技术解决方案选择和思考**

* **面试官：WebUI自动化技术解决方案你了解哪些？为什么选择这个框架？**

<img src="img/image-20240221162101053.png" alt="image-20240221162101053" style="zoom:50%;" />

* 业界常见技术解决方案

  * **Selenium**

    * 是一个广泛使用的Web UI自动化测试工具 ，适合进行大规模的回归测试、跨浏览器和跨平台的测试

    * 支持多种浏览器（如Chrome、Firefox、Safari等）和操作系统（如Windows、Linux、macOS等）

    * **优点**：

      - 支持多种浏览器和操作系统。
      - 丰富的API，可以灵活地操作页面元素。
      - 社区活跃，有大量的教程和资料可供参考。

      **缺点**：

      - 学习曲线较陡峭，需要一定的编程基础。
      - 对于某些复杂的UI交互，可能需要编写较复杂的脚本。
      - 在某些情况下，可能无法稳定地识别页面元素。

  * **Cypress**

    * 是一个新兴的Web UI测试工具，是基于JavaScript语言的前端自动化测试工具，无需借助外部工具

    * 它强调简单易用和端到端的测试，适合进行UI交互的验证和端到端的测试

    * **优点**：

      - 简单易用，无需编写复杂的脚本。
      - 支持实时重载和调试，便于发现和解决问题。
      - 提供了丰富的断言和匹配器，方便进行UI验证。

      **缺点**：

      - 相对于Selenium，社区较小，资料相对较少。
      - 可能不适合进行大规模的自动化测试。

  * **Puppeteer**
    * 是Google开发的一个Node库，它提供了一个高级API来通过DevTools协议控制Chrome或Chromium。
    * 适合进行Chrome浏览器的自动化测试和操作。
    * **优点**：
      - 基于Chrome浏览器，兼容性好。
      - 提供了丰富的API，可以方便地操作页面元素和模拟用户行为。
      - 支持无头模式，可以在没有浏览器界面的情况下运行。
    * **缺点**：
      - 只支持Chrome浏览器。
      - 对于一些复杂的UI交互，可能需要编写较复杂的脚本

* 回答思路
  * 对内：技术框架满足业务需求，团队多数人员熟悉相关产品
  * 对外：模拟真实用户的交互行为，功能强大，支持多种浏览器和操作系统，社区活跃。
  * 结论
    * 在选择Web UI自动化技术解决方案时，需要根据具体的测试需求、项目规模、团队技能等因素进行综合考虑
    * 同时，也可以考虑将不同的技术结合起来，以充分发挥它们的优势













#### 第3集 Java版Selenium自动化测试框架介绍和原理

**简介：Java版Selenium自动化测试框架介绍和原理**

* Selenium自动化测试框架

  * 是一个用于Web应用程序测试的自动化测试工具

  * 支持多种浏览器（如Chrome、Firefox、Safari等）和操作系统（如Windows、Linux、macOS等），

  * 提供了一个丰富的API，允许用户模拟真实用户的交互行为，如点击、输入、提交等

  * 官网：https://www.selenium.dev

  * 特点

    * **跨平台与多浏览器支持**：Selenium可以在不同的操作系统和浏览器上运行，提供了广泛的兼容性。
    * **开源与免费**：Selenium是一个开源项目，用户可以免费地使用其中的工具和库。
    * **强大的API**：Selenium提供了丰富的API，允许用户进行复杂的页面操作和验证。
    * **支持自动化测试**：Selenium可以模拟真实用户的交互行为，从而进行自动化测试，提高测试效率。
    * **集成与扩展性**：可以与其他测试工具（如Jenkins）和编程语言（如Python、Java等）集成，提供了很好的扩展性。

  * **优点**：

    1. **灵活性**：Selenium提供了丰富的API，用户可以根据自己的需求进行定制化的测试。
    2. **开源与免费**：Selenium是一个开源项目，用户可以免费地使用其中的工具和库，降低了测试成本。
    3. **跨平台与多浏览器支持**：Selenium可以在不同的操作系统和浏览器上运行，提供了广泛的兼容性。

    **缺点**：

    1. **学习曲线陡峭**：对于初学者来说，Selenium的学习成本可能较高，需要掌握一定的编程和测试知识。
    2. **性能问题**：由于Selenium模拟真实用户的交互行为，所以相比于传统的性能测试工具，其执行速度可能较慢。
    3. **对页面结构敏感**：Selenium的脚本编写通常依赖于页面的DOM结构，如果页面结构发生变化，需要相应地更新测试脚本。

* **Selenium框架的原理**

  * 通过WebDriver与浏览器进行交互，WebDriver是一个API和协议，定义了用于控制Web浏览器行为的接口。
  * Selenium通过调用WebDriver接口方法完成对浏览器的操作，如点击、输入、提交等。
  * 这些操作都通过HTTP请求发送给浏览器驱动，浏览器驱动再转发给浏览器执行。

  ![image-20240221180516657](img/image-20240221180516657.png)

* **Selenium框架的使用步骤**

  * **环境搭建**（最多人踩坑的地方-**浏览器版本和驱动版本对应关系**）
    * 安装Selenium库，不同语言采用不同依赖包安装
    * 下载与浏览器对应的WebDriver，如ChromeDriver或GeckoDriver，并**确保它们与浏览器版本匹配。**
    * 【强调三遍！！！！】**浏览器版本一定要和驱动版本一一对应，不然存在不兼容问题**
  * **编写测试脚本**
    * 使用Selenium提供的API编写测试脚本
    * 通常包括启动WebDriver、打开浏览器、执行用户请求（如点击按钮、填写表单等）、获取页面元素等操作。
  * **运行测试脚本**
    * 将脚本文件与WebDriver和浏览器一起运行，以执行自动化测试。
  * **分析结果**
    * 根据测试结果分析潜在的问题和缺陷，并进行相应的修复和优化

   













#### 第4集 Win11+JDK17+Selenium4.X+Chrome环境安装实战

**简介：Window版本Java版Selenium环境安装实战**

* 环境说明
  * **课程演示环境版本：Win11系统+JDK17+Maven3.9+Selenimum4.X**
  * **注意：如果安装失败，可以搜索下博文参考，每个人系统和浏览器版本不一样，有win8,win10,win11，根据关键词搜索即可**

* 驱动相关注意事项（如果驱动版本太新，可以降低版本验证）

  * 浏览器版本：122.0.6261.58

  ![image-20240221191942550](img/image-20240221191942550.png)

  * 驱动版本：122.0.6261.57

* 相关驱动版本下载地址（如果浏览器版本太新找不到驱动，可以降低浏览器版本，如果遇到selenium兼容性问题，统一降低版本）
  * https://registry.npmmirror.com/binary.html?path=chromedriver
  * https://googlechromelabs.github.io/chrome-for-testing/#stable

* 测试代码

  * 增加依赖

    ```
      <dependencies>
            <!-- Selenium -->
            <dependency>
                <groupId>org.seleniumhq.selenium</groupId>
                <artifactId>selenium-java</artifactId>
                <version>4.10.0</version>
            </dependency>
        </dependencies>
    ```

  * 案例测试

    ```
    public class Main {
        public static void main(String[] args) {
        		//指定驱动路径
            System.setProperty("webdriver.chrome.driver","C:\\chromedriver-win64\\chromedriver.exe");
            // 谷歌驱动
            ChromeOptions options = new ChromeOptions();
            // 允许所有请求
            options.addArguments("--remote-allow-origins=*");
    
    				WebDriver webDriver = new ChromeDriver(options);
            // 启动需要打开的网页
            webDriver.get("https://xdclass.net");
    
        }
    }
    ```

    

  















#### 第5集 新版Mac+JDK17+Selenium4.X+Safari安装实战

**简介：Mac版本Java版Selenium环境安装实战**

* 环境说明

  * Mac系统+JDK17+Maven3.9+Selenimum4.X

    <img src="img/image-20240221192730750.png" alt="image-20240221192730750" style="zoom:50%;" />

    <img src="img/image-20240221194618356.png" alt="image-20240221194618356" style="zoom:50%;" />

* 驱动相关注意事项

  * selenium支持多系统多浏览器,在操作chrome或者firefox浏览器时,需要安装相应的驱动.

  * **要操作safari浏览器,也需要下载对应的驱动,但是safari浏览器已经帮助我们安装好了,所以只需要做一些配置即可**

  * safari本身集成safaridriver，在Safari的“开发”菜单中启用“允许远程自动化”选项 ，才能通过WebDriver控制Safari，否则会报错

    ```
    Could not create a session: You must enable the 'Allow Remote Automation' option in Safari's Develop menu to control Safari via WebDriver."
    ```

  * selenium启动safari浏览器，需要先打开safari允许自动化开关

  * 步骤

    * 菜单栏点击Safari 浏览器->偏好设置 ->高级 ->勾选-在菜单栏中显示“开发”菜单

    ![image-20240221193344313](img/image-20240221193344313.png)

    * 菜单栏点击开发 ->勾选“允许远程自动化”

    ![image-20240221193420841](img/image-20240221193420841.png)

* 测试代码

  * 增加依赖

    ```
      			<dependency>
                <groupId>org.seleniumhq.selenium</groupId>
                <artifactId>selenium-java</artifactId>
            </dependency>
    ```

  * 案例测试

    ```
    public class TestMain {
        /**
         * 主方法入口
         * @param args 命令行参数
         */
        public static void main(String[] args) {
            // 创建一个Safari驱动实例
            WebDriver webDriver = new SafariDriver();
            // 最大化浏览器窗口
            webDriver.manage().window().maximize();
            // 打开"https://xdclass.net"网址
            webDriver.get("https://xdclass.net");
        }
    
    }
    ```

    

* 作业：可以配置Mac系统操作Firefox或者Chrome浏览器，搜索博文资料参考













#### 第6集 新版Mac+JDK17+Selenium4.X+谷歌浏览器安装

**简介：新版Mac+JDK17+Selenium4.X+谷歌浏览器安装**

* 环境说明
  * Mac系统+JDK17+Maven3.9+Selenimum4.X+Chrome

* 驱动相关注意事项

  * 浏览器版本

  ![image-20240223102553785](img/image-20240223102553785.png)

  * 驱动版本下载
    * 114之前的驱动版本下载地址：https://chromedriver.storage.googleapis.com/index.html
    * 117之后的驱动版本下载地址：https://googlechromelabs.github.io/chrome-for-testing

  ![image-20240223103611469](img/image-20240223103611469.png)

* 测试代码

  * 增加依赖

    ```
      			<dependency>
                <groupId>org.seleniumhq.selenium</groupId>
                <artifactId>selenium-java</artifactId>
            </dependency>
    ```

  * 案例测试

    ```
    public class TestMain {
        /**
         * 主方法入口
         * @param args 命令行参数
         */
        public static void main(String[] args) {
            // 创建一个Safari驱动实例
            //WebDriver webDriver = new SafariDriver();
            System.setProperty("webdriver.chrome.driver", "/Users/xdclass/Desktop/coding/chromedriver-mac-arm64/chromedriver");
            ChromeOptions options = new ChromeOptions();
            // 允许所有请求
            options.addArguments("--remote-allow-origins=*");
            WebDriver webDriver = new ChromeDriver(options);
    
            // 最大化浏览器窗口
            webDriver.manage().window().maximize();
            // 打开"https://xdclass.net"网址
            webDriver.get("https://xdclass.net");
        }
    
    }
    ```

  * 配置问题说明

    * 首次使用会提示安全问题，打开系统偏好设置，安全性与隐私里面，找到任何来源。

<img src="img/image-20240223103356029.png" alt="image-20240223103356029" style="zoom:30%;" />

<img src="img/image-20240223103339916.png" alt="image-20240223103339916" style="zoom:50%;" />











![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第二十五章 Java版本Selenium4.X UI元素定位实战



#### 第1集 自动化测试Chrome调试工具和Selenium4.X定位

**简介：自动化测试Chrome调试工具和Selenium4.X定位**

* 调试工具和基础知识说明

  * 不管是爬虫还是Web的UI自动化测试，需要查找和识别UI元素.

  * 所以需要了解HTML, CSS和Javascript的一些知识, 还需要学会使用各种浏览器的调试功能

  * 谷歌浏览器页面调试工具

    * Google Chrome 自带Web开发调试工具

    ![image-20240223104613684](img/image-20240223104613684.png)

    * 拷贝对应的元素的xpath路径

    ![image-20240223104734009](img/image-20240223104734009.png)

  * 其他工具：Firefox 的firebug插件

* 自动化测试步骤

  ![image-20240223151448158](img/image-20240223151448158.png)

  * Selenium常见的元素定位方式概述

  | 定位方法             | Java语言实现实例                                             |
  | -------------------- | ------------------------------------------------------------ |
  | id 定位              | driver.findElement(By.id(“id的值”))；                        |
  | name定位             | driver.findElement(By.name(“name的值”))；                    |
  | 链接的全部文字定位   | driver.findElement(By.linkText(“链接里面的的全部文字”))；    |
  | 链接的部分文字定位   | driver.findElement(By.partialLinkText(“链接里面的部分文字”))； |
  | css 方式定位         | driver.findElement(By.cssSelector(“css表达式”))；            |
  | xpath 方式定位       | driver.findElement(By.xpath(“xpath表达式”))；                |
  | Class 名称定位       | driver.findElement(By.className(“class属性”))；              |
  | TagName 标签名称定位 | driver.findElement(By.tagName(“标签名称”))；                 |

















#### 第2集 Selenium4.X元素定位之ID和Name案例实操

**简介：Selenium4.X元素定位之ID和Name案例实操**

* 元素定位方法说明

  * 在使用webdriver进行元素定位时,通常用`findElement`或`findElements`方法结合By类返回元素句柄来定位元素
  * findElement() 方法返回一个元素, 如果没有找到,会抛出一个异常 NoElementFindException()
  * findElements()方法返回多个元素, 如果没有找到,会返回空数组, 不会抛出异常

* **Selenium4元素定位之ID方式**

  * **ID元素定位**
    - HTML中的每个元素都可以设置一个唯一的ID属性。通过该属性 可以精确地定位到页面上的某个元素。
    - 在Selenium中，使用`findElement(By.id(“id的值”))；`方法可以根据元素的ID进行定位。
  * **注意事项**：
    - ID应该是唯一的，因此在页面上不应该有两个或更多的元素具有相同的ID。
    - 如果元素的ID发生了改变，或者页面上没有该ID的元素，那么定位会失败。

  * 案例实操

    ```
    public static void main(String[] args) throws InterruptedException {
            System.setProperty("webdriver.chrome.driver", "/Users/xdclass/Desktop/coding/chromedriver-mac-arm64/chromedriver");
            ChromeOptions options = new ChromeOptions();
            // 允许所有请求
            options.addArguments("--remote-allow-origins=*");
            WebDriver webDriver = new ChromeDriver(options);
            // 最大化浏览器窗口
            webDriver.manage().window().maximize();
            idTest(webDriver);
        }
    
        public static void idTest(WebDriver webDriver) throws InterruptedException {
            webDriver.get("https://xdclass.net");
            TimeUnit.SECONDS.sleep(2);
            // 利用id定位元素:输入框,并在输入框中输入:小滴课堂
            //sendKeys在对象上模拟按键输入内容
            webDriver.findElement(By.id("rc_select_0")).sendKeys("小滴课堂");
        }
    ```

    

* **Selenium4元素定位之Name方式**

  * **Name元素定位**

    * 在HTML中，某些元素（如`<input>`, `<button>`, `<select>`等）可以设置一个Name属性。
    * 虽然Name属性不必唯一，但在某些情况下，它可以用于定位特定的元素。
    * 在Selenium中，使用`findElement(By.name(“name的值”))；`方法可以根据元素的Name属性进行定位

  * **注意事项**：

    - Name属性不必唯一，可能存在多个元素具有相同的Name，默认只会返回第一个匹配的元素。
    - 如果页面上的元素没有设置Name属性，或者Name属性的值发生了改变，那么定位会失败

  * 案例实操

    ```
        public static void nameTest(WebDriver webDriver){
            webDriver.get("https://www.baidu.com");
            webDriver.findElement(By.name("wd")).sendKeys("小滴课堂官网");
        }
    ```

    







#### 第3集 Selenium4.X元素定位之链接和Class案例实操

**简介：Selenium4.X元素定位之链接和class案例实操**

* **Selenium4元素定位之链接方式**

  * 通过超链接上的文字信息来定位元素，包括通过链接的全部文字和部分文字进行定位。

  * **链接的全部文字定位**

    * 当链接的完整文本是唯一的，想要定位这个链接时，可以使用`By.linkText`方法
    * `By.linkText("完整的链接文本")`用于查找页面上文字完全匹配的链接。
    * 案例操作

    ```
    public static void linkTest(WebDriver webDriver) throws InterruptedException {
            webDriver.get("https://xdclass.net");
            TimeUnit.SECONDS.sleep(2);
            WebElement webElement = webDriver.findElement(By.linkText("课程中心"));
            String text = webElement.getText();
            System.out.println(text);
            //点击元素
            webElement.click();
        }
    ```

  * **链接的部分文字定位**

    * 当链接的文本不是唯一的，想基于部分文本来定位链接时，可以使用`By.partialLinkText`方法。
    * `By.partialLinkText("部分链接文本")`用于查找页面上文字包含指定文本的链接。
    * 案例操作

    ```
    public static void partialLinkTest(WebDriver webDriver) throws InterruptedException {
            webDriver.get("https://xdclass.net");
            TimeUnit.SECONDS.sleep(2);
            WebElement webElement = webDriver.findElement(By.partialLinkText("课程"));
            String text = webElement.getText();
            System.out.println(text);
            //点击元素
            webElement.click();
        }
    ```

  * 注意事项

    * 确保链接的文本或部分文本是唯一的，否则可能会定位到错误的元素。
    * 当页面包含多个符合条件元素时
      * findElement方法只会返回第一个查找到的元素，而不会返回所有符合条件的元素
      * 如果想要获得所有符合条件的元素，还是只能用findElements方法
    * 链接的文本是区分大小写的，确保在定位时使用了正确的大小写。
    * 如果页面上的链接动态变化或者链接的文本是通过JS生成的，需要使用其他定位策略或等待机制
      * 如显式等待或隐式等待来确保元素正确加载后再进行定位。

  

* **Selenium4元素定位之Class方式**

  * 通过元素属性class定位元素，查找一个或一组显示效果相同的页面元素 `driver.findElement(By.className(“class属性”))；`

  * 案例讲解

    * HTML代码

      ```
      <a class="reg" href="https://api.xdclass.net/api/regisgter">注册</a>
      ```

    * 语法代码

      ```
      WebElement element = driver.findElement(By.className( "reg")); 
      ```

    * 代码实战

      ```
       public static void classTest(WebDriver webDriver) throws InterruptedException {
              webDriver.get("https://xdclass.net");
              TimeUnit.SECONDS.sleep(2);
              List<WebElement> elements = webDriver.findElements(By.className("title"));
              System.out.println("size======="+elements.size());
              for (WebElement element : elements) {
                  String text = element.getText();
                  System.out.println(text);
              }
          }
      ```

      

  









#### 第4集 Selenium4.X元素定位之XPath案例实操

**简介：Selenium4.X元素定位之XPath案例实操**

* 什么是XPath

  * XPath（XML Path Language）是一种在XML文档中查找信息的语言，也可以用于HTML
  * XPath提供了非常强大的定位能力，可以定位到几乎任何元素。
  * 语法案例（更多语法搜索博文资料  https://www.w3school.com.cn/xpath/index.asp）

  | 表达式   | 描述                                 | 实例                | 案例说明                  |
  | -------- | ------------------------------------ | ------------------- | ------------------------- |
  | nodename | 选取nodename节点的所有子节点         | xpath(‘//div’)      | 选取了div节点的所有子节点 |
  | /        | 从根节点选取                         | xpath(‘/div’)       | 从根节点上选取div节点     |
  | //       | 选取所有的当前节点，不考虑他们的位置 | xpath(‘//div’)      | 选取所有的div节点         |
  | .        | 选取当前节点                         | xpath(‘./div’)      | 选取当前节点下的div节点   |
  | ..       | 选取当前节点的父节点                 | xpath(‘..’)         | 回到上一个节点            |
  | @        | 选取属性                             | xpath（’//@class’） | 选取所有的class属性       |

  | 通配符 | 描述                 |
  | :----- | :------------------- |
  | *      | 匹配任何元素节点。   |
  | @*     | 匹配任何属性节点。   |
  | node() | 匹配任何类型的节点。 |

  | 路径表达式  | 结果                            |
  | :---------- | :------------------------------ |
  | /video/*    | 选取 video 元素的所有子元素。   |
  | //*         | 选取文档中的所有元素。          |
  | //title[@*] | 选取所有带有属性的 title 元素。 |

* **Selenium4元素定位之XPath方式**
  * HTML文档本身就是一个标准的XML页面，可以使用Xpath 的用法来定位页面元素
  * 有两种路径定位方式
    * 绝对路径
      * 以 "/"  开头， 让xpath 从文档的根节点开始解析
      * 如果页面结构发生改变，改路径也随之失效，必须重新配置
    * 相对路径
      * 以"//" 开头， 让xpath 从文档的任何元素节点开始解析
      * 推荐采用这个方式，结合适合的元素，则通用性更好
  * **注意事项**
    * webdriver会将整个页面的元素扫描定位所需要的元素，如果大量使用xpath做元素定位的话， 脚本的执行速度可能会稍慢

* 案例实操

  ```
   public static void xpathTest(WebDriver webDriver) throws InterruptedException {
          webDriver.get("https://xdclass.net");
          TimeUnit.SECONDS.sleep(2);
          List<WebElement> elements = webDriver.findElements(By.xpath("//*[@class=\"title\"]"));
          System.out.println("size======="+elements.size());
          for (WebElement element : elements) {
              String text = element.getText();
              System.out.println(text);
          }
      }
  ```

  











#### 第5集 Selenium4.X元素定位之CSS和TagName案例实操

**简介：Selenium4.X元素定位之CSS选择器案例实操**

* **Selenium4元素定位之CSS选择器方式**

  * selenium中的css定位，是通过css选择器来定位到具体元素，css选择器来自于css语法
  * css相较与xpath选择元素：表达式更加简洁，一般情况css的运行速度是优于xpath的。
  * 常见的选择器包括：
    - 标签：直接使用标签名,如下列：p
    - 类（class)：“.”（英文句号）+class值
    - id：“#”+id值*
    - 通配符：意为匹配所有元素， 用“*”表示
  * 使用CSS选择器定位元素案例说明

  ```
  // 通过类名定位  
  WebElement elementByClassName = driver.findElement(By.cssSelector(".class-name"));  
  // 通过ID定位（虽然通常使用By.id更直接）  
  WebElement elementById = driver.findElement(By.cssSelector("#element-id"));  
  // 通过标签名定位  
  WebElement elementByTagName = driver.findElement(By.cssSelector("div"));  
  // 通过属性定位  
  WebElement elementByAttribute = driver.findElement(By.cssSelector("input[name='input-name']"));    
  ```

  

  * 案例实操

  ```
   public static void cssTest(WebDriver webDriver) throws InterruptedException {
          webDriver.get("https://xdclass.net");
          TimeUnit.SECONDS.sleep(2);
          List<WebElement> elements = webDriver.findElements(By.cssSelector("div[class='title']"));
          System.out.println("size======="+elements.size());
          for (WebElement element : elements) {
              String text = element.getText();
              System.out.println(text);
          }
      }
  ```

* **Selenium4元素定位之TagName选择器方式**

  * 标签名定位方式主要用于匹配多个页面元素的情况，将找到的页面元素对象进行计数、遍历

  * HTML的本质就是通过tag来定义实现不同的功能，每一个元素本质上也是一个tag。

  * 通过方法`driver.findElement(By.tagName(“标签名称”))；` 进行操作

  * **注意事项**

    * tag往往用来定义一类功能和布局，通过tag识别某个元素的概率很低。
    * 如页面存在大量的< div >,< input >,< a >等tag

  * 案例讲解

    * HTML源码

      ```
      <a name="search" href="http://www.baidu.com/setting/preferences.html">搜索设置</a>
      <a href="http://www.baidu.com">baidu搜索</a>
      ```

    * java代码

      ```
      WebElement element=driver.findElement(By.tagName("a"));
      List<WebElement> elements= driver.findElements(By.tagName(a));
      ```

      

  













![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第二十六章 Java版本Selenium4.X WebDriver案例操作



#### 第1集 Selenium4.X的WebDriver对象API操作介绍

**简介：Selenium4.X的WebDriver对象API操作介绍**

* 需求

  * 通过WebDriver获取元素对象后，需要进行相关操作
  * 比如点击，提交，输入内容，清空等

* 元素对象API操作语法

  * WebElement对象常用API

  |     方法     | 说明                   |
  | :----------: | ---------------------- |
  |    click     | 点击对象               |
  |   sendKeys   | 在对象上模拟按键输入   |
  |    clear     | 清除对象输入的文本内容 |
  |    submit    | 提交,比如表单对象      |
  | getAttribute | 获取元素的指定属性     |
  |   getText    | 用于获取元素的文本信息 |

  * 备注
    * submit 用于对信息进行提交，也可以使用click 进行代替
    * submit要求提交对象是一个表单，click 更强调事件的独立性

  * WebDriver对象常用API

  |     方法      | 说明                    |
  | :-----------: | ----------------------- |
  |   getTitle    | 用于获得当前页面的title |
  | getCurrentUrl | 用户获得当前页面的URL   |

* 案例实战

  ```
  public static void webEleTest(WebDriver webDriver)throws InterruptedException {
          //启动需要打开的网页
          webDriver.get("https://www.baidu.com");
          String title = webDriver.getTitle();
          String currentUrl = webDriver.getCurrentUrl();
          System.out.println("title="+title+",currentUrl="+currentUrl);
          
          TimeUnit.SECONDS.sleep(2);
  
          //输入元素 sendKey
          webDriver.findElement(By.id("kw")).sendKeys("小滴课堂官网");
          TimeUnit.SECONDS.sleep(2);
  
          //清除元素  clear
          webDriver.findElement(By.id("kw")).clear();
  
          TimeUnit.SECONDS.sleep(2);
          webDriver.findElement(By.id("kw")).sendKeys("苹果手机");
  
          //点击元素  click
          webDriver.findElement(By.id("su")).click();
          TimeUnit.SECONDS.sleep(2);
  
          webDriver.findElement(By.id("kw")).clear();
          webDriver.findElement(By.id("kw")).sendKeys("苹果手机最新款");
          //提交元素  submit
          webDriver.findElement(By.id("su")).submit();
          String text = webDriver.findElement(By.id("su")).getAttribute("value");
          System.out.println("text======"+text);
      }
  ```

  















#### 第2集 Selenium4.X的浏览器和鼠标操作案例实战

**简介：Selenium4.X的浏览器和鼠标操作案例实战**

* 需求
  * 浏览器操作网页，有前进、后退，不同网页直接切换，窗口最大化、刷新等
  * 鼠标操作的时候，有右击、双击、悬停、拖动等
  * 通过Selenium的api完成上述的操作案例

* 浏览器案例

  * API语法

  | 方法                           | 说明               |
  | ------------------------------ | ------------------ |
  | back                           | 模拟浏览器后退按钮 |
  | forward                        | 模拟浏览器前进按钮 |
  | refresh                        | 刷新页面（F5）     |
  | maximize                       | 浏览器最大化       |
  | setSize                        | 浏览器宽高         |
  | manage( ).window( ).setSize( ) | 设置浏览器的大小   |

  * 案例操作

  ```
  public static void browserTest(WebDriver webDriver)throws InterruptedException {
          //打开网页
          webDriver.get("https://www.baidu.com");
          //输入小滴课堂官网
          webDriver.findElement(By.cssSelector("#kw")).sendKeys("小滴课堂官网");
          //点击搜索
          webDriver.findElement(By.cssSelector("#su")).click();
          //浏览器刷新
          TimeUnit.SECONDS.sleep(2);
          webDriver.navigate().refresh();
          //浏览器后退一步
          TimeUnit.SECONDS.sleep(2);
          //加个休眠时间
          webDriver.navigate().back();
          //浏览器前进
          TimeUnit.SECONDS.sleep(2);
          webDriver.navigate().forward();
          TimeUnit.SECONDS.sleep(2);
          //浏览器窗口按照指定大小来显示
          webDriver.manage().window().setSize(new Dimension(300,300));
          TimeUnit.SECONDS.sleep(2);
          //浏览器全屏
          webDriver.manage().window().fullscreen();
      }
  ```

  

* 鼠标案例

  * API语法

  | 方法            | 说明                        |
  | --------------- | :-------------------------- |
  | contextClick( ) | 右击                        |
  | clickAndHold( ) | 鼠标点击并控制              |
  | doubleClick( )  | 双击                        |
  | dragAndDrop( )  | 拖动                        |
  | release( )      | 释放鼠标                    |
  | perform( )      | 执行所有Actions中存储的行为 |

  * 案例操作

  ```
   public static void mouseTest(WebDriver webDriver)throws InterruptedException {
          //打开网页
          webDriver.get("https://www.baidu.com");
          //输入小滴课堂官网
          webDriver.findElement(By.cssSelector("#kw")).sendKeys("小滴课堂官网");
          //点击百度一下的按钮
          webDriver.findElement(By.cssSelector("#su")).click();
          TimeUnit.SECONDS.sleep(2);
          //找到文库的text的tab
          WebElement webElement = webDriver.findElement(By.cssSelector("#s_tab > div > a.s-tab-item.s-tab-wenku"));
          TimeUnit.SECONDS.sleep(2);
          //鼠标右击
          Actions actions = new Actions(webDriver);
          actions.moveToElement(webElement).contextClick().perform();
      }
  ```

  















#### 第3集 多网页窗口案例-Selenium4.X的窗口切换实战

**简介： 多网页窗口案例-Selenium4.X的窗口切换实战**

* 需求
  * 自动化测试过程中会有打开不同网页的操作
  * 网页操作时会打开新窗口，不同窗口需要如何进行切换？

* 不同窗口的切换

  * 自动化脚本通过识别浏览器窗口的属性用句柄handle来识别不同窗口
  * 窗口句柄handle是窗口的唯一标识，是窗口的唯一ID
  * 通过 `webDriver.getWindowHandles()` 获取窗口全部具柄
  * 默认是第一个打开窗口，通过 `webDriver.switchTo().window()` 传入某个窗口句柄，切换到对应窗口
  * 案例实战

  ```
   public static void windowTest(WebDriver webDriver)throws InterruptedException {
          //打开网页
          webDriver.get("https://www.baidu.com");
          String currentHandle = webDriver.getWindowHandle();
  				System.out.println("currentHandle===="+currentHandle);
          //点击百度的新闻页面
          webDriver.findElement(By.cssSelector("#s-top-left > a:nth-child(1")).click();
          // getWindowHandles获取全部窗口句柄
          Set<String> handles = webDriver.getWindowHandles();
          String newHandle = "";
          for(String handle : handles){
              System.out.println("handle===="+handle);
              //记录最后一个窗口的具柄
              newHandle = handle;
          }
          TimeUnit.SECONDS.sleep(2);
          //切换到新窗口，没调用默认还是第一个窗口，则定位新闻窗口的输入框元素会失败
          webDriver.switchTo().window(newHandle);
          //定位新闻窗口的输入框
          webDriver.findElement(By.id("ww")).sendKeys("小滴课堂");
      }
  ```















#### 第4集【保留现场】Selenium4.X的快照截图案例实战

**简介：Selenium4.X的快照截图案例实战**

* 需求
  * 自动化测试的时候，没有人工进行观看，用例执行失败如何进行发现？
  * 如果遇到有错误信息等，如何保存当前页面的截图，方便后续排查？

* 网页快照截图

  * 自动化测试的时候由代码编写程序控制网页去执行，但是具体页面是否正常，元素正确判断可以通过截图进行快照保留
  * 通过API ` (TakesScreenshot) webDriver).getScreenshotAs(OutputType.FILE)`

  ```
   public static void screenshotTest(WebDriver webDriver)throws Exception {
          //打开网页
          // 打开百度首页
          webDriver.get("https://www.baidu.com");
          // 在搜索框中输入“小滴课堂官网”
          webDriver.findElement(By.cssSelector("#kw")).sendKeys("小滴课堂官网");
          // 点击搜索按钮
          webDriver.findElement(By.cssSelector("#su")).click();
          // 等待2秒
          TimeUnit.SECONDS.sleep(2);
  
          // 截取当前页面的截图
          File file = ((TakesScreenshot) webDriver).getScreenshotAs(OutputType.FILE);
          // 将截图保存为文件，文件名为UUID加上.png后缀
          FileUtils.copyFile(file, new File(IdUtil.fastSimpleUUID()+".png"));
  
      }
  ```

  



















#### 第5集 Selenium4.X的显示等待和隐式等待案例实战

**简介：Selenium4.X的显示等待和隐式等待案例实战**

* 需求

  * Web应用通常通过异步加载（如Ajax）来动态更新页面内容，页面元素可能不是立即可用的。

  * 当自动化测试脚本尝试访问或操作这些元素时，如果没有等待机制，可能会遇到定位失败、元素状态不正确等异常

  * Selenium4等待主要解决以下问题：

    * **元素加载延迟**
      * 当页面上的某些元素是通过异步请求（如Ajax）加载的，这些元素可能不会立即出现在DOM中。
      * 网络波动或服务器响应延迟，页面上的某些内容可能需要一些时间才能加载。
      * 如果没有等待机制，测试脚本可能会在元素实际可用之前访问它，导致定位失败。

    * **依赖关系**：
      * 测试脚本中的操作可能依赖于前一步的结果或内容。
      * 例如，一个表单提交后，可能需要等待新页面加载完成才能继续执行后续操作。

    * **页面更新**：

      * JavaScript可能会动态更改页面内容，如添加、删除或修改元素。

      * 如果没有等待，测试脚本可能会错过这些变化，导致测试失败。

        

* Selenium 等待元素出现的方式有以下三种
  * 强制等待
    * 即线程休眠，在代码中强制当前正在执行的线程休眠（暂停执行）不管元素有没出现都固定时间
    * 前面案例操作中已经多次使用 `TimeUnit.SECONDS.sleep(2);`
  * **显式等待(Explicit Wait)**
    * 通俗说就是死等，不灵活的等待，在指定的时间内一定要等到某个元素的出现或可操作的状态
    * 如果等不到,就一直等,直到在规定的时间之内都要操作的元素仍没找到,就抛出异常
    * 可以针对特定的元素或一组元素进行等待，提供了更灵活的等待机制，可以等待复杂的条件。
  * **隐式等待 (Implicit Wait)**
    * 设置**全局等待时间，全部查找都会生效**，驱动初始化后就可以配置，在指定时间内轮询DOM，直到找到元素或超时。
    * 一旦设置，在整个WebDriver对象实例的生命周期内都有效。
    * 适用于等待整个页面加载完毕。

* 案例实战

  ```
  public static void waitTest(WebDriver webDriver)throws InterruptedException {
          //启动需要打开的网页
          webDriver.get("https://www.baidu.com");
  
          // 创建显式等待对象，设置最大等待时间为10秒
          WebDriverWait wait = new WebDriverWait(webDriver,Duration.ofSeconds(5));
          // 使用ExpectedConditions定义等待条件，例如元素可见性
          wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("kw")));
  
          //隐式等待,可以用一个不存在的元素位置进行测试
          //webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(5));
          //输入元素 sendKey
          webDriver.findElement(By.id("kw")).sendKeys("小滴课堂官网");
  
          //提交元素  submit
          webDriver.findElement(By.id("su")).submit();
          String text = webDriver.findElement(By.id("su")).getAttribute("value");
          System.out.println("text======"+text);
      }
  ```

  








![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第二十六章 Java版本Selenium4.X WebDriver案例操作



#### 第1集 Selenium4.X的WebDriver对象API操作介绍

**简介：Selenium4.X的WebDriver对象API操作介绍**

* 需求

  * 通过WebDriver获取元素对象后，需要进行相关操作
  * 比如点击，提交，输入内容，清空等

* 元素对象API操作语法

  * WebElement对象常用API

  |     方法     | 说明                   |
  | :----------: | ---------------------- |
  |    click     | 点击对象               |
  |   sendKeys   | 在对象上模拟按键输入   |
  |    clear     | 清除对象输入的文本内容 |
  |    submit    | 提交,比如表单对象      |
  | getAttribute | 获取元素的指定属性     |
  |   getText    | 用于获取元素的文本信息 |

  * 备注
    * submit 用于对信息进行提交，也可以使用click 进行代替
    * submit要求提交对象是一个表单，click 更强调事件的独立性

  * WebDriver对象常用API

  |     方法      | 说明                    |
  | :-----------: | ----------------------- |
  |   getTitle    | 用于获得当前页面的title |
  | getCurrentUrl | 用户获得当前页面的URL   |

* 案例实战

  ```
  public static void webEleTest(WebDriver webDriver)throws InterruptedException {
          //启动需要打开的网页
          webDriver.get("https://www.baidu.com");
          String title = webDriver.getTitle();
          String currentUrl = webDriver.getCurrentUrl();
          System.out.println("title="+title+",currentUrl="+currentUrl);
          
          TimeUnit.SECONDS.sleep(2);
  
          //输入元素 sendKey
          webDriver.findElement(By.id("kw")).sendKeys("小滴课堂官网");
          TimeUnit.SECONDS.sleep(2);
  
          //清除元素  clear
          webDriver.findElement(By.id("kw")).clear();
  
          TimeUnit.SECONDS.sleep(2);
          webDriver.findElement(By.id("kw")).sendKeys("苹果手机");
  
          //点击元素  click
          webDriver.findElement(By.id("su")).click();
          TimeUnit.SECONDS.sleep(2);
  
          webDriver.findElement(By.id("kw")).clear();
          webDriver.findElement(By.id("kw")).sendKeys("苹果手机最新款");
          //提交元素  submit
          webDriver.findElement(By.id("su")).submit();
          String text = webDriver.findElement(By.id("su")).getAttribute("value");
          System.out.println("text======"+text);
      }
  ```

  















#### 第2集 Selenium4.X的浏览器和鼠标操作案例实战

**简介：Selenium4.X的浏览器和鼠标操作案例实战**

* 需求
  * 浏览器操作网页，有前进、后退，不同网页直接切换，窗口最大化、刷新等
  * 鼠标操作的时候，有右击、双击、悬停、拖动等
  * 通过Selenium的api完成上述的操作案例

* 浏览器案例

  * API语法

  | 方法                           | 说明               |
  | ------------------------------ | ------------------ |
  | back                           | 模拟浏览器后退按钮 |
  | forward                        | 模拟浏览器前进按钮 |
  | refresh                        | 刷新页面（F5）     |
  | maximize                       | 浏览器最大化       |
  | setSize                        | 浏览器宽高         |
  | manage( ).window( ).setSize( ) | 设置浏览器的大小   |

  * 案例操作

  ```
  public static void browserTest(WebDriver webDriver)throws InterruptedException {
          //打开网页
          webDriver.get("https://www.baidu.com");
          //输入小滴课堂官网
          webDriver.findElement(By.cssSelector("#kw")).sendKeys("小滴课堂官网");
          //点击搜索
          webDriver.findElement(By.cssSelector("#su")).click();
          //浏览器刷新
          TimeUnit.SECONDS.sleep(2);
          webDriver.navigate().refresh();
          //浏览器后退一步
          TimeUnit.SECONDS.sleep(2);
          //加个休眠时间
          webDriver.navigate().back();
          //浏览器前进
          TimeUnit.SECONDS.sleep(2);
          webDriver.navigate().forward();
          TimeUnit.SECONDS.sleep(2);
          //浏览器窗口按照指定大小来显示
          webDriver.manage().window().setSize(new Dimension(300,300));
          TimeUnit.SECONDS.sleep(2);
          //浏览器全屏
          webDriver.manage().window().fullscreen();
      }
  ```

  

* 鼠标案例

  * API语法

  | 方法            | 说明                        |
  | --------------- | :-------------------------- |
  | contextClick( ) | 右击                        |
  | clickAndHold( ) | 鼠标点击并控制              |
  | doubleClick( )  | 双击                        |
  | dragAndDrop( )  | 拖动                        |
  | release( )      | 释放鼠标                    |
  | perform( )      | 执行所有Actions中存储的行为 |

  * 案例操作

  ```
   public static void mouseTest(WebDriver webDriver)throws InterruptedException {
          //打开网页
          webDriver.get("https://www.baidu.com");
          //输入小滴课堂官网
          webDriver.findElement(By.cssSelector("#kw")).sendKeys("小滴课堂官网");
          //点击百度一下的按钮
          webDriver.findElement(By.cssSelector("#su")).click();
          TimeUnit.SECONDS.sleep(2);
          //找到文库的text的tab
          WebElement webElement = webDriver.findElement(By.cssSelector("#s_tab > div > a.s-tab-item.s-tab-wenku"));
          TimeUnit.SECONDS.sleep(2);
          //鼠标右击
          Actions actions = new Actions(webDriver);
          actions.moveToElement(webElement).contextClick().perform();
      }
  ```

  















#### 第3集 多网页窗口案例-Selenium4.X的窗口切换实战

**简介： 多网页窗口案例-Selenium4.X的窗口切换实战**

* 需求
  * 自动化测试过程中会有打开不同网页的操作
  * 网页操作时会打开新窗口，不同窗口需要如何进行切换？

* 不同窗口的切换

  * 自动化脚本通过识别浏览器窗口的属性用句柄handle来识别不同窗口
  * 窗口句柄handle是窗口的唯一标识，是窗口的唯一ID
  * 通过 `webDriver.getWindowHandles()` 获取窗口全部具柄
  * 默认是第一个打开窗口，通过 `webDriver.switchTo().window()` 传入某个窗口句柄，切换到对应窗口
  * 案例实战

  ```
   public static void windowTest(WebDriver webDriver)throws InterruptedException {
          //打开网页
          webDriver.get("https://www.baidu.com");
          String currentHandle = webDriver.getWindowHandle();
          System.out.println("currentHandle===="+currentHandle);
          //点击百度的新闻页面
          webDriver.findElement(By.cssSelector("#s-top-left > a:nth-child(1")).click();
          // getWindowHandles获取全部窗口句柄
          Set<String> handles = webDriver.getWindowHandles();
          String newHandle = "";
          for(String handle : handles){
              System.out.println("handle===="+handle);
              //记录最后一个窗口的具柄
              newHandle = handle;
          }
          TimeUnit.SECONDS.sleep(2);
          //切换到新窗口，没调用默认还是第一个窗口，则定位新闻窗口的输入框元素会失败
          webDriver.switchTo().window(newHandle);
          //定位新闻窗口的输入框
          webDriver.findElement(By.id("ww")).sendKeys("小滴课堂");
      }
  ```















#### 第4集【保留现场】Selenium4.X的快照截图案例实战

**简介：Selenium4.X的快照截图案例实战**

* 需求
  * 自动化测试的时候，没有人工进行观看，用例执行失败如何进行发现？
  * 如果遇到有错误信息等，如何保存当前页面的截图，方便后续排查？

* 网页快照截图

  * 自动化测试的时候由代码编写程序控制网页去执行，但是具体页面是否正常，元素正确判断可以通过截图进行快照保留
  * 通过API ` (TakesScreenshot) webDriver).getScreenshotAs(OutputType.FILE)`

  ```
   public static void screenshotTest(WebDriver webDriver)throws Exception {
          //打开网页
          // 打开百度首页
          webDriver.get("https://www.baidu.com");
          // 在搜索框中输入“小滴课堂官网”
          webDriver.findElement(By.cssSelector("#kw")).sendKeys("小滴课堂官网");
          // 点击搜索按钮
          webDriver.findElement(By.cssSelector("#su")).click();
          // 等待2秒
          TimeUnit.SECONDS.sleep(2);
  
          // 截取当前页面的截图
          File file = ((TakesScreenshot) webDriver).getScreenshotAs(OutputType.FILE);
          // 将截图保存为文件，文件名为UUID加上.png后缀
          FileUtils.copyFile(file, new File(IdUtil.fastSimpleUUID()+".png"));
  
      }
  ```

  



















#### 第5集 Selenium4.X的显示等待和隐式等待案例实战

**简介：Selenium4.X的显示等待和隐式等待案例实战**

* 需求

  * Web应用通常通过异步加载（如Ajax）来动态更新页面内容，页面元素可能不是立即可用的。

  * 当自动化测试脚本尝试访问或操作这些元素时，如果没有等待机制，可能会遇到定位失败、元素状态不正确等异常

  * Selenium4等待主要解决以下问题：

    * **元素加载延迟**
      * 当页面上的某些元素是通过异步请求（如Ajax）加载的，这些元素可能不会立即出现在DOM中。
      * 网络波动或服务器响应延迟，页面上的某些内容可能需要一些时间才能加载。
      * 如果没有等待机制，测试脚本可能会在元素实际可用之前访问它，导致定位失败。

    * **依赖关系**：
      * 测试脚本中的操作可能依赖于前一步的结果或内容。
      * 例如，一个表单提交后，可能需要等待新页面加载完成才能继续执行后续操作。

    * **页面更新**：

      * JavaScript可能会动态更改页面内容，如添加、删除或修改元素。

      * 如果没有等待，测试脚本可能会错过这些变化，导致测试失败。

        

* Selenium 等待元素出现的方式有以下三种
  * 强制等待
    * 即线程休眠，在代码中强制当前正在执行的线程休眠（暂停执行）不管元素有没出现都固定时间
    * 前面案例操作中已经多次使用 `TimeUnit.SECONDS.sleep(2);`
  * **显式等待(Explicit Wait)**
    * 通俗说就是死等，不灵活的等待，在指定的时间内一定要等到某个元素的出现或可操作的状态
    * 如果等不到,就一直等,直到在规定的时间之内都要操作的元素仍没找到,就抛出异常
    * 可以针对特定的元素或一组元素进行等待，提供了更灵活的等待机制，可以等待复杂的条件。
  * **隐式等待 (Implicit Wait)**
    * 设置**全局等待时间，全部查找都会生效**，驱动初始化后就可以配置，在指定时间内轮询DOM，直到找到元素或超时。
    * 一旦设置，在整个WebDriver对象实例的生命周期内都有效。
    * 适用于等待整个页面加载完毕。

* 案例实战

  ```
  public static void waitTest(WebDriver webDriver)throws InterruptedException {
          //启动需要打开的网页
          webDriver.get("https://www.baidu.com");
  
          // 创建显式等待对象，设置最大等待时间为10秒
          WebDriverWait wait = new WebDriverWait(webDriver,Duration.ofSeconds(5));
          // 使用ExpectedConditions定义等待条件，例如元素可见性
          wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("kw")));
  
          //隐式等待,可以用一个不存在的元素位置进行测试
          //webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(5));
          //输入元素 sendKey
          webDriver.findElement(By.id("kw")).sendKeys("小滴课堂官网");
  
          //提交元素  submit
          webDriver.findElement(By.id("su")).submit();
          String text = webDriver.findElement(By.id("su")).getAttribute("value");
          System.out.println("text======"+text);
      }
  ```

  







![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第二十七章 云测平台-UI自动化测试需求和功能初体验



#### 第1集 Web UI自动化测试进阶平台化思路和需求说明

**简介：Web UI自动化测试进阶平台化思路和需求说明**

* **初级工程师进阶高级工程师或技术组长->自动化脚本如何进行平台化的思路**

  ![image-20240221180516657](img/image-20240221180516657.png)

  * 需求分析和框架选择

    - 定义平台需要支持的测试类型和范围；分析现有自动化测试脚本，找出可以复用的部分。

    - 选择一个合适的自动化测试框架，如Selenium、TestNG等；考虑使用Python、Java语言来构建平台。

  * 设计架构和模块化设计

    - 设计平台的整体架构，包括前端、后端、数据库等部分；确定各个组件之间的通信方式和数据交互格式。

    - 将测试脚本拆分成多个模块，每个模块负责特定的功能或页面操作；确保模块之间的耦合度低，便于维护和扩展。

  * 配置和测试用例管理

    * 建立一个配置管理系统，用于管理测试环境、测试用例、测试数据等配置信息；让用户能够方便地编辑和查看配置信息。
    * 设计一个测试用例管理系统，允许用户创建、编辑、查看和执行测试用例。

  * 测试执行与监控

    - 实现自动化测试的执行功能，能够自动调度测试用例并运行测试脚本。
    - 提供实时监控功能，展示测试进度、测试结果和日志信息。

  * 报告与统计

    - 测试报告生成功能，根据测试结果生成易于阅读的报告；提供统计分析功能，帮助用户了解测试覆盖率、缺陷分布等信息。

  * 文档与培训

    - 编写详细的用户手册和操作指南，帮助用户快速上手平台；提供培训和支持服务，解决用户在使用过程中遇到的问题。

  * 迭代与优化

    - 根据用户反馈和测试结果，不断优化平台功能和性能；定期发布新版本，并提供升级和迁移方案。

<img src="img/image-20240301163711977.png" alt="image-20240301163711977" style="zoom:50%;" />

* Web UI自动化需求说明
  * UI自动化测试-支持多项目切换
  * 项目支持多模块管理，每个模块下面支持多用例
  * 每个用例支持多类型操作步骤录入、测试和执行
  * 支持WebUI自动化测试执行明细查看，包括异常和断言日志等
  * UI自动化测试支持功能包括不限于下面大类，而且需要做到易拓展
    * UI元素定位
      * id定位
      * 链接文本内容定位
      * 全部链接文本内容定位
      * 名称定位
      * 标签名称定位
      * xpath定位
      * 类名定位
      * CSS选择器定位
    * 鼠标操作
      * 鼠标左键点击
      * 鼠标右键点击
      * 鼠标左键双击
      * 鼠标移入元素
      * 鼠标拖拽元素到目标元素
    * 键盘操作
      * 键盘输入
      * 表单提交
      * 清空输入框
    * 浏览器操作
      * 打开窗口
      * 关闭窗口
      * 通过句柄切换窗口
      * 通过索引切换窗口
      * 最大化窗口
      * 设置窗口大小
      * 浏览器前进
      * 浏览器后退
      * 浏览器刷新
    * 断言操作
      * 网页标题相关多案例断言
      * 网页URL相关多案例断言
      * 元素文本相关多案例断言
      * 元素启用相关多案例断言
      * 元素被选中相关多案例断言
    * 等待
      * 强制等待
      * 隐式等待
    * 其他
      * 快照截图和异常步骤下行
    * 浏览器驱动选择
      * 谷歌浏览器
      * 苹果浏览器











#### 第2集 滴云自动化测试平台-UI功能自动化功能演示

**简介：滴云自动化测试平台-UI功能自动化功能演示**

* **Selenium自动化测试步骤**

  ![image-20240223151448158](img/image-20240223151448158.png)

* Web UI功能自动化功能需求演示

  * 录入用例和多案例步骤

  ![image-20240301162322202](img/image-20240301162322202.png)

  * 执行用例和结果概述

  ![image-20240301162332172](img/image-20240301162332172.png)

  * 查看测试报告明细

  ![image-20240301162516596](img/image-20240301162516596.png)

  













#### 第3集 Web UI功能自动化引擎数据库设计和数据字典

**简介： 云测平台-Web UI功能自动化引擎数据库设计**

* 需求
  * 设计WebUI自动化测试的数据库，包括用例模块，用例和多步骤存储
  * 支持多类型UI操作，包括元素定位、断言等，包括后续新增，需要采用**数据字典**进行存储

![image-20240301162322202](img/image-20240301162322202.png)

* 数据库表关系和设计说明

  * ER图概述

  ![image-20240301165557335](img/image-20240301165557335.png)

  * 下载资料 ，使用**【wget】或者【浏览器】远程下载相关依赖包（需要替换群里最新的）**

    ```
    原生资料下载方式(账号 - 密码 - ip地址 - 端口 需要替换群里最新的，其他路径不变)
    wget --http-user=用户名 --http-password=密码 http://ip:端口/dcloud_test/dcloud_ui_sql.zip
    
    #比如 命令行下
    wget --http-user=admin --http-password=xdclass.net888 http://47.115.31.28:9088/dcloud_test/dcloud_ui_sql.zip
    
    # 比如 浏览器直接访问
    http://47.115.31.28:9088/dcloud_test/dcloud_ui_sql.zip
    ```

    

  * 数据库表说明

    * 用例模块管理

    * 用例管理

    * 数据字典

      * 也称为数据字典表或枚举表，用于存储数据库中的标准值或枚举值，这些值通常是某些字段的可能取值
      * 例如省份列表、城市列表、状态代码等，通过使用字典表，可以确保在这些值统一，避免数据冗余和不一致
      * 当需要修改或扩展某些字段的取值时，只需更新字典表，无需修改多个表中的数据，简化了数据维护工作
      * 字典表可以用于实现动态配置功能，例如系统管理员可以通过修改字典表中的值来动态调整系统的某些配置或行为

      















#### 第4集 UI自动化多步骤编排和动态表单设计

**简介： UI自动化多步骤编排测试设计和动态表单设计**

* 需求

  * WebUI自动化测试，一个用例一般不止单独测试某个元素，一个功能测试可能涉及多个操作

    * 比如某个用例功能：需要打开网页，搜索输入，点击搜索，等待，文字断言，搜索结果和获取评分

    ![image-20240301162322202](img/image-20240301162322202.png)

  * 每个UI自动化操作，涉及的输入框数量，字段不一样，而且提交后端字段不一样，如何动态配置生成？

    * 比如 鼠标左键点击操作需要3个输入框，提交后端其他字段；断言又需要其他输入框和绑定字段

    ![image-20240301175501320](img/image-20240301175501320.png)

* 数据库表说明

  * UI用例步骤字段说明

  ![image-20240301175149387](img/image-20240301175149387.png)

* **【重点】字典表extend字段动态表单设计**

  * 不同操作需要显示不同的输入框，提交的时候需要绑定到对应的用例步骤字段上面，需要采用动态表单
  * 动态表单设计
    * 前端运行过程中可以根据某些业务逻辑动态改变表单项的表单
    * 这些内容可以通过后端通过API接口输出表单内容，和前端配合来自动完成
    * 由于表单项可以动态改变，因此当需要修改或增加表单项时，**只需要修改数据库中的表单描述，而无需修改前端代码**
    * 这大大降低了系统的维护成本，并提高了系统的可扩展性，**简化前后端开发工作**，**支持业务逻辑的灵活配置**
    * **JSON数组存储，name字段是显示给用户看，field是提交到后端API时需要绑定的字段，进一步设计还可以加类型和限制等**

![image-20240301175101831](img/image-20240301175101831.png)

















#### 第5集 云测平台-WebUI自动化测试数据库逆向工程

**简介： 云测平台-WebUI自动化测试数据库逆向工程**

* 需求
  * 逆向工程生成数据库相关实体类和基本包结构创建

* 案例实战

  * 逆向工程生成POJO实体类和映射
  * 创建对应的controller和service

  





















#### 第6集 云测平台-数据字典相关接口和数据录入实战

**简介： 云测平台-数据字典相关接口和数据录入实战**

* 需求
  * 开发数据字典相关接口查询，根据多个字典查询
  * 导入相关WebUI自动化测试数据

* 案例实战

  * 开发数据字典查询接口

  

* 导入WebUI自动化测试数据

  * 下载资料 ，使用**【wget】或者【浏览器】远程下载相关依赖包（需要替换群里最新的）**

  ```
  原生资料下载方式(账号 - 密码 - ip地址 - 端口 需要替换群里最新的，其他路径不变)
  wget --http-user=用户名 --http-password=密码 http://ip:端口/dcloud_test/sys_dict.zip
  
  #比如 命令行下
  wget --http-user=admin --http-password=xdclass.net888 http://47.115.31.28:9088/dcloud_test/sys_dict.zip
  
  # 比如 浏览器直接访问
  http://47.115.31.28:9088/dcloud_test/sys_dict.zip
  ```

  



















![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第二十八章 云测平台-UI自动化测试管理模块开发实战



#### 第1集 Web UI自动化测试-分类模块管理开发实战《上》

**简介：Web UI自动化测试-分类模块开发实战《上》**

* 需求

  * 开发Web UI自动化测试模块管理CRUD

  ![image-20240301231846382](img/image-20240301231846382.png)

* 编码实战

  <img src="img/image-20240301231718744.png" alt="image-20240301231718744" style="zoom:50%;" />













#### 第2集 Web UI自动化测试-分类模块管理开发实战《下》

**简介：Web UI自动化测试-分类模块开发实战《下》**

* 需求
  * 开发Web UI自动化测试模块管理CRUD

![image-20240301231846382](img/image-20240301231846382.png)















#### 第3集 Web UI自动化测试-用例模块开发实战

**简介：Web UI自动化测试模块开发实战**

* 需求

  * 开发Web UI自动化测试的用例模块CRUD

  ![image-20240301231939982](img/image-20240301231939982.png)

* 编码实战

  











#### 第4集 Web UI自动化测试-用例步骤管理开发实战

**简介：Web UI自动化测试模块管理开发实战**

* 需求

  * 开发Web UI自动化测试的用例步骤管理模块CRUD

  ![image-20240301232059645](img/image-20240301232059645.png)

* 编码实战

  















#### 第5集 Web UI自动化测试用例执行接口开发实战

**简介：Web UI自动化测试用例执行接口开发实战**

* 需求
  * 开发Web UI自动化测试用例执行接口
  * 流程链路和API接口自动化测试类似，可以参考相关逻辑快速完善

<img src="img/image-20240301233430914.png" alt="image-20240301233430914" style="zoom:50%;" />

* 编码实战

  * **查询用例->查询用例关联的步骤->初始化测试报告->执行自动化测试->响应结果**

  ```
   public JsonData execute(long id, long projectId) {
          LambdaQueryWrapper<UiCaseDO> queryWrapper = new LambdaQueryWrapper<>(UiCaseDO.class)
                  .eq(UiCaseDO::getId, id)
                  .eq(UiCaseDO::getProjectId, projectId);
          UiCaseDO uiCaseDO = uiCaseMapper.selectOne(queryWrapper);
  
          if(uiCaseDO !=null){
              // 获取UI用例关联的UI用例步骤列表
              List<UiCaseStepDO> uiCaseStepDOS = getStepList(id);
              if (uiCaseStepDOS.isEmpty()) {
                  throw new BizException(BizCodeEnum.UI_CASE_STEP_IS_EMPTY);
              }
              //初始化测试报告
              ReportSaveReq reportSaveReq = ReportSaveReq.builder().projectId(uiCaseDO.getProjectId())
                      .caseId(uiCaseDO.getId())
                      .startTime(System.currentTimeMillis())
                      .executeState(ReportStateEnum.EXECUTING.name())
                      .name(uiCaseDO.getName())
                      .type(TestTypeEnum.UI.name()).build();
              JsonData jsonData = reportFeignService.save(reportSaveReq);
              if(jsonData.isSuccess()){
                  ReportDTO reportDTO = jsonData.getData(ReportDTO.class);
  
                  // 执行
                  CaseInfoDTO caseInfoDTO = new CaseInfoDTO();
                  caseInfoDTO.setId(uiCaseDO.getId());
                  caseInfoDTO.setModuleId(uiCaseDO.getModuleId());
                  caseInfoDTO.setName(uiCaseDO.getName());
  
                  UiExecuteEngine uiExecuteEngine = new UiExecuteEngine(reportDTO);
                  UiCaseResultDTO uiCaseResultDTO = uiExecuteEngine.execute(caseInfoDTO,uiCaseDO.getBrowser(), uiCaseStepDOS);
                  return JsonData.buildSuccess(uiCaseResultDTO);
  
              }else {
                  log.error("UI用例执行，初始化测试报告失败,{}",uiCaseDO);
                  return JsonData.buildError("UI接口用例执行，初始化测试报告失败");
              }
          }else {
              return JsonData.buildError("用例不存在");
  
          }
  
      }
  ```

  











![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第二十九章 重点-云测平台UI自动化测试引擎开发实战



#### 第1集 Selenium4.X多浏览器驱动管理封装实战

**简介：Selenium4.X多浏览器驱动管理封装实战**

* 需求
  * 封装工具类获取浏览器驱动，传递不同的浏览器驱动名称，创建不同的驱动对象
  * 现有支持谷歌浏览器、苹果浏览器，可以支持拓展比如支持火狐浏览器
  * 需要支持支持本地调试和Linux服务器版本迭代

* 编码实战

  ```
   public static WebDriver getWebdriver(String driverName) {
  
          String osName = System.getProperty("os.name");
          System.out.println("osName========"+osName);
  
  
          SeleniumWebDriverEnum seleniumWebDriverEnum = SeleniumWebDriverEnum.valueOf(driverName);
          return switch (seleniumWebDriverEnum) {
              // GoogleChrome
              case CHROME -> {
                  ChromeOptions option = new ChromeOptions();
                  //--no-sandbox参数表示禁用沙箱模式，以提高浏览器的兼容性和稳定性。
                  //--disable-dev-shm-usage参数表示禁用/dev/shm的使用，以避免在某些Linux系统中出现的内存不足问题。
                  //--disable-extensions参数表示禁用所有扩展，以防止扩展影响浏览器的性能和稳定性。
                  option.addArguments("--no-sandbox");
                  option.addArguments("--disable-dev-shm-usage");
                  option.addArguments("--disable-extensions");
  
                  if(osName.contains("Mac")){
                      System.setProperty("webdriver.chrome.driver", "/Users/xdclass/Desktop/coding/chromedriver-mac-arm64/chromedriver");
                  }else {
                      option.addArguments("--headless");
                      System.setProperty("webdriver.chrome.driver", "/usr/local/software/chromedriver-linux64/chromedriver");
  
                  }
                  System.setProperty("webdriver.chrome.logfile", "./chromedriver.log");
                  WebDriver webDriver  = new ChromeDriver(option);
                  webDriver.manage().window().maximize();
                  yield webDriver;
              }
  
              // Safari 可视化测试用
              case SAFARI -> {
                  WebDriver webDriver = new SafariDriver();
                  webDriver.manage().window().maximize();
                  yield webDriver;
              }
  
              default ->
                      throw new BizException(BizCodeEnum.UI_UNSUPPORTED_BROWSER_DRIVEN);
          };
      }
  ```

  

















#### 第2集 Selenium驱动上下文传递和元素定位封装

**简介：Selenium驱动上下文传递和元素定位封装**

* 需求

  * **一个用例下面多个步骤，不同步骤之前都会依赖驱动，因此驱动需要随时获取，执行完成后移除**

    * 解决方式：一个方式通过参数传递，另外一种是通过ThreadLocal进行传递

    ![image-20240303141858086](img/image-20240303141858086.png)

  * **元素定位方式多种，需要封装对应的方法，元素定位方法需要默认都是支持显式等待**

* 编码实战

  * 驱动上下文传递工具类

  ```
  public class SeleniumWebdriverContext {
      private static final ThreadLocal<WebDriver> THREAD_LOCAL = new ThreadLocal<>();
  
      public static WebDriver get() {
          return THREAD_LOCAL.get();
      }
  
      public static void set(WebDriver webDriver) {
          THREAD_LOCAL.set(webDriver);
      }
  
      public static void remove() {
          THREAD_LOCAL.remove();
      }
  }
  ```

  * WebUi元素定位工具类

  ```
  public static WebElement findElement(String locationType, String locationExpress, long waitTime) {
          WebDriver webDriver = SeleniumWebdriverContext.get();
          // 元素查找最长等待时间
          WebDriverWait wait = new WebDriverWait(webDriver, Duration.ofMillis(waitTime));
  
          SeleniumByEnum seleniumByEnum = SeleniumByEnum.valueOf(locationType);
          try {
              return switch (seleniumByEnum) {
                  case ID ->
                          wait.until(ExpectedConditions.presenceOfElementLocated(By.id(locationExpress)));
  
                  case LINK_TEXT ->
                          wait.until(ExpectedConditions.presenceOfElementLocated(By.linkText(locationExpress)));
  
                  case PARTIAL_LINK_TEXT ->
                          wait.until(ExpectedConditions.presenceOfElementLocated(By.partialLinkText(locationExpress)));
  
                  case NAME ->
                          wait.until(ExpectedConditions.presenceOfElementLocated(By.name(locationExpress)));
  
                  case TAG_NAME ->
                          wait.until(ExpectedConditions.presenceOfElementLocated(By.tagName(locationExpress)));
  
                  case XPATH ->
                          wait.until(ExpectedConditions.presenceOfElementLocated(By.xpath(locationExpress)));
  
                  case CLASS_NAME ->
                          wait.until(ExpectedConditions.presenceOfElementLocated(By.className(locationExpress)));
  
                  case CSS_SELECTOR ->
                          wait.until(ExpectedConditions.presenceOfElementLocated(By.cssSelector(locationExpress)));
  
                  default ->
                          throw new BizException(BizCodeEnum.UI_OPERATION_UNSUPPORTED_ELEMENT);
              };
          } catch (NoSuchElementException e) {
              // 未找到元素
              throw new BizException(BizCodeEnum.UI_ELEMENT_NOT_EXIST);
          }
      }
  ```

  











#### 第3集 UI自动化测试引擎-用例步骤执行骨架开发

**简介： UI自动化测试引擎-用例步骤执行骨架开发**

* 需求

  * 获取了用例基本信息，驱动还有用例步骤列表，开发对应的方法骨架
  * 业务逻辑和API接口自动化测试类似，也是基于**递归方法**进行执行处理

  ![image-20240303142008025](img/image-20240303142008025.png)

  * 步骤方法包括
    * 驱动获取和上下文配置、统计步骤数量、执行成功和失败数量、用例状态
    * 发送测试报告、释放资源和移除驱动上下文

* 编码实战

  ```
   public UiCaseResultDTO execute(CaseInfoDTO caseInfo, String driverName, List<UiCaseStepDO> stepList) {
          // 获取浏览器驱动并设置上下文
          WebDriver webdriver = SeleniumFetchUtil.getWebdriver(driverName);
          SeleniumWebdriverContext.set(webdriver);
  
          try {
              // 执行步骤数量
              int quantity = stepList.size();
              // 开始时间
              long startTime = System.currentTimeMillis();
              UiCaseResultDTO result = doExecute(null, stepList);
              // 结束时间
              long endTime = System.currentTimeMillis();
  
              result.setReportId(reportDTO.getId());
              result.setStartTime(startTime);
              result.setEndTime(endTime);
              result.setExpendTime(endTime-startTime);
              result.setQuantity(quantity);
  
              int passQuantity = result.getList().stream().filter(item -> {
                  item.setReportId(reportDTO.getId());
                  return item.getExecuteState() && item.getAssertionState();
              }).toList().size();
  
              result.setPassQuantity(passQuantity);
              result.setFailQuantity(quantity-passQuantity);
              result.setExecuteState(Objects.equals(result.getQuantity(), result.getPassQuantity()));
  
              // 发送信息
              resultSenderService.sendResult(caseInfo, TestTypeEnum.UI, JsonUtil.obj2Json(result));
              return result;
  
          } finally {
              try {
                  // 释放资源
                  if (webdriver != null) {
                      TimeUnit.SECONDS.sleep(5);
                      webdriver.quit();
                  }
              } catch (Exception e) {
                  log.error("关闭浏览器驱动异常", e);
              }
              SeleniumWebdriverContext.remove();
          }
      }
  ```

  













#### 第4集 UI自动化用例步骤递归执行和快照截图开发

**简介：  UI自动化用例步骤递归执行和快照截图开发**

* 需求
  * 开发用例步骤递归执行骨架方法，包括以下功能
    * 获取用例步骤，调用步骤类型分配器，封装步骤结果实体类
    * 根据执行情况和异常信息记录日志
    * 根据步骤配置是否失败继续下行执行和截图快照
  * 整体执行逻辑和API接口自动化类似，可以参考类似模型

* 编码实战

  ```
  public UiCaseResultDTO doExecute(UiCaseResultDTO result, List<UiCaseStepDO> stepList) {
          if (result == null) {
              result = new UiCaseResultDTO();
              result.setList(new ArrayList<>());
          }
          if (stepList == null || stepList.isEmpty()) {
              return result;
          }
  
          UiCaseStepDO uiCaseStepDO = stepList.get(0);
          // 步骤信息初始化
          UiCaseResultItemDTO resultItem = new UiCaseResultItemDTO();
          result.getList().add(resultItem);
          UiCaseStepDTO uiCaseStepDTO = SpringBeanUtil.copyProperties(uiCaseStepDO, UiCaseStepDTO.class);
          resultItem.setUiCaseStep(uiCaseStepDTO);
          resultItem.setExecuteState(true);
          resultItem.setAssertionState(true);
  
          try {
              // 开始时间
              long startTime = System.currentTimeMillis();
              // 分配步骤操作
              UiOperationResultDTO uiOperationResultDTO = seleniumDispatcherService.operationDispatcher(uiCaseStepDO);
              uiOperationResultDTO.setOperationType(uiCaseStepDO.getOperationType());
              // 结束时间
              long endTime = System.currentTimeMillis();
  
              // 步骤截图
              if (uiCaseStepDO.getIsScreenshot()) {
                  resultItem.setScreenshotUrl(getScreenshot());
              }
  
              // 设置当前步骤结束信息
              resultItem.setAssertionState(uiOperationResultDTO.getOperationState());
              if(!uiOperationResultDTO.getOperationState()){
                  resultItem.setExceptionMsg("动作:"+uiOperationResultDTO.getOperationType()+",实际内容:"+uiOperationResultDTO.getActualValue()+",期望内容:"+uiOperationResultDTO.getExpectValue());
              }
              resultItem.setExpendTime(endTime - startTime);
              if (!uiOperationResultDTO.getOperationState() && !uiCaseStepDO.getIsContinue()) {
                  // 断言失败且不再继续
                  return result;
              }
          }
          catch (Exception e) {
              // e.printStackTrace();
              resultItem.setExecuteState(false);
              resultItem.setAssertionState(false);
  
              // 记录异常信息
              StringWriter sw = new StringWriter();
              e.printStackTrace(new PrintWriter(sw));
              resultItem.setExceptionMsg(sw.toString());
              // 步骤截图
              if (uiCaseStepDO.getIsScreenshot()) {
                  resultItem.setScreenshotUrl(getScreenshot());
              }
              if(!uiCaseStepDO.getIsContinue()){
                  return result;
              }
          }
  
          // 下轮递归
          stepList.remove(0);
          return doExecute(result, stepList);
      }
  
      public String getScreenshot() {
          WebDriver webDriver = SeleniumWebdriverContext.get();
          File file = ((TakesScreenshot) webDriver).getScreenshotAs(OutputType.FILE);
          try {
              MockMultipartFile mockMultipartFile = new MockMultipartFile(file.getName(), file.getName(), Files.probeContentType(file.toPath()), new FileInputStream(file));
              return fileService.upload(mockMultipartFile);
          } catch (Exception e) {
              throw new RuntimeException(e);
          }
      }
  ```

  













#### 第5集 重点-UI自动化用例步骤执行分配器难点分析

**简介：  重点-UI自动化用例步骤执行分配器难点分析**

* 业务需求分析

  * WebUI自动化测试，涉及多个Operation操作，每个大类下面又有很多小项

  ![image-20240301175101831](img/image-20240301175101831.png)

  * **WebUI用例步骤执行到分发器，分发器里面如何设计比较好？**

  <img src="img/image-20240303154319179.png" alt="image-20240303154319179" style="zoom:50%;" />

  * 解决方案-分治思想

    * **先通过一级类目分发，然后到二级类目再分发，最后到三级类目或者四级类目执行操作**
    * 例子
      * **通过 `operationType` 字段值内容进行分发**
      * 第一个单词即属于大分类，比如BROWSER_OPEN，大分类是 BROWSER；MOUSE_LEFT_CLICK 大分类是MOUSE
    * **后续新增操作的时候需要遵循对应的规范，operationType首单词属于大分类**

    <img src="img/image-20240303154835842.png" alt="image-20240303154835842" style="zoom:50%;" />



















![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第三十章 【重点】云测平台WebUI自动化引擎分发器实战



#### 第1集 Web UI自动化引擎一级大类分发器开发实战

**简介：UI自动化引擎一级大类分发器开发实战**

* 需求
  * 开发一级大类分发器对应的类目骨架方法
  * 配置对应的一级大类枚举实操

* 编码实战

  * 一级大类枚举配置

  ```
  public enum SeleniumOperationEnum {
      /**
       * 归类为浏览器相关操作
       */
      BROWSER,
      /**
       * 归类为鼠标相关操作
       */
      MOUSE,
      /**
       * 归类为键盘相关操作
       */
      KEYBOARD,
      /**
       * 归类为等待相关操作
       */
      WAIT,
      /**
       * 归类为断言相关操作
       */
      ASSERTION,
      /**
       * 归类为断言浏览器相关操作
       */
      ASSERTION_BROWSER,
  
  
      /**
       * 归类为断言元素相关操作
       */
      ASSERTION_ELEMENT,
  
      /**
       * 归类为断言元素文本相关操作
       */
      ASSERTION_ELEMENT_TEXT,
  
      /**
       * 归类为断言元素属性相关操作
       */
      ASSERTION_ELEMENT_ATTRIBUTE;
  }
  ```

  * 分发器骨架方法开发

  ```
   public UiOperationResultDTO operationDispatcher(UiCaseStepDO uiCaseStepDO) {
          String type = uiCaseStepDO.getOperationType();
  
  
          if (type.startsWith(SeleniumOperationEnum.BROWSER.name())) {
              // 浏览器相关操作
              browserOperationDispatcher(uiCaseStepDO);
  
          } else if (type.startsWith(SeleniumOperationEnum.MOUSE.name())) {
              // 鼠标相关操作
              mouseOperationDispatcher(uiCaseStepDO);
  
          } else if (type.startsWith(SeleniumOperationEnum.KEYBOARD.name())) {
              // 键盘相关操作
              keyBoardOperationDispatcher(uiCaseStepDO);
  
          } else if (type.startsWith(SeleniumOperationEnum.WAIT.name())) {
              // 等待相关操作
              waitOperationDispatcher(uiCaseStepDO);
  
          } else if (type.startsWith(SeleniumOperationEnum.ASSERTION.name())) {
              // 断言相关操作
              return assertionOperationDispatcher(uiCaseStepDO);
  
          } else {
              // 不支持的操作类型
              throw new BizException(BizCodeEnum.UI_OPERATION_UNSUPPORTED);
          }
          return UiOperationResultDTO.builder().operationState(true).build();
      }
  ```

  















#### 第2集 Web UI自动化引擎-浏览器组件封装实战《上》

**简介：Web UI自动化引擎-浏览器操作组件封装实战**

* 需求
  * 开发浏览器相关操作分发，封装Selenium具体实现方法
  * 包括不限于
    * 打开窗口、关闭窗口、切换窗口通过句炳、切换窗口通过索引
    * 最大化窗口、后退、刷新、前进和自定义窗口大小

* 编码实战

  * 操作类型枚举配置

  ```
    /**
       * 打开窗口
       */
      BROWSER_OPEN,
  
      /**
       * 关闭窗口
       */
      BROWSER_CLOSE,
  
      /**
       * 切换窗口通过句柄
       */
      BROWSER_SWITCH_BY_HANDLER,
  
      /**
       * 切换窗口通过索引
       */
      BROWSER_SWITCH_BY_INDEX ,
  
      /**
       * 最大化窗口
       */
      BROWSER_MAXIMIZE,
  
      /**
       * 设置窗口大小
       */
      BROWSER_RESIZE,
  
      /**
       * 窗口刷新
       */
      BROWSER_REFRESH,
  
      /**
       * 设置窗口后退
       */
      BROWSER_BACK ,
  
      /**
       * 设置窗口前进
       */
      BROWSER_FORWARD,
  
  ```

  * 编码实战

  ```
  public void browserOperationDispatcher(UiCaseStepDO uiCaseStepDO) {
          SeleniumOperationTypeEnum seleniumOperationTypeEnum = SeleniumOperationTypeEnum.valueOf(uiCaseStepDO.getOperationType());
          switch (seleniumOperationTypeEnum) {
              case BROWSER_OPEN:
                  // 打开窗口
                  seleniumBrowserOperationService.open(uiCaseStepDO.getValue());
                  break;
  
              case BROWSER_CLOSE:
                  // 关闭窗口
                  seleniumBrowserOperationService.close();
                  break;
  
              case BROWSER_SWITCH_BY_HANDLER:
                  // 切换窗口通过句炳
                  seleniumBrowserOperationService.switchByHandle(uiCaseStepDO.getValue());
                  break;
  
              case BROWSER_SWITCH_BY_INDEX:
                  // 切换窗口通过索引
                  seleniumBrowserOperationService.switchByIndex(Integer.parseInt(uiCaseStepDO.getValue()));
                  break;
  
              case BROWSER_MAXIMIZE:
                  // 最大化窗口
                  seleniumBrowserOperationService.resizeMaximize();
                  break;
  
              case BROWSER_BACK:
                  seleniumBrowserOperationService.back();
                  break;
  
              case BROWSER_REFRESH:
                  seleniumBrowserOperationService.refresh();
                  break;
  
              case BROWSER_FORWARD:
                  seleniumBrowserOperationService.forward();
                  break;
  
              case BROWSER_RESIZE:
                  // 设置窗口大小
                  String[] arr = uiCaseStepDO.getValue().split(",");
                  int x = Integer.parseInt(arr[0]);
                  int y = Integer.parseInt(arr[1]);
                  seleniumBrowserOperationService.resize(x, y);
                  break;
  
              default:
                  // 不支持的浏览器操作
                  throw new BizException(BizCodeEnum.UI_OPERATION_UNSUPPORTED_BROWSER);
          }
      }
  ```

  















#### 第3集 Web UI自动化引擎-浏览器组件封装实战《下》

**简介：Web UI自动化引擎-浏览器操作组件封装实战**

* 需求
  * 开发浏览器相关操作分发，封装Selenium具体实现方法
  * 包括不限于
    * 打开窗口、关闭窗口、切换窗口通过句炳、切换窗口通过索引
    * 最大化窗口、后退、刷新、前进和自定义窗口大小
  * 代码链路解读和注释增加

![image-20240304220321769](img/image-20240304220321769.png)

















#### 第4集 云测平台-UI自动化引擎基础链路测试实战

**简介：云测平台-UI自动化引擎基础链路测试实战**

* 需求

  * 前面封装了驱动、用例执行接口、初始化测试报告和浏览器执行明细
  * 基于前面的案例录入基础数据，然后进行链路测试实战

  <img src="img/image-20240303161125620.png" alt="image-20240303161125620" style="zoom:50%;" />

* 案例实战

  * 录入WebUI基础测试数据

  ```
  INSERT INTO `test_engine`.`ui_case` (`id`, `project_id`, `module_id`, `browser`, `name`, `description`, `level`,`gmt_create`, `gmt_modified`) VALUES (13, 1, 28, 'CHROME', '百度搜索用例', '无描述', 'p0', '2026-03-02 06:40:41', '2026-03-02 06:40:41');
  
  INSERT INTO `test_engine`.`ui_case_step` (`id`, `project_id`, `case_id`, `num`, `name`, `operation_type`, `location_type`, `location_express`, `element_wait`, `target_location_type`, `target_location_express`, `target_element_wait`, `value`, `expect_key`, `expect_value`, `description`, `is_continue`, `is_screenshot`, `gmt_create`, `gmt_modified`) VALUES (65, 1, 13, 0, '打课网页', 'BROWSER_OPEN', NULL, NULL, 0, NULL, NULL, 0, 'https://www.baidu.com/', NULL, NULL, NULL, 0, 0, '2024-03-04 14:24:18', '2024-03-04 14:25:02');
  ```

  * WebUI自动化测试用例执行测试











#### 第5集 Web UI自动化引擎-鼠标事件封装实战

**简介：Web UI自动化引擎-鼠标事件封装实战**

* 需求

  * 开发鼠标相关操作分发，封装Selenium具体实现方法

  * 包括不限于

    * 鼠标左键点击、鼠标右键点击、鼠标左键双击

    * 鼠标移入元素、鼠标拖拽元素到目标元素

    * **元素操作定位需要支持显示等待机制，配置等待时间**

      

* 案例实战

  * 操作类型枚举配置

  ```
   /**
       * 鼠标左键点击
       */
      MOUSE_LEFT_CLICK,
  
      /**
       * 鼠标右键右击
       */
      MOUSE_RIGHT_CLICK,
  
      /**
       * 鼠标左键双击
       */
      MOUSE_DOUBLE_CLICK,
  
      /**
       * 鼠标移入元素
       */
      MOUSE_MOVE_TO_ELEMENT,
  
      /**
       * 鼠标拖拽元素到目标元素
       */
      MOUSE_DRAG_ELEMENT_TO_ELEMENT,
  ```

  * 编码实战

  ```
  public void mouseOperationDispatcher(UiCaseStepDO uiCaseStepDO) {
          WebElement webElement = SeleniumFetchUtil.findElement(uiCaseStepDO.getLocationType(), uiCaseStepDO.getLocationExpress(), uiCaseStepDO.getElementWait());
          SeleniumOperationTypeEnum seleniumOperationTypeEnum = SeleniumOperationTypeEnum.valueOf(uiCaseStepDO.getOperationType());
  
          switch (seleniumOperationTypeEnum) {
              case MOUSE_LEFT_CLICK:
                  // 鼠标左键点击
                  seleniumMouseOperationService.leftClick(webElement);
                  break;
  
              case MOUSE_RIGHT_CLICK:
                  // 鼠标右键点击
                  seleniumMouseOperationService.rightClick(webElement);
                  break;
  
              case MOUSE_DOUBLE_CLICK:
                  // 鼠标左键双击
                  seleniumMouseOperationService.doubleClick(webElement);
                  break;
  
              case MOUSE_MOVE_TO_ELEMENT:
                  // 鼠标移入元素
                  seleniumMouseOperationService.moveToElement(webElement);
                  break;
  
              case MOUSE_DRAG_ELEMENT_TO_ELEMENT:
                  // 鼠标拖拽元素到目标元素
                  WebElement targetWebElement = SeleniumFetchUtil.findElement(uiCaseStepDO.getTargetLocationType(), uiCaseStepDO.getTargetLocationExpress(), uiCaseStepDO.getTargetElementWait());
                  seleniumMouseOperationService.dragElementToElement(webElement, targetWebElement);
                  break;
  
              default:
                  // 不支持的鼠标操作
                  throw new BizException(BizCodeEnum.UI_OPERATION_UNSUPPORTED_MOUSE);
          }
      }
  
  
  @Component
  public class SeleniumMouseOperationServiceImpl implements SeleniumMouseOperationService {
      @Override
      public void leftClick(WebElement webElement) {
          webElement.click();
      }
  
      @Override
      public void rightClick(WebElement webElement) {
          Actions actions = new Actions(SeleniumWebdriverContext.get());
          actions.contextClick(webElement)
                  .perform();
      }
  
      @Override
      public void doubleClick(WebElement webElement) {
          Actions actions = new Actions(SeleniumWebdriverContext.get());
          actions.doubleClick(webElement)
                  .perform();
      }
  
      @Override
      public void moveToElement(WebElement webElement) {
          Actions actions = new Actions(SeleniumWebdriverContext.get());
          actions.moveToElement(webElement)
                  .perform();
      }
  
      @Override
      public void dragElementToElement(WebElement source, WebElement target) {
          Actions actions = new Actions(SeleniumWebdriverContext.get());
          actions.dragAndDrop(source, target)
                  .perform();;
      }
  }
  ```

  















#### 第6集 Web UI自动化引擎-键盘事件封装实战

**简介：Web UI自动化引擎-键盘事件封装实战**

* 需求
  * 开发键盘相关操作分发，封装Selenium具体实现方法
  * 包括不限于
    * 键盘输入、表单清空、表单提交
    * **元素操作定位需要支持显示等待机制，配置等待时间**

* 案例实战

  * 操作类型枚举配置

  ```
  
      /**
       * 键盘输入
       */
      KEYBOARD_INPUT,
  
      /**
       * 表单提交
       */
      KEYBOARD_SUBMIT,
  
  
      /**
       * 清空
       */
      KEYBOARD_CLEAR,
  
  ```

  

  * 编码实战

  ```
   @Override
      public void keyBoardOperationDispatcher(UiCaseStepDO uiCaseStepDO) {
          WebElement webElement = SeleniumFetchUtil.findElement(uiCaseStepDO.getLocationType(), uiCaseStepDO.getLocationExpress(), uiCaseStepDO.getElementWait());
          SeleniumOperationTypeEnum seleniumOperationTypeEnum = SeleniumOperationTypeEnum.valueOf(uiCaseStepDO.getOperationType());
  
          switch (seleniumOperationTypeEnum) {
              case KEYBOARD_INPUT:
                  // 键盘输入
                  seleniumKeyboardOperationService.input(webElement, uiCaseStepDO.getValue());
                  break;
  
              case KEYBOARD_CLEAR:
                  // 表单清空
                  seleniumKeyboardOperationService.clear(webElement);
                  break;
  
              case KEYBOARD_SUBMIT:
                  // 表单提交
                  seleniumKeyboardOperationService.submit(webElement);
                  break;
  
              default:
                  // 不支持的键盘操作
                  throw new BizException(BizCodeEnum.UI_OPERATION_UNSUPPORTED_KEYBOARD);
          }
      }
      
  @Service
  public class SeleniumKeyboardOperationServiceImpl implements SeleniumKeyboardOperationService {
      @Override
      public void input(WebElement webElement, String... content) {
          webElement.sendKeys(content);
      }
  
      @Override
      public void clear(WebElement webElement) {
          webElement.clear();
      }
  
      @Override
      public void submit(WebElement webElement) {
          webElement.submit();
      }
  }
  ```

  









#### 第7集 Web UI自动化引擎-等待事件封装实战

**简介：Web UI自动化引擎-等待事件封装实战**

* 需求
  * 开发等待相关操作分发，封装Selenium具体实现方法
  * 包括不限于：隐式等待、强制等待、显式等待

* 操作实战

  * 数据库新增字典

  ```
  INSERT INTO `test_engine`.`sys_dict` (`id`, `category`, `category_name`, `name`, `value`, `extend`, `remark`, `gmt_create`, `gmt_modified`) VALUES (108, 'wait', '等待', '显式等待', 'WAIT_SHOW', '[{\"name\":\"元素定位类型\",\"field\":\"locationType\"},{\"name\":\"元素定位表达式\",\"field\":\"locationExpress\"},{\"name\":\"显示等待(毫秒)\",\"field\":\"value\"}]', NULL, '2024-03-05 03:53:10', '2024-03-05 04:08:53');
  ```

  * 编码案例

  ```
      /**
       * 隐式等待
       */
      WAIT_HIDE,
  
      /**
       * 显式等待
       */
      WAIT_SHOW,
      /**
       * 强制等待
       */
      WAIT_FORCE,
      
      
      
      public class SeleniumWaitOperationServiceImpl implements SeleniumWaitOperationService {
      @Override
      public void waitHide(long milliseconds) {
          WebDriver webDriver = SeleniumWebdriverContext.get();
          webDriver.manage().timeouts().implicitlyWait(Duration.ofMillis(milliseconds));
      }
  
      @Override
     public void waitShow(UiCaseStepDO uiCaseStepDO) {
          WebDriverWait wait = new WebDriverWait(SeleniumWebdriverContext.get(), Duration.ofMillis(Long.parseLong(uiCaseStepDO.getValue())));
          SeleniumByEnum seleniumByEnum = SeleniumByEnum.valueOf(uiCaseStepDO.getLocationType());
          String locationExpress = uiCaseStepDO.getLocationExpress();
          try {
               switch (seleniumByEnum) {
                  case ID ->
                          wait.until(ExpectedConditions.presenceOfElementLocated(By.id(locationExpress)));
  
                  case LINK_TEXT ->
                          wait.until(ExpectedConditions.presenceOfElementLocated(By.linkText(locationExpress)));
  
                  case PARTIAL_LINK_TEXT ->
                          wait.until(ExpectedConditions.presenceOfElementLocated(By.partialLinkText(locationExpress)));
  
                  case NAME ->
                          wait.until(ExpectedConditions.presenceOfElementLocated(By.name(locationExpress)));
  
                  case TAG_NAME ->
                          wait.until(ExpectedConditions.presenceOfElementLocated(By.tagName(locationExpress)));
  
                  case XPATH ->
                          wait.until(ExpectedConditions.presenceOfElementLocated(By.xpath(locationExpress)));
  
                  case CLASS_NAME ->
                          wait.until(ExpectedConditions.presenceOfElementLocated(By.className(locationExpress)));
  
                  case CSS_SELECTOR ->
                          wait.until(ExpectedConditions.presenceOfElementLocated(By.cssSelector(locationExpress)));
  
                  default ->
                          throw new BizException(BizCodeEnum.UI_OPERATION_UNSUPPORTED_ELEMENT);
              };
          } catch (NoSuchElementException e) {
              // 未找到元素
              throw new BizException(BizCodeEnum.UI_ELEMENT_NOT_EXIST);
          }
      }
  
      @Override
      public void waitForce(long milliseconds) {
          try {
              Thread.sleep(milliseconds);
          } catch (InterruptedException e) {
              throw new RuntimeException(e);
          }
      }
  }
  
  ```

  









![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第三十一章 UI自动化测试引擎-多案例断言分发器实战



#### 第1集 Selenium4.X断言分发器骨架方法开发实战

**简介：Selenium4.X断言分发器骨架方法开发实战**

* 需求
  * **UI自动化测试里面断言种类多样，需要进行二级和三级分发**
  * 归类为：断言浏览器相关操作、断言元素文本相关操作、断言元素状态相关操作
  * **每类断言都可以支持拓展新增，学会对应的开发流程和思路，可以支持更多类型**

* 编码实战

  ```
   @Override
      public UiOperationResultDTO assertionOperationDispatcher(UiCaseStepDO uiCaseStepDO) {
          String type = uiCaseStepDO.getOperationType();
  
          UiOperationResultDTO assertion;
          if (type.contains(SeleniumOperationEnum.ASSERTION_BROWSER.name())) {
              // 断言浏览器相关操作
              assertion = assertionBrowserOperationDispatcher(uiCaseStepDO);
  
          }
          else if (type.contains(SeleniumOperationEnum.ASSERTION_ELEMENT_TEXT.name())) {
              // 断言元素文本相关操作
              assertion = assertionElementTextOperationDispatcher(uiCaseStepDO);
  
          } else if (type.contains(SeleniumOperationEnum.ASSERTION_ELEMENT.name())) {
              // 断言元素状态相关操作
              assertion = assertionElementOperationDispatcher(uiCaseStepDO);
  
          } else {
              // 不支持的断言操作
              throw new BizException(BizCodeEnum.UI_OPERATION_UNSUPPORTED_ASSERTION);
          }
  
  
          return assertion;
      }
  
  ```

  











#### 第2集 Selenium4.X断言浏览器操作分发器开发实战

**简介：Selenium4.X断言浏览器操作分发器开发实战**

* 需求
  * UI自动化测试浏览器网页相关断言开发
  * 包括不限于下面功能
    * 网页标题相等、不相等、包含、不包含
    * 网页URL相等、不相等、包含、不包含

* 编码实战

  ```
  /**
       * 网页标题相等
       */
      ASSERTION_BROWSER_TITLE_EQUAL,
  
      /**
       * 网页标题不相等
       */
      ASSERTION_BROWSER_TITLE_NOT_EQUAL,
  
      /**
       * 网页标题包含
       */
      ASSERTION_BROWSER_TITLE_CONTAIN,
  
      /**
       * 网页标题不包含
       */
      ASSERTION_BROWSER_TITLE_NOT_CONTAIN,
  
      /**
       * 网页URL相等
       */
      ASSERTION_BROWSER_URL_EQUAL,
  
      /**
       * 网页URL不相等
       */
      ASSERTION_BROWSER_URL_NOT_EQUAL,
  
      /**
       * 网页URL包含
       */
      ASSERTION_BROWSER_URL_CONTAIN,
  
      /**
       * 网页URL不包含
       */
      ASSERTION_BROWSER_URL_NOT_CONTAIN,
  
  
  
   public UiOperationResultDTO assertionBrowserOperationDispatcher(UiCaseStepDO uiCaseStepDO) {
          WebDriver webDriver = SeleniumWebdriverContext.get();
          SeleniumOperationTypeEnum seleniumOperationTypeEnum = SeleniumOperationTypeEnum.valueOf(uiCaseStepDO.getOperationType());
  
          return switch (seleniumOperationTypeEnum) {
              case ASSERTION_BROWSER_TITLE_EQUAL ->
                      // 网页标题相等
                      seleniumAssertionOperationService.equalValue(webDriver.getTitle(), uiCaseStepDO.getExpectValue());
  
              case ASSERTION_BROWSER_TITLE_NOT_EQUAL ->
                      // 网页标题不相等
                      seleniumAssertionOperationService.notEqualValue(webDriver.getTitle(), uiCaseStepDO.getExpectValue());
  
              case ASSERTION_BROWSER_TITLE_CONTAIN ->
                      // 网页标题包含
                      seleniumAssertionOperationService.containValue(webDriver.getTitle(), uiCaseStepDO.getExpectValue());
  
              case ASSERTION_BROWSER_TITLE_NOT_CONTAIN ->
                      // 网页标题不包含
                      seleniumAssertionOperationService.notContainValue(webDriver.getTitle(), uiCaseStepDO.getExpectValue());
  
  
              case ASSERTION_BROWSER_URL_EQUAL ->
                      // 网页URL相等
                      seleniumAssertionOperationService.equalValue(webDriver.getCurrentUrl(), uiCaseStepDO.getExpectValue());
  
              case ASSERTION_BROWSER_URL_NOT_EQUAL ->
                      // 网页URL不相等
                      seleniumAssertionOperationService.notEqualValue(webDriver.getCurrentUrl(), uiCaseStepDO.getExpectValue());
  
              case ASSERTION_BROWSER_URL_CONTAIN ->
                      // 网页URL包含
                      seleniumAssertionOperationService.containValue(webDriver.getCurrentUrl(), uiCaseStepDO.getExpectValue());
  
              case ASSERTION_BROWSER_URL_NOT_CONTAIN ->
                      // 网页URL不包含
                      seleniumAssertionOperationService.notContainValue(webDriver.getCurrentUrl(), uiCaseStepDO.getExpectValue());
  
              default ->
                      // 不支持的断言操作
                      throw new BizException(BizCodeEnum.UI_OPERATION_UNSUPPORTED_ASSERTION);
          };
      }
  ```

  



















#### 第3集 Selenium4.X断言元素文本操作分发器开发实战

**简介：Selenium4.X断言元素文本操作分发器开发实战**

* 需求
  * 开发WebUI自动化测试元素文本相关断言
  * 包括不限于下面功能
    * 元素文本大于、元素文本小于、元素文本等于
    * 文本元素不等于、文本元素包含、文本元素不包含

* 编码实战

  ```
  
      /**
       * 元素文本大于
       */
      ASSERTION_ELEMENT_TEXT_GREAT_THEN,
  
      /**
       * 元素文本小于
       */
      ASSERTION_ELEMENT_TEXT_LESS_THEN ,
  
      /**
       * 元素文本相等
       */
      ASSERTION_ELEMENT_TEXT_EQUAL,
  
      /**
       * 元素文本不相等
       */
      ASSERTION_ELEMENT_TEXT_NOT_EQUAL,
  
      /**
       * 元素文本包含
       */
      ASSERTION_ELEMENT_TEXT_CONTAIN,
  
      /**
       * 元素文本不包含
       */
      ASSERTION_ELEMENT_TEXT_NOT_CONTAIN,
      
      
  public UiOperationResultDTO assertionElementTextOperationDispatcher(UiCaseStepDO uiCaseStepDO) {
          WebElement element;
          try {
              element = SeleniumFetchUtil.findElement(uiCaseStepDO.getLocationType(), uiCaseStepDO.getLocationExpress(), 0);
          } catch (Exception e) {
              // 元素不存在
              throw new BizException(BizCodeEnum.UI_ELEMENT_NOT_EXIST);
          }
          String value = element.getText();
          SeleniumOperationTypeEnum seleniumOperationTypeEnum = SeleniumOperationTypeEnum.valueOf(uiCaseStepDO.getOperationType());
  
          return switch (seleniumOperationTypeEnum) {
              case ASSERTION_ELEMENT_TEXT_GREAT_THEN ->
                      // 元素文本大于
                      seleniumAssertionOperationService.greatThen(Long.parseLong(value), Long.parseLong(uiCaseStepDO.getExpectValue()));
  
              case ASSERTION_ELEMENT_TEXT_LESS_THEN ->
                      // 元素文本小于
                      seleniumAssertionOperationService.lessThen(Long.parseLong(value), Long.parseLong(uiCaseStepDO.getExpectValue()));
  
              case ASSERTION_ELEMENT_TEXT_EQUAL ->
                      // 元素文本等于
                      seleniumAssertionOperationService.equalValue(value, uiCaseStepDO.getExpectValue());
  
              case ASSERTION_ELEMENT_TEXT_NOT_EQUAL ->
                      // 文本元素不等于
                      seleniumAssertionOperationService.notEqualValue(value, uiCaseStepDO.getExpectValue());
  
              case ASSERTION_ELEMENT_TEXT_CONTAIN ->
                      // 文本元素包含
                      seleniumAssertionOperationService.containValue(value, uiCaseStepDO.getExpectValue());
  
              case ASSERTION_ELEMENT_TEXT_NOT_CONTAIN ->
                      // 文本元素不包含
                      seleniumAssertionOperationService.notContainValue(value, uiCaseStepDO.getExpectValue());
  
              default ->
                      // 不支持的断言操作
                      throw new BizException(BizCodeEnum.UI_OPERATION_UNSUPPORTED_ASSERTION);
          };
      }
  ```

  













#### 第4集 Selenium4.X断言元素状态操作分发器开发实战

**简介：Selenium4.X断言元素状态操作分发器开发实战**

* 需求
  * 开发WebUI自动化测试元素状态相关断言
  * 包括不限于下面
    * 元素存在、元素不存在、元素启用、元素禁用
    * 元素可见、元素不可见、元素可选、元素不可选

* 编码实战

  ```
  
      /**
       * 元素存在
       */
      ASSERTION_ELEMENT_EXIST,
  
      /**
       * 元素不存在
       */
      ASSERTION_ELEMENT_NOT_EXIST,
  
      /**
       * 元素启用
       */
      ASSERTION_ELEMENT_ENABLE,
  
      /**
       * 元素禁用
       */
      ASSERTION_ELEMENT_DISABLE,
  
      /**
       * 元素可见
       */
      ASSERTION_ELEMENT_VISIBLE,
  
      /**
       * 元素不可见
       */
      ASSERTION_ELEMENT_INVISIBLE,
  
      /**
       * 元素可选
       */
      ASSERTION_ELEMENT_SELECT,
  
      /**
       * 元素不可选
       */
      ASSERTION_ELEMENT_UNSELECT;
      
      
  public UiOperationResultDTO assertionElementOperationDispatcher(UiCaseStepDO uiCaseStepDO) {
          SeleniumOperationTypeEnum seleniumOperationTypeEnum = SeleniumOperationTypeEnum.valueOf(uiCaseStepDO.getOperationType());
  
          return switch (seleniumOperationTypeEnum) {
              case ASSERTION_ELEMENT_EXIST ->
                      // 元素存在
                      seleniumAssertionOperationService.existElement(uiCaseStepDO.getLocationType(), uiCaseStepDO.getLocationExpress());
  
              case ASSERTION_ELEMENT_NOT_EXIST ->
                      // 元素不存在
                      seleniumAssertionOperationService.absentElement(uiCaseStepDO.getLocationType(), uiCaseStepDO.getLocationExpress());
  
              case ASSERTION_ELEMENT_ENABLE ->
                      // 元素启用
                      seleniumAssertionOperationService.enableElement(uiCaseStepDO.getLocationType(), uiCaseStepDO.getLocationExpress());
  
              case ASSERTION_ELEMENT_DISABLE ->
                      // 元素禁用
                      seleniumAssertionOperationService.disableElement(uiCaseStepDO.getLocationType(), uiCaseStepDO.getLocationExpress());
  
              case ASSERTION_ELEMENT_VISIBLE ->
                      // 元素可见
                      seleniumAssertionOperationService.visibleElement(uiCaseStepDO.getLocationType(), uiCaseStepDO.getLocationExpress());
  
              case ASSERTION_ELEMENT_INVISIBLE ->
                      // 元素不可见
                      seleniumAssertionOperationService.invisibleElement(uiCaseStepDO.getLocationType(), uiCaseStepDO.getLocationExpress());
  
              case ASSERTION_ELEMENT_SELECT ->
                      // 元素可选
                      seleniumAssertionOperationService.selectElement(uiCaseStepDO.getLocationType(), uiCaseStepDO.getLocationExpress());
  
              case ASSERTION_ELEMENT_UNSELECT ->
                      // 元素不可选
                      seleniumAssertionOperationService.unselectElement(uiCaseStepDO.getLocationType(), uiCaseStepDO.getLocationExpress());
  
              default ->
                      // 不支持的断言操作
                      throw new BizException(BizCodeEnum.UI_OPERATION_UNSUPPORTED_ASSERTION);
          };
      }
  ```

  













![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第三十二章 UI自动化测试引擎-测试报告开发实战



#### 第1集 UI自动化测试引擎-UI测试报告数据库设计

**简介：UI自动化测试引擎-UI测试报告数据库设计**

* 需求
  * 设计Web UI自动化测试的测试报告明细数据库表
  * 逆向工程生成对应的实体类

* 数据库表说明

  * 下载资料 ，使用**【wget】或者【浏览器】远程下载相关依赖包（需要替换群里最新的）**

    ```
    原生资料下载方式(账号 - 密码 - ip地址 - 端口 需要替换群里最新的，其他路径不变)
    wget --http-user=用户名 --http-password=密码 http://ip:端口/dcloud_test/web_ui_detail_sql.zip
    
    #比如 命令行下
    wget --http-user=admin --http-password=xdclass.net888 http://47.115.31.28:9088/dcloud_test/web_ui_detail_sql.zip
    
    # 比如 浏览器直接访问
    http://47.115.31.28:9088/dcloud_test/web_ui_detail_sql.zip
    ```

  * WebUI自动化测试明细日志字段说明

  * 逆向工程配置实战











#### 第2集 Web UI自动化测试-测试报告日志开发实战

**简介：Web UI自动化测试-测试报告日志开发实战**

* 需求

  * 开发web ui自动化测试消费者配置实战，消费测试报告日志
  * 更新测试报告状态和保存测试报告明细数据

* 编码实战

  ```
  @Override
      public void handleUiReportDetail(String reportContent) {
          UiCaseResultDTO uiCaseResultDTO = JsonUtil.json2Obj(reportContent, UiCaseResultDTO.class);
  
          //处理测试报告的概述
          ReportDO reportDO = reportMapper.selectById(uiCaseResultDTO.getReportId());
          reportDO.setExecuteState(ReportStateEnum.EXECUTE_SUCCESS.name());
          reportDO.setEndTime(uiCaseResultDTO.getEndTime());
          reportDO.setExpandTime(uiCaseResultDTO.getExpendTime());
          reportDO.setQuantity(Long.valueOf(uiCaseResultDTO.getQuantity()));
          reportDO.setFailQuantity(Long.valueOf(uiCaseResultDTO.getFailQuantity()));
          reportDO.setPassQuantity(reportDO.getQuantity() - reportDO.getFailQuantity());
          //更新概述
          reportMapper.updateById(reportDO);
  
          //处理测试报告明细
          List<UiCaseResultItemDTO> stepList = uiCaseResultDTO.getList();
          stepList.forEach(item->{
  
              ReportDetailUiDO reportDetailUiDO = SpringBeanUtil.copyProperties(item, ReportDetailUiDO.class);
              UiCaseStepDTO step = item.getUiCaseStep();
              SpringBeanUtil.copyProperties(step, reportDetailUiDO);
              reportDetailUiDO.setId(null);
              reportDetailUiMapper.insert(reportDetailUiDO);
          });
      }
  ```

  









#### 第3集 UI自动化测试快照截图-预览接口开发实战

**简介：UI自动化测试快照截图-预览接口开发实战**

* 需求

  * Web UI自动化测试有截图快照，自动上传分布式文件存储，那用户如何查看截图快照呢？
  * 默认是不支持预览的，所以需要开发预览接口，用户可以通过预览接口查看Selenium的快照截图

  ![image-20240306144000555](img/image-20240306144000555.png)

* 编码实战

  ```
     @Operation(summary = "临时访问路径")
      @GetMapping("/get_temp_url")
      public JsonData getTempUrl(@RequestParam("fileUrl") String fileUrl) {
          return JsonData.buildSuccess(minioService.getTempFileUrl(fileUrl));
      }
      
      
        /**
       * 获取对象的临时访问url，有效期60分钟
       */
      @Override
      public String getTempFileUrl(String remoteFilePath) {
          try {
              String fileName = remoteFilePath.substring(remoteFilePath.lastIndexOf('/') + 1);
              GetPresignedObjectUrlArgs args = GetPresignedObjectUrlArgs.builder()
                      .bucket(minioConfig.getBucketName())
                      .object(fileName)
                      .expiry(60, TimeUnit.MINUTES)
                      .method(Method.GET)
                      .build();
              return minioClient.getPresignedObjectUrl(args);
          } catch (Exception e) {
              throw new BizException(BizCodeEnum.FILE_PRE_SIGNED_FAILED);
          }
      }
  ```

  















![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第三十三章 云测试平台-Web UI自动化全链路测试实战



#### 第1集 WebUI自动化引擎全链路测试-正常链路

**简介： WebUI自动化引擎全链路测试-正常链路**

* 需求
  * WebUI自动化测试引擎全链路测试
  * 说明：由于测试的模块特别多，这边没法全部覆盖，大家可以自己测试更多场景，有Bug及时反馈给我
  * 本集内容进行**正常链路测试：打开网页、定位元素、输入内容、点击搜索、截图案例**

* 案例实战

  * 录入数据

  ```
  INSERT INTO `test_engine`.`ui_case` (`id`, `project_id`, `module_id`, `browser`, `name`, `description`, `level`, `gmt_create`, `gmt_modified`) VALUES (13, 1, 28, 'CHROME', '百度搜索用例', '无描述', 'p0', '2026-03-02 06:40:41', '2026-03-02 06:40:41');
  
  
  INSERT INTO `test_engine`.`ui_case_step` (`id`, `project_id`, `case_id`, `num`, `name`, `operation_type`, `location_type`, `location_express`, `element_wait`, `target_location_type`, `target_location_express`, `target_element_wait`, `value`, `expect_key`, `expect_value`, `description`, `is_continue`, `is_screenshot`,  `gmt_create`, `gmt_modified`) VALUES (65, 1, 13, 0, '打开首页', 'BROWSER_OPEN', '', '', 0, '', '', 0, 'https://www.baidu.com/', '', '', '', 0, 0, '2026-03-02 06:41:58', '2026-03-02 06:41:58');
  
  INSERT INTO `test_engine`.`ui_case_step` (`id`, `project_id`, `case_id`, `num`, `name`, `operation_type`, `location_type`, `location_express`, `element_wait`, `target_location_type`, `target_location_express`, `target_element_wait`, `value`, `expect_key`, `expect_value`, `description`, `is_continue`, `is_screenshot`,  `gmt_create`, `gmt_modified`) VALUES (66, 1, 13, 1, '输入内容', 'KEYBOARD_INPUT', 'ID', 'kw', 2000, '', '', 0, '苹果手机1000', '', '', '', 0, 0,  '2026-03-02 06:42:50', '2026-03-08 01:54:25');
  
  INSERT INTO `test_engine`.`ui_case_step` (`id`, `project_id`, `case_id`, `num`, `name`, `operation_type`, `location_type`, `location_express`, `element_wait`, `target_location_type`, `target_location_express`, `target_element_wait`, `value`, `expect_key`, `expect_value`, `description`, `is_continue`, `is_screenshot`,  `gmt_create`, `gmt_modified`) VALUES (67, 1, 13, 2, '点击搜索', 'MOUSE_LEFT_CLICK', 'ID', 'su', 1000, '', '', 0, '', '', '', '', 0, 0,  '2026-03-02 06:43:21', '2026-03-02 06:43:21');
  
  INSERT INTO `test_engine`.`ui_case_step` (`id`, `project_id`, `case_id`, `num`, `name`, `operation_type`, `location_type`, `location_express`, `element_wait`, `target_location_type`, `target_location_express`, `target_element_wait`, `value`, `expect_key`, `expect_value`, `description`, `is_continue`, `is_screenshot`,  `gmt_create`, `gmt_modified`) VALUES (68, 1, 13, 3, '等待截图', 'WAIT_FORCE', '', '', 0, '', '', 0, '2000', '', '', '', 0, 1, '2026-03-08 01:52:14', '2026-03-08 01:52:14');
  ```

  * 用例执行
  * 测试报告查看

  <img src="img/image-20240308095623565.png" alt="image-20240308095623565" style="zoom:50%;" />











#### 第2集 WebUI自动化引擎全链路测试-异常链路

**简介： WebUI自动化引擎全链路测试-异常链路**

* 需求
  * WebUI自动化测试引擎全链路测试
  * 说明：由于测试的模块特别多，这边没法全部覆盖，可以自己测试更多场景，有Bug及时反馈给我
  * 本集内容进行异常链路测试：打开网页、定位元素(不存在)、输入内容、点击搜索、截图案例
  * **关注点：某个步骤执行失败是否继续下行，开启下行执行和失败直接终止**

* 案例实战

  * 录入数据

  ```
  INSERT INTO `test_engine`.`ui_case` (`id`, `project_id`, `module_id`, `browser`, `name`, `description`, `level`, `gmt_create`, `gmt_modified`) VALUES (14, 1, 28, 'CHROME', '百度搜索-某步骤失败', '无描述', 'p0',  '2026-03-08 02:00:10', '2026-03-08 02:01:14');
  
  
  INSERT INTO `test_engine`.`ui_case_step` (`id`, `project_id`, `case_id`, `num`, `name`, `operation_type`, `location_type`, `location_express`, `element_wait`, `target_location_type`, `target_location_express`, `target_element_wait`, `value`, `expect_key`, `expect_value`, `description`, `is_continue`, `is_screenshot`,  `gmt_create`, `gmt_modified`) VALUES (69, NULL, 14, 0, '打开网页', 'BROWSER_OPEN', '', '', 0, '', '', 0, 'https://www.baidu.com/', '', '', '', 0, 0,'2026-03-08 02:00:10', '2026-03-08 02:00:10');
  
  INSERT INTO `test_engine`.`ui_case_step` (`id`, `project_id`, `case_id`, `num`, `name`, `operation_type`, `location_type`, `location_express`, `element_wait`, `target_location_type`, `target_location_express`, `target_element_wait`, `value`, `expect_key`, `expect_value`, `description`, `is_continue`, `is_screenshot`,  `gmt_create`, `gmt_modified`) VALUES (70, NULL, 14, 1, '定位不存在元素', 'KEYBOARD_INPUT', 'ID', 'id8888', 2000, '', '', 0, '小滴课堂', '', '', '', 1, 1,  '2026-03-08 02:00:10', '2026-03-08 02:08:26');
  
  INSERT INTO `test_engine`.`ui_case_step` (`id`, `project_id`, `case_id`, `num`, `name`, `operation_type`, `location_type`, `location_express`, `element_wait`, `target_location_type`, `target_location_express`, `target_element_wait`, `value`, `expect_key`, `expect_value`, `description`, `is_continue`, `is_screenshot`, `gmt_create`, `gmt_modified`) VALUES (71, 1, 14, 2, '默认名称', 'KEYBOARD_INPUT', 'ID', 'kw', 2000, '', '', 0, '苹果100', '', '', '', 0, 0,  '2026-03-08 02:00:53', '2026-03-08 02:00:53');
  
  INSERT INTO `test_engine`.`ui_case_step` (`id`, `project_id`, `case_id`, `num`, `name`, `operation_type`, `location_type`, `location_express`, `element_wait`, `target_location_type`, `target_location_express`, `target_element_wait`, `value`, `expect_key`, `expect_value`, `description`, `is_continue`, `is_screenshot`,  `gmt_create`, `gmt_modified`) VALUES (72, 1, 14, 3, '点击搜索', 'MOUSE_LEFT_CLICK', 'ID', 'su', 1000, '', '', 0, '', '', '', '', 0, 1,'2026-03-08 02:01:11', '2026-03-08 02:01:11');
  ```

  * 用例执行
  * 测试报告查看

















#### 第3集 WebUI自动化引擎全链路测试-多案例断言

**简介： WebUI自动化引擎全链路测试-多案例断言**

* 需求
  * WebUI自动化测试引擎全链路测试
  * 说明：由于测试的模块特别多，这边没法全部覆盖，可以自己测试更多场景，有Bug及时反馈给我
  * 本集内容进行异常链路测试
    * 打开网页、定位元素(不存在)、截图、输入内容、断言URL，断言标题、点击搜索、断言元素文本、截图案例
  * **关注点：某个步骤断言是否继续下行，开启下行执行和失败直接终止**

* 案例实战

  * 录入数据

  ```
  INSERT INTO `test_engine`.`ui_case` (`id`, `project_id`, `module_id`, `browser`, `name`, `description`, `level`,  `gmt_create`, `gmt_modified`) VALUES (15, 1, 28, 'CHROME', '百度搜索-断言', '无描述', 'p0', '2026-03-08 02:00:10', '2026-03-08 02:42:19');
  
  
  
  INSERT INTO `test_engine`.`ui_case_step` (`id`, `project_id`, `case_id`, `num`, `name`, `operation_type`, `location_type`, `location_express`, `element_wait`, `target_location_type`, `target_location_express`, `target_element_wait`, `value`, `expect_key`, `expect_value`, `description`, `is_continue`, `is_screenshot`,  `gmt_create`, `gmt_modified`) VALUES (89, 1, 15, 0, '打开网页', 'BROWSER_OPEN', '', '', 0, '', '', 0, 'https://www.baidu.com/', '', '', '', 0, 0,'2026-03-08 02:00:10', '2026-03-08 02:44:05');
  
  INSERT INTO `test_engine`.`ui_case_step` (`id`, `project_id`, `case_id`, `num`, `name`, `operation_type`, `location_type`, `location_express`, `element_wait`, `target_location_type`, `target_location_express`, `target_element_wait`, `value`, `expect_key`, `expect_value`, `description`, `is_continue`, `is_screenshot`,  `gmt_create`, `gmt_modified`) VALUES (90, 1, 15, 1, '定位不存在元素', 'KEYBOARD_INPUT', 'ID', 'id8888', 2000, '', '', 0, '小滴课堂', '', '', '', 1, 1,  '2026-03-08 02:00:10', '2026-03-08 02:43:58');
  
  INSERT INTO `test_engine`.`ui_case_step` (`id`, `project_id`, `case_id`, `num`, `name`, `operation_type`, `location_type`, `location_express`, `element_wait`, `target_location_type`, `target_location_express`, `target_element_wait`, `value`, `expect_key`, `expect_value`, `description`, `is_continue`, `is_screenshot`,  `gmt_create`, `gmt_modified`) VALUES (91, 1, 15, 2, '默认名称', 'KEYBOARD_INPUT', 'ID', 'kw', 2000, '', '', 0, '苹果100', '', '', '', 0, 0, '2026-03-08 02:00:53', '2026-03-08 02:44:08');
  
  INSERT INTO `test_engine`.`ui_case_step` (`id`, `project_id`, `case_id`, `num`, `name`, `operation_type`, `location_type`, `location_express`, `element_wait`, `target_location_type`, `target_location_express`, `target_element_wait`, `value`, `expect_key`, `expect_value`, `description`, `is_continue`, `is_screenshot`,  `gmt_create`, `gmt_modified`) VALUES (92, 1, 15, 3, '点击搜索', 'MOUSE_LEFT_CLICK', 'ID', 'su', 1000, '', '', 0, '', '', '', '', 0, 1,  '2026-03-08 02:01:11', '2026-03-08 02:44:10');
  
  INSERT INTO `test_engine`.`ui_case_step` (`id`, `project_id`, `case_id`, `num`, `name`, `operation_type`, `location_type`, `location_express`, `element_wait`, `target_location_type`, `target_location_express`, `target_element_wait`, `value`, `expect_key`, `expect_value`, `description`, `is_continue`, `is_screenshot`,  `gmt_create`, `gmt_modified`) VALUES (93, 1, 15, 4, '断言元素是存在-实际不存在', 'ASSERTION_ELEMENT_EXIST', 'ID', 'kkkkk', 0, '', '', 0, '', '', '', '', 1, 0, '2026-03-08 02:38:12', '2026-03-08 02:44:13');
  
  INSERT INTO `test_engine`.`ui_case_step` (`id`, `project_id`, `case_id`, `num`, `name`, `operation_type`, `location_type`, `location_express`, `element_wait`, `target_location_type`, `target_location_express`, `target_element_wait`, `value`, `expect_key`, `expect_value`, `description`, `is_continue`, `is_screenshot`, `gmt_create`, `gmt_modified`) VALUES (94, 1, 15, 5, '断言元素启用', 'ASSERTION_ELEMENT_ENABLE', 'ID', 'su', 0, '', '', 0, '', '', '', '', 0, 0, '2026-03-08 02:39:04', '2026-03-08 02:44:15');
  
  INSERT INTO `test_engine`.`ui_case_step` (`id`, `project_id`, `case_id`, `num`, `name`, `operation_type`, `location_type`, `location_express`, `element_wait`, `target_location_type`, `target_location_express`, `target_element_wait`, `value`, `expect_key`, `expect_value`, `description`, `is_continue`, `is_screenshot`,  `gmt_create`, `gmt_modified`) VALUES (95, 1, 15, 6, '断言URL包括', 'ASSERTION_BROWSER_URL_CONTAIN', '', '', 0, '', '', 0, '', '', 'baidu', '', 0, 1, '2026-03-08 02:39:47', '2026-03-08 02:44:17');
  ```

  * 用例执行
  * 测试报告查看









#### 第4集 滴云自动化测试平台-WebUI自动化测试引擎总结

**简介:滴云自动化测试平台-WebUI自动化测试引擎总结**

- 大家此刻的心情应该如下，TM终于把Web UI自动化引擎 开发好了

  <img src="./img/image-20240114150848929.png" alt="image-20240114150848929" style="zoom:50%;" />

- 知识点总结规划

  - **从WebUI自动化测试需求分析，到数据库表设计，到技术框架选择，到项目搭建**
  - **完成WebUI自动化测试引擎的多业务解决方案设计+核心逻辑开发**
  - **掌握了Selenium4.X测试框架使用+封装，包括元素定位、浏览器、等待、键盘、鼠标等事件封装**
  - **封装了UiExecuteEngine，支持递归处理用例多步骤请求**
  - **支持多WebUI用例编排、多类型元素操作方式、不同模块多断言规则和处理、自动化测试报告处理等**
  - 还有很多可以做的...**作为作业等待大家的探索设计，开源社区方向**
    - 整体代码逻辑优化和bug修复
    - 元素库提取和用例快速生成
    - 用例步骤拖拽调整顺序
    - 支持WebUI自定义HTTP请求参数
    - Web UI自动化报告传输组件和持久化数据源支持多类型
    - ...











![logo](img/logo.png) **愿景："IT路上的持续充电平台，让技术不再难学"**

**更多高级课程请访问 xdclass.net**

### 第三十四章 重点-滴云自动化测试平台-跳槽面试简历编写



#### 第1集 一份合格的技术工程师简历关键组成

**简介： 一份合格的技术工程师简历关键组成**

* 备注
  * 云测平台里面三大引擎基本开发完成了，也有很多同学想尽快写简历和面试
  * 所以我们在这里提前讲简历编写和面试官问答
  * 云测大课后续还有不少内容，包括用户服务、测试计划、前端、部署上线等，简历讲完后在继续

* 需求

  * 如何编写一份合格的简历，关键组成部分有哪些？

  <img src="img/image-20240308120245432.png" alt="image-20240308120245432" style="zoom:50%;" />

  * 常规一个招聘HC从哪里来的，换位思考
    * 技术组长需要招聘->HR发布招聘需求【HR懂技术不？】->捞取简历->初步符合要求给面试官确认是否约面
    * 回复应聘者进行约面->一面基础，二面项目，三面潜力和价值观->背景调查【非必要】->发放Offer入职

  * **合格简历组成部分【每个填写项里面，中括号里面的是注意事项，尤其注意！！！！】**

    * 个人信息

      - 姓名、联系方式、电话号码、电子邮件地址

      - 居住地

      - 求职岗位
      - 期望薪资

    * 教育背景
      - 最高学历及毕业院校、所学专业、毕业时间、如有相关荣誉或奖项，可在此处提及

    * 工作经验

      - 列出的工作经历，包括公司名称、职位、工作时间

      - 描述在每个职位中承担的职责和所取得的成果

      - 强调与Java技术相关的项目经验，如使用的技术栈、解决的问题、实现的功能等

    * 技能与专长

      - 列出熟练掌握的Java相关开发技术、测试相关技术、数据库、各类主流中间件技术等

      - 列出进阶的能力，如设计模式、主导项目、全链路性能有优化、带技术团队、架构和技术选型等

      - 如有其他相关技能，如前端技术、大数据等，也可在此处列出

    * 项目经验

      - 描述参与过的具有【代表性】的项目，包括项目背景、目标、角色和贡献

      - 强调项目中的技术难点及如何解决的【解决方案也可以不写，面试官提问的时候说】

      - 提供项目的成果或业绩数据，证明自己的能力和价值

    * 自我评价

      - 简短地描述的性格特点、职业规划及优势

      - 突出的团队合作精神、学习能力及解决问题的能力

    * 附加信息

      - 如有获奖证书、培训经历或其他能证明能力的材料，可在此处提及，不想关的可以忽略

      - 如有博客或GitHub仓库等，可附上链接以便面试官查看



* 我们来看一份简历，你认为如何，先自己找出缺点，下一集来点评

<img src="img/image-20240308122611114.png" alt="image-20240308122611114" style="zoom:50%;" />

















#### 第2集 高级后端工程师简历-如何扬长补短

**简介： 高级后端工程师简历-如何扬长补短**

* 知道合格简历的组成部分后，为啥还有人投递后，已读不回复？？？？

  * 根据下面简历挑刺，说下你认为不合格的地方

  <img src="img/image-20240308121637978.png" alt="image-20240308121637978" style="zoom:50%;" />

<img src="img/image-20240308121652570.png" alt="image-20240308121652570" style="zoom:50%;" />

* 知道问题所在了不？？

  * 个人信息

    * 姓名、联系方式、电话号码、电子邮件地址

    - 居住地【通勤时间】

    - 求职岗位【年限和职位级别是否对应】

    - 期望薪资【建议写面议，具体等面试的时候聊，结年终奖和福利】

  * 教育背景

    - 最高学历及毕业院校【大专学历如何写、自考本科如何写】

    - 所学专业【非科班如何写】

    - 毕业时间【和本行从事工作年限需要一样】

    - 如有相关荣誉或奖项，可在此处提及

  * 工作经验

    - 列出的工作经历，包括公司名称、职位、工作时间【适当合并过往公司，避免跳槽频繁】

    - 描述在每个职位中承担的职责和所取得的成果

    - 强调与Java技术相关的项目经验，如使用的技术栈、解决的问题、实现的功能等

  * 技能与专长

    - 列出熟练掌握的Java相关技术、自动化测试相关技术，如Java并发、Spring框架、数据库、各类主流中间件技术等
      - **尽量和求职岗位相关的：后端岗主写后端，测试岗主写测试、前端岗主写前端、运维刚主写运维**
      - 注意
        - 高级岗，工作4年以上的，都必须写后端，因为各个岗位高级岗都是需要会后端！！！
        - **最终都是往架构师和技术组长方向进行发展，包括所属岗位的平台开发**

    - 列出进阶的能力，如设计模式、主导项目、全链路性能有优化、带技术团队、架构和技术选型等

    - 如有其他相关技能，如前端技术、大数据等，也可在此处列出

    <img src="img/image-20240308120530760.png" alt="image-20240308120530760" style="zoom:50%;" />

  * 项目经验

    - 描述参与过的具有【代表性】的项目，包括项目背景、目标、角色和贡献

    - 强调项目中的技术难点及如何解决的【解决方案也可以不写，面试官提问的时候说】

    - 提供项目的成果或业绩数据，证明自己的能力和价值

  * 自我评价

    - 简短地描述的性格特点、职业规划及优势

    - 突出的团队合作精神、学习能力及解决问题的能力

  * 附加信息

    - 如有获奖证书、培训经历或其他能证明能力的材料，可在此处提及，不想关的可以忽略

    - 如有博客或GitHub仓库等，可附上链接以便面试官查看

* **在编写简历时，请注意以下几点：**

  - **简洁明了：尽量用简洁的语言描述的经历和技能，避免冗长的句子和无关紧要的细节【有同学和写作文一样】**
  - **突出重点：根据求职岗位的要求，突出与Java技术相关的经验和技能【不要写不相干的和凑数项目】**
  - **量化成果：尽量用数据或具体成果来说明难点和成功，简历更具说服力。**
  - **格式化**：使用清晰的格式和排版，使简历易于阅读和理解，可以使用**加粗、列表**等方式突出关键信息

  











#### 第3集 高级测试工程师简历-如何扬长补短

**简介： 高级测试工程师简历-如何扬长补短**

* 知道合格简历的组成部分后，为啥还有人投递后，已读不回复？？？？
  * 根据下面简历挑刺，说下你认为不合格的地方

<img src="img/image-20240308150311389.png" alt="image-20240308150311389" style="zoom:50%;" />

<img src="img/image-20240308150333052.png" alt="image-20240308150333052" style="zoom:50%;" />

<img src="img/image-20240308150352656.png" alt="image-20240308150352656" style="zoom:50%;" />





















#### 第4集 简历的个人技能-高级工程师和技术组长

**简介：  简历的个人技能-高级工程师和技术组长**

* 高级后端工程师简历或技术组长简历

  * 高级测试开发工程师 个人技能模块

  ```
  熟练Java、Python等后端开发语言，能够编写稳定的自动化测试脚本和复杂的测试框架。
  熟练掌握JUnit、Pytest等主流测试框架，能够根据业务需求定制测试策略
  深入理解接口测试、性能测试、安全测试等多种测试方法，具备丰富的测试案例设计和执行经验。
  熟练使用Selenium、Appium等工具进行Web和移动应用的自动化测试
  熟练JMeter等性能测试工具，能够对系统进行压力测试和性能调优。
  熟练使用SonarQube、FindBugs等静态代码分析工具，帮助开发团队定位潜在缺陷。
  熟悉Jenkins、GitLab CI等持续集成/持续部署工具，能够构建自动化测试流水线。
  熟练使用阿里云性能测试PTS、云效等云原生测试工具，提升测试效率与准确性
  熟练MySQL、Oracle等关系型数据库，有一定的数据库性能优化经验
  熟悉NoSQL数据库如Redis、MongoDB等，了解其在大数据处理中的应用
  熟悉微服务架构、容器化技术，开发过相关项目，掌握分布式系统测试的挑战与解决方案。
  能够根据业务需求设计合理的测试架构，确保测试的可扩展性、可维护性和高效性。
  熟悉API网关、消息队列等中间件技术，能够在复杂系统中进行集成测试
  持续关注测试领域的新技术、新工具，如AI驱动的测试、混沌工程等。
  具有较强的学习能力，能够快速掌握新技术并将其应用到实际工作中。
  参与过多个大型项目的测试工作，积累了丰富的测试经验和问题解决能力
  具备优秀的沟通与协作能力，能够与产品、开发、运维等多个团队有效合作。
  能够准确理解业务需求，制定测试计划并推动测试工作的顺利进行。
  ```

  * 高级后端开发工程师技术组长个人技能模块

  ```
  熟练掌握后端 java/Python/Sql 等语言,  掌握 JVM 内存模型，对JVM性能优化有丰富的经验
  熟练java并发,异步编程、线程池等熟练 AQS 和多个 JUC 源码， 主导过多个大型项目性能优化
  熟练 Spring/Boot/Cloud/Mybatis/Redis/RabbitMQ/ES/Netty,底层原理，根据业务搭建合适的架构
  熟悉全链路压测和性能优化，多次主导过公司核心项目全链路压测和稳定性保障
  深入理解分布式系统原理，熟悉分布式事务、一致性协议等关键技术。
  熟悉Jenkins、GitLab CI等持续集成工具，能够构建自动化测试与发布流程。
  熟练使用SonarQube、Checkstyle等代码质量检查工具，确保代码质量。
  掌握 实时计算框架和丰富大数据项目经验，主导过多个数据仓库、BI平台、画像系统的建设
  掌握 Flink 实时计算框架和一定的大数据项目经验熟悉分布式架构，集群和负载均衡算法
  熟悉分布式事务等 搭建搜索引擎,Redis 和 RabbitMQ 集群,LVS+Nginx；
  熟悉 Rancher 云平台和容器编排技术， 自动化扩容和监控体系搭建；
  熟练掌握 Mysql,掌握多种索引使用和原理,能独立分析需求设计数据库有一定的 sql 优化经验；
  熟悉 K8S容器编排技术，对自动化扩容和Prometheus监控、日志系统、DevOps平台有丰富经验
  CET-6有优秀的听说读写能力， 能用英语进行日常交流，曾负责海外项目技术对接和落地
  有丰富的海量数据处理经验，独立架构过日均数据量百万的数据库，包括底层性能优化
  具备较强的创新能力，能够将新技术应用到实际工作中，提升项目质量和效率。
  参与过多个大型项目的开发工作，积累了丰富的项目经验和解决问题的能力。
  管理过30人+团队，5年架构经验，在电商、在线教育、支付领域有丰富的业务和架构经验
  ```

<img src="img/image-20240309150241932.png" alt="image-20240309150241932" style="zoom:30%;" />

* 大家简历编写后，看完本章内容，编写自己的简历，记得发我点评下，注意下面几点
  * 切记不可全部照抄上面的，每个人的经历情况都是独一无二
  * 工作年限、学校级别、学历、专业情况、求职城市、过往公司和项目经历等
  * 所以需要掌握前面的技巧，结合我的建议调整，打造一份专属的优秀简历

<img src="img/image-20240309152903622.png" alt="image-20240309152903622" style="zoom:50%;" />







#### 第5集 简历最关键的部分-项目经验如何写

**简介：  简历最关键的部分-项目经验如何写**

* 简历最关键的模块-项目这边如何编写？
  * **项目概述**：简要介绍项目的背景和规模，让面试官快速了解项目的整体情况。
  * **角色与职责**：详细列出你在项目中担任的角色和具体职责，例如项目负责人、架构师、核心开发等。
  * **技术栈与工具**：列出项目中所使用的技术栈、框架和工具，特别是那些你擅长或有所贡献的部分。
  * **挑战与解决方案**：描述在项目过程中遇到的关键技术难题或挑战，你是如何解决这些问题的。
  * **成果与贡献**：量化你的成果和贡献，例如提高系统性能XX%、降低代码缺陷率XX%等；也列举一些具体的创新点或亮点。
* **注意事项**
  * **针对性**
    * 根据项目需求和个人职业规划，有针对性地选择和描述项目经验。
    * 如果应聘的职位注重性能优化，那么可以重点突出你在项目中如何提高系统性能的经验。
    * 错误案例
      * 在简历中列举了多个与Java开发无关的项目，如前端开发、移动端开发等
      * 招聘者无法快速识别出应聘者在Java后端开发方面的专业能力。
  * **简洁明了**
    * 避免冗长的描述和无关的细节，用简洁明了的语言突出重点和亮点。
    * 错误案例
      * 对于某个项目的描述过于冗长，包含了大量细节和无关紧要的内容，使得招聘者难以快速抓住重点。
      * 项目和和个人负责的模块当成小作文那样编写
  * **数据化成果**
    * 尽量使用具体的数据来量化你的成果和贡献，这样更能体现你的价值。
    * 错误案例
      * 在描述项目成果时，仅使用了模糊的描述，如“提高了系统性能”、“优化了代码结构”等，没有具体的数据支撑。
    * 正确做法
      使用具体的数据来量化成果，如“通过优化算法，将系统响应时间降低了30%”、“重构代码后，代码缺陷率下降了20%”等
  * **避免夸大**
    * 实事求是地描述自己的经验和成果，适当包装亮点和模块，但不懂装懂，严重夸大
    * 错误案例
      * 在简历中夸大自己的贡献和成果，如声称自己独自完成了整个项目或解决了业界公认的难题，但实际情况并非如此。
  * **体现团队合作**
    * 可以突出自己项目中发挥了关键作用，也要强调团队合作的重要性，体现团队协作精神和沟通能力
    * 错误案例
      * 在简历中过分强调个人的作用和贡献，忽略了团队合作的重要性，给招聘者留下自私、不善于协作的印象。

* 参考格式案例【基于下面的格式，替换整理自己的简历】

<img src="img/image-20240309161516902.png" alt="image-20240309161516902" style="zoom:40%;" />

* 云测平台项目介绍和技术栈说明【结合需求文档】

  * 项目介绍

  ```
  滴云自动化测试平台是一站式测试平台，三大核心模块包括：自动化接口引擎、UI自动化引擎、压力测试引擎，
  高效提升开发和测试团队进行自动化接口测试、业务场景编排测试、压力负载测试，加快高质量的软件交付
  全SaaS化形态，支持复杂场景的可视化+自动化测试编排，自研平台更可靠+定制化强，DevOps一键启动公有云端测试+持续监控告警+自动生成测试报告+可视化数据大屏+丰富数据报表下载，未来还会对外商业化收费，私有化部署给其他企业
  ```

  * 项目技术栈

  ```
  SpringBoot3.X+SpringCloudAlibaba+Redis7.X+Kafak3.X+Jmeter5.X+Senenium4.X+Mysql+分布式文件存储MinIO
  ```

  * 开发部署工具

  ```
  JDK17+Docker+Git+Jenkins+DevOps自动化部署+阿里云ECS
  ```

  * 项目周期

  ```
  6个月完成第一个版本开发和上线，后续2～3个月迭代一次
  ```

  













#### 第6集  云测平台-压测引擎简历编写和注意事项

**简介：  云测平台-压测引擎简历编写和注意事项**

* 滴云自动化测试平台-压力测试引擎项目介绍

```
压力测试引擎作为一站式测试平台的核心组件之一，可以模拟大量用户并发访问，对程序的性能进行性能测试，支持多种压力测试策略，可以根据不同的测试需求进行灵活配置和调整。支持在线创建压测脚本，也支持本地上传Jmeter录制JMX上传，支持多种HTTP请求接口压测，一键切换环境、支持多种数据源的可变参数传递、多案例断言和丰富的测试报告
```

<img src="img/image-20240308172121525.png" alt="image-20240308172121525" style="zoom:50%;" />

* 回顾云测大课压测引擎开发目录和课程代码总结亮点
  * 编写简历案例说明
    * 主导压测引擎整体架构+数据库设计，负责在线创建压测计划和本地JMX压测脚本动态上传
    * 封装JmeterEngine和自定义压测结果收集器，
    * 结合模版方法设计模式开发多引擎执行骨架，实现方法复用和拓展
    * 抽取消息组件接口支持多队列切换，支持包括Redis、Kafka等消息组件
    * 分布式文件存储组建封装，支持CSV可变参数文件上传和动态解析使用
    * 负责多案例断言组件开发和执行引擎异步任务线程池优化
    * 负责测试报告概述和明细日志设计，支持在线实时查看测试报告和性能瓶颈
    * 业绩【**靠这个说服老板或者面试官，汇报和面试都很有用**】
      * 业务上线性能测试接口覆盖率从70%->上升为90%（因为性能测试更容易操作，同样时间可以压测更多接口）
      * 生产环境高负载预警通知下降30%（由于多数接口做了压测和优化，所以线上预警减少了）
      * 单项目月人力成本节约40%（更少人力做更多事情，效率更高，公司成本也降低）

<img src="img/image-20240308173934161.png" alt="image-20240308173934161" style="zoom:30%;" />















#### 第7集 云测平台-接口自动化测试引擎简历编写

**简介：  滴云自动化测试平台-接口引擎简历编写**

* 滴云自动化测试平台-接自动化测试引擎项目介绍

```
接口自动化测试引擎是云测平台核心引擎之一，用于自动化测试后端各类型接口的请求和响应，快速完成接口自动化测试，缩短项目测试周期，统一技术团队接口管理和测试工具，避免重复性工作和提高接口测试效率，支持HTTP多类型接口请求和多接口编排，包括不同接口之间参数依赖和传递，支持模版参数动态解析替换；支持多种跨接口参数提取，包括JsonPath/正则等；支持多类型断言和二次拓展，包括一键切换不同测试环境和实时查看测试报告
```

<img src="img/image-20240309105824652.png" alt="image-20240309105824652" style="zoom:50%;" />

* 回顾云测大课压测引擎开发目录和课程代码总结亮点

  * 编写简历案例说明
    * 主导接口自动化测试引擎整体架构设计+技术选型+数据库设计；
    * 负责多接口编排引擎解决方案设计和开发，支持不同的规则接口上下文提取，支持请求头/行/体等
    * 封装参数上下文组件，支持跨接口参数传递，作用域支持全类型
    * 二次封装Restassured框架，支持类型HTTP接请求测试；
    * 负责多类型断言解决方案设计，支持GPath、JSONPath和正则提取，支持二次拓展更多
    * 负责多接口执行模块-基于递归算法处理多接口执行和测试日志传递
    * 业绩【**靠这个说服老板或者面试官，汇报和面试都很有用**】
      * 使用前：团队主要依赖手动测试，部分接口测试覆盖不全
      * 使用后：测试覆盖率从原来的60%提升至95%，更多接口得到验证
      *  使用前：版本迭代都需要进行大量的回归测试，手动测试耗时长且容易出错。
      * 使用后：回归测试时间从原来的8小时缩短至2小时，实现自动化执行
      * 使用前：开发和测试人员与沟通成本较高，协作效率较低。
      * 使用后：沟通成本降低了15%，协作效率提高20%，
      * 通过多场景断言，缺陷发现率提高30%，更多潜在问题在上线前被修复
      * 减少对测试人员的依赖，测试成本降低了20%，提高业务稳定性
      * 单项目月人力成本节约20%（更少人力做更多事情，效率更高，公司成本也降低）





















#### 第8集 Web UI自动化测试引擎模块简历编写

**简介：  滴云自动化测试平台-接口引擎简历编写**

* 滴云自动化测试平台-WebUI自动化测试引擎项目介绍

```
WebUI自动化测试引擎是云测平台核心引擎之一,基于Selenium WebDriver 自动生成测试脚本，使用者可以通过0代码方式实现UI自动化测试，支持主流的元素位方式，封装的UI操作组件支持鼠标、键盘、浏览器、等待、断言机制等；支持多种浏览器（如Chrome、Firefox等）的测试脚本执行；支持WebUI自动化测试多步骤编排，结合数据字典实现采用动态表单设计，支持灵活拓展更多元素和操作；实时展示测试过程中的进度和详细信息；生成详细的测试报告，包括测试通过率，失败原因
```

<img src="img/image-20240311184223947.png" alt="image-20240311184223947" style="zoom:50%;" />

* 回顾云测大课压测引擎开发目录和课程代码总结亮点

  * 编写简历案例说明

    * 主导接口自动化测试引擎整体架构设计+技术选型+数据库设计；

    * 负责Selenium4.X 多浏览器驱动上下文封装，支持二次拓展

    * 负责多UI用例步骤编排引擎解决方案设计和开发

    * 设计基于数据字典实现的动态表单，实现多WebUI步骤编排测试

    * 封装UI自动化核心操作组件：鼠标/键盘/浏览器/元素定位/快照截图/等待

    * 基于前端页面操作，实现零代码实现WebUI自动化测试

    * 设计多类型断言分发器骨架，支持二次拓展

    * 主导WebUI自动化测试报告设计和开发，实时查看用例步骤执行情况

    * 业绩【**靠这个说服老板或者面试官，汇报和面试都很有用**】

      * 测试覆盖率从原先的60%提升至90%，更多关键页面和功能得到验证。

      * 测试时间从手动测试的4小时缩短至自动化测试的30分钟

      * 缺陷发现率提升25%，更多潜在问题在上线前被发现。

      * 测试成本降低20%，减少了对大量测试人员的依赖。

      * 项目交付延期率降低了15%，提高了项目交付的稳定性。

      * 测试报告生成时间缩短40%，上线后缺陷率下降20%，增强了软件的可靠性

      * 团队协作效率提高了15%，减少了因沟通不畅导致的误解和返工。

        








